% types.bib -- Bibliography for work related to types in programming languages



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Immutability
%%%



@InProceedings{PoratBKM2000,
  author = 	 "Sara Porat and Marina Biberstein and Larry Koved and
                  Bilba Mendelson",
  title = 	 "Automatic detection of immutable fields in {Java}",
  NEEDpages = 	 "",
  booktitle =	 CASCON2000,
  year =	 2000,
  address =	 CASCON2000addr,
  month =	 CASCON2000date,
  abstract =
   "This paper introduces techniques to detect mutability of fields and classes
    in Java. A variable is considered to be mutable if a new value is stored
    into it, as well as if any of its reachable variables is mutable. We
    present a static flow-sensitive analysis algorithm which can be applied to
    any Java component. The analysis classifies fields and classes as either
    mutable or immutable. In order to facilitate open-world analysis, the
    algorithm identifies situations that expose variables to potential
    modification by code outside the component, as well as situations where
    variables are modified by the analyzed code. We also present an
    implementation of the analysis which focuses on detecting mutability of
    class variables, so as to avoid isolation problems. The implementation
    incorporates intra- and inter-procedural data-flow analyses and is shown to
    be highly scalable. Experimental results demonstrate the effectiveness of
    the algorithms."
}




@InProceedings{BibersteinGP01,
  author = 	 "Marina Biberstein and Joseph Gil and Sara Porat",
  title = 	 "Sealing, encapsulation, and mutability",
  booktitle = ECOOP2001,
  pages = 	 "28--52",
  year = 	 2001,
  address = 	 ECOOP2001addr,
  month = 	 ECOOP2001date,
}


@InProceedings{SkoglundW2001,
  author = 	 "Mats Skoglund and Tobias Wrigstad",
  title = 	 "A mode system for read-only references in {Java}",
  booktitle =	 FTFJP2001,
  NEEDpages = 	 "*",
  year =	 2001,
  address =	 FTFJP2001addr,
  month =	 FTFJP2001date,
}


@TechReport{MuellerPoetzsch-Heffter01a,
  author      = { M{\"u}ller, P. and Poetzsch-Heffter, A. },
  title       = { Universes: A Type System
                 for Alias and Dependency Control },
  institution = { Fernuniversit{\"a}t Hagen },
  year        = 2001,
  number      = 279,
  note        = {  }
}


@Article{DietlM2005,
  author = 	 "Werner Dietl and Peter M{\"u}ller",
  authorASCII =  "Peter Muller / Peter Mueller",
  title = 	 "Universes: Lightweight ownership for {JML}",
  journal = 	 JOT,
  year = 	 2005,
  volume = 	 4,
  number = 	 8,
  pages = 	 "5--32",
  month = 	 oct
}



@InProceedings{DietlDM2007,
  author = 	 "Werner Dietl and Sophia Drossopoulou and and Peter M{\"u}ller",
  authorASCII =  "Peter Muller",
  title = 	 "{G}eneric {U}niverse {T}ypes",
  titleASCII = 	 "Generic Universe Types",
  booktitle =    ECOOP2007,
  pages = 	 "28--53",
  year = 	 2007,
  address = 	 ECOOP2007addr,
  month = 	 ECOOP2007date,
  abstract =
   "Ownership is a powerful concept to structure the object store and to
    control aliasing and modifications of objects. This paper presents an
    ownership type system for a Java-like programming language with generic
    types. Like our earlier Universe type system, Generic Universe Types
    enforce the owner-as-modifier discipline. This discipline does not restrict
    aliasing, but requires modifications of an object to be initiated by its
    owner. This allows owner objects to control state changes of owned objects,
    for instance, to maintain invariants. Generic Universe Types require a
    small annotation overhead and provide strong static guarantees.  They are
    the first type system that combines the owner-as-modifier discipline with
    type genericity.",
}


@Article{KnieselT2001,
  author = 	 "G{\"u}nter Kniesel and Dirk Theisen",
  title = 	 "{JAC} --- Access right based encapsulation for {Java}",
  journal = 	 j-spe,
  year = 	 2001,
  volume =	 31,
  number =	 6,
  pages =	 "555--576"
}





@InProceedings{PechtchanskiS2002,
  author = 	 "Igor Pechtchanski and Vivek Sarkar",
  title = 	 "Immutability specification and its applications",
  booktitle =	 JavaGrande2002,
  pages =	 "202--211",
  year =	 2002,
  address =	 JavaGrande2002addr,
  month =	 JavaGrande2002date,
  abstract =
   "A location is said to be immutable if its value and the values of selected
    locations reachable from it are guaranteed to remain unchanged during a
    specified time interval. We introduce a framework for immutability
    specification, and discuss its application to code optimization. Compared
    to a final declaration, an immutability assertion in our framework can
    express a richer set of immutability properties along three dimensions ---
    lifetime, reachability and context. We present a framework for processing
    and verifying immutability annotations in Java, as well as extending
    optimizations so as to exploit immutability information. Preliminary
    experimental results show that a significant number (82\%) of read accesses
    could potentially be classified as immutable in our framework. Further, use
    of immutability information yields substantial reductions (33\% to 99\%) in
    the number of dynamic read accesses, and also measurable speedups in the
    range of 5\% to 10\% for certain benchmark programs."
}


@InProceedings{BoylandNR2001,
  author = 	 "John Boyland and James Noble and William Retert",
  title = 	 "Capabilities for sharing:
                  A generalisation of uniqueness and read-only",
  booktitle =	 ECOOP2001,
  pages =	 "2--27",
  year =	 2001,
  address =	 ECOOP2001addr,
  month =	 ECOOP2001date,
  abstract =
   "Many languages and language extensions include annotations on pointer
    variables such as ``read-only,'' ``unique,'' and ``borrowed''; many more
    annotations have been proposed but not implemented. Unfortunately, all
    these annotations are described individually and formalised independently -
    assuming they are formalised at all. In this paper, we show how these
    annotations can be subsumed into a general capability system for
    pointers. This system separates mechanism (defining the semantics of
    sharing and exclusion) from policy (defining the invariants that are
    intended to be preserved). The capability system has a well-defined
    semantics which can be used as a reference for the correctness of various
    extended type systems using annotations. Furthermore, it supports research
    in new less-restrictive type systems that permit a wider range of idioms to
    be statically checked."
}


@InProceedings{Boyland2005,
  author = 	 "John Boyland",
  title = 	 "Why we should not add \texttt{readonly} to {Java} (yet)",
  booktitle =	 FTFJP2005,
  NEEDpages = 	 "",
  year =	 2005,
  address =	 FTFJP2005addr,
  month =	 FTFJP2005date,
  abstract =
   "In this paper, I examine some of reasons that ``readonly'' style
    qualifiers have been proposed for Java, and also the principles behind the
    rules for these new qualifiers. I find that there is a mismatch between
    some of the motivating problems and the proposed solutions. Thus I urge
    Java designers to proceed with caution when adopting a solution to these
    sets of problems.",
}



@Misc{JSR163,
  author = 	 "Robert Field",
  title = 	 "{JSR} 163: {Java} Platform Profiling Architecture",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=163}",
  month = 	 sep # "~30,",
  year = 	 2004,
}

@Misc{JSR175,
  author = 	 "Joshua Bloch",
  title = 	 "{JSR} 175: A Metadata Facility for the {Java} Programming Language",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=175}",
  month = 	 sep # "~30,",
  year = 	 2004,
}


@Misc{JSR175-PFD2,
  author = 	 "Joshua Bloch",
  title = 	 "{JSR175}: A Program Annotation Facility for the {Java} Programming Language: Proposed Final Draft 2",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=175}",
  month = 	 aug # "~12,",
  year = 	 2004,
}


@Misc{JSR198,
  author = 	 "Jose Cronembold",
  title = 	 "{JSR} 198:  A Standard Extension {API} for {Integrated} {Development} {Environments}",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=198}",
  month = 	 may # "~8,",
  year = 	 2006,
}


@Misc{JSR199,
  author = 	 "Peter von der Ahe",
  title = 	 "{JSR} 199: {Java} Compiler {API}",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=199}",
  month = 	 dec # "~11,",
  year = 	 2006,
}

@Misc{JSR250,
  author = 	 "Rajiv Mordani",
  title = 	 "{JSR} 250: Common Annotations for the {Java} Platform",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=250}",
  month = 	 may # "~11,",
  year = 	 2006,
}

@Misc{JSR269,
  author = 	 "Joe Darcy",
  title = 	 "{JSR} 269: Pluggable Annotation Processing {API}",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=269}",
  month = 	 may # "~17,",
  year = 	 2006,
  note = 	 "Public review version",
}


@Misc{JSR305,
  author = 	 "William Pugh",
  title = 	 "{JSR} 305: Annotations for Software Defect Detection",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=305}",
  month = 	 aug # "~29,",
  year = 	 2006,
  note = 	 "JSR Review Ballot version",
}


@InProceedings{HaackPSS2007,
  author = 	 "Christian Haack and Erik Poll and Jan Sch{\"a}fer and Aleksy Schubert",
  title = 	 "Immutable objects for a {Java}-like language",
  booktitle = ESOP2007,
  pages = 	 "347--362",
  year = 	 2007,
  address = 	 ESOP2007addr,
  month = 	 ESOP2007date,
}


%%%
%%% Interning (aka canonicalization, hash-consing)
%%%


@Article{Ershov58,
  author = 	 "A. P. Ershov",
  title = 	 "On programming of arithmetic operations",
  journal = 	 CACM,
  year = 	 1958,
  volume = 	 1,
  number = 	 8,
  pages = 	 "3--6",
  month = 	 aug,
}


@Book{Allen78,
  author = 	 "John R. Allen",
  title = 	 "Anatomy of LISP",
  publisher = 	 "McGraw-Hill",
  year = 	 1978,
  address = 	 "New York",
}


@TechReport{Goto74,
  author = 	 "E. Goto",
  title = 	 "Monocopy and associative algorithms in an extended {Lisp}",
  institution =  "Information Science Laboratory, University of Tokyo",
  year = 	 1974,
  number = 	 "74-03",
  address = 	 "Tokyo, Japan",
  month = 	 may,
}


@InProceedings{VaziriTFD2007,
  author = 	 "Mandana Vaziri and Frank Tip and Stephen Fink and Julian Dolby",
  title = 	 "Declarative object identity using relation types",
  booktitle = 	 ECOOP2007,
  pages = 	 "54--78",
  year = 	 2007,
  address = 	 ECOOP2007addr,
  month = 	 ECOOP2007date,
}



@InProceedings{MarinovO2003,
  author = 	 "Darko Marinov and Robert O'Callahan",
  title = 	 "Object equality profiling",
  booktitle = OOPSLA2003,
  pages = 	 "313--325",
  year = 	 2003,
  address = 	 OOPSLA2003addr,
  month = 	 OOPSLA2003date,
  abstract =
   "We present \emph{Object Equality Profiling} (OEP), a new technique for
    helping programmers discover optimization opportunities in programs. OEP
    discovers opportunities for replacing a set of equivalent object instances
    with a single representative object. Such a set represents an opportunity for
    automatically or manually applying optimizations such as hash consing, heap
    compression, lazy allocation, object caching, invariant hoisting, and
    more. To evaluate OEP, we implemented a tool to help programmers reduce the
    memory usage of Java programs. Our tool performs a dynamic analysis that
    records all the objects created during a particular program run. The tool
    partitions the objects into equivalence classes, and uses collected timing
    information to determine when elements of an equivalence class could have
    been safely collapsed into a single representative object without affecting
    the behavior of that program run. We report the results of applying this
    tool to benchmarks, including two widely used Web application servers. Many
    benchmarks exhibit significant amounts of object equivalence, and in most
    benchmarks our profiler identifies optimization opportunities clustered
    around a small number of allocation sites. We present a case study of using
    our profiler to find simple manual optimizations that reduce the average
    space used by live objects in two SpecJVM benchmarks by 47\% and 38\%
    respectively.",
}


@InProceedings{ZendraC99,
  author = 	 "Olivier Zendra and Dominique Colnet",
  title = 	 "Towards safer aliasing with the {Eiffel} language",
  booktitle = IWAOOS99,
  pages = 	 "153--154",
  year = 	 1999,
  OMITvolume = 	 1743,
  OMITseries = 	 LNCS,
  address = 	 IWAOOS99addr,
  month = 	 IWAOOS99date,
}


@InProceedings{120750,
 author = {Richard J. Fateman},
 title = {Canonical representations in Lisp and applications to computer algebra systems},
 booktitle = {ISSAC '91: Proceedings of the 1991 international symposium on Symbolic and algebraic computation},
 year = {1991},
 isbn = {0-89791-437-6},
 pages = {360--369},
 location = {Bonn, West Germany},
 doi = {http://doi.acm.org/10.1145/120694.120750},
 publisher = {ACM Press},
 address = {New York, NY, USA},
 }


@article{231195,
 author = {Richard J. Fateman and Mark Hayden},
 title = {Speeding up Lisp-based symbolic mathematics},
 journal = {SIGSAM Bull.},
 volume = {30},
 number = {1},
 year = {1996},
 issn = {0163-5824},
 pages = {25--30},
 doi = {http://doi.acm.org/10.1145/231191.231195},
 publisher = {ACM Press},
 address = {New York, NY, USA},
 }




@InProceedings{FilliatreC2006,
  author = 	 "Jean-Christophe Filli\^{a}tre and Sylvain Conchon",
  authorASCII =	 "Jean-Christophe Filliatre and Sylvain Conchon",
  title = 	 "Type-safe modular hash-consing",
  booktitle = 	 ML2006,
  pages = 	 "12--19",
  year = 	 2006,
  address = 	 ML2006addr,
  month = 	 ML2006date,
}


%% These last few citations are unrelated to interning, but seemed to be at
%% first glance.

@article{359667,
 author = {Jay M. Spitzen and Karl N. Levitt and Lawrence Robinson},
 title = {An example of hierarchical design and proof},
 journal = CACM,
 volume = {21},
 month = dec,
 number = {12},
 year = {1978},
 issn = {0001-0782},
 pages = {1064--1075},
 doi = {http://doi.acm.org/10.1145/359657.359667},
 publisher = {ACM Press},
 address = {New York, NY, USA},
 }






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type qualifiers in general (not immutability)
%%%

@InProceedings{FosterFFA99,
  author =    "Jeffrey S. Foster and Manuel F{\"{a}}hndrich and
               Alexander Aiken",
  title =     "A theory of type qualifiers",
  pages =     "192--203",
  booktitle = PLDI99,
  year =      1999,
  address =   PLDI99addr,
  month =     PLDI99date
}




@InProceedings{foster:pldi02,
  author =    {Jeffrey S. Foster and Tachio Terauchi and Alex Aiken},
  title =     "Flow-sensitive type qualifiers",
  pages =     {1--12},
  booktitle = PLDI2002,
  year =      2002,
  address =   PLDI2002addr,
  month =     PLDI2002date
}


@Manual{ElsmanFA99,
  title = 	 "Carillon --- A System to Find {Y2K} Problems in {C} Programs",
  author = 	 "Martin Elsman and Jeffrey S. Foster and Alexander Aiken",
  month = 	 jul # "~30,",
  year = 	 1999,
  abstract =
   "Carillon is a simple, fast, and effective type-based system for finding Y2K
    errors in C programs. Carillon extends the standard C type system with a
    user-defined set of date-related type qualifiers. The user annotates
    date-related functions with the appropriate qualifiers, and Carillon checks
    the program for Y2K errors.
    \par
    Carillon displays the results of the Y2K analysis in an interactive Emacs
    buffer. Program variables are colored according to the kind of Y2K
    information they may contain, and the user can click on program variables
    to see the exact Y2K type inferred by the analysis.
    \par
    The system has been used successfully to verify Y2K readiness of programs
    and to locate Y2K errors.",
  URL =          "www.cs.berkeley.edu/Research/Aiken/carillon/",
}



@InProceedings{GreenfieldboyceF2007,
  author = 	 "David Greenfieldboyce and Jeffrey S. Foster",
  title = 	 "Type qualifier inference for {Java}",
  booktitle =    OOPSLA2007,
  pages = 	 "321--336",
  year = 	 2007,
  address = 	 OOPSLA2007addr,
  month = 	 OOPSLA2007date,
  abstract =
   "Java's type system provides programmers with strong guarantees of type and
    memory safety, but there are many important properties not captured by
    standard Java types. We describe JQual, a tool that adds user-defined type
    qualifiers to Java, allowing programmers to quickly and easily incorporate
    extra lightweight, application-specific type checking into their
    programs. JQual provides type qualifier inference, so that programmers need
    only add a few key qualifier annotations to their program, and then JQual
    infers any remaining qualifiers and checks their consistency. We explore
    two applications of JQual. First, we introduce opaque and enum qualifiers
    to track C pointers and enumerations that flow through Java code via the
    JNI. In our benchmarks we found that these C values are treated correctly,
    but there are some places where a client could potentially violate
    safety. Second, we introduce a readonly qualifier for annotating references
    that cannot be used to modify the objects they refer to.  We found that
    JQual is able to automatically infer readonly in many places on method
    signatures. These results suggest that type qualifiers and type qualifier
    inference are a useful addition to Java.",
}



@Misc{GreenfieldboyceF2005,
  author = 	 "David Greenfieldboyce and Jeffrey S. Foster",
  title = 	 "Type qualifiers for {Java}",
  howpublished = "\url{http://www.cs.umd.edu/Grad/scholarlypapers/papers/greenfiledboyce.pdf}",
  month = 	 aug # "~8,",
  year = 	 2005,
  supersededby = "GreenfieldboyceF2007",
}




@InProceedings{ChinMM2005,
  author = 	 "Brian Chin and Shane Markstrum and Todd Millstein",
  title = 	 "Semantic type qualifiers",
  booktitle =	 PLDI2005,
  pages = 	 "85--95",
  year =	 2005,
  address =	 PLDI2005addr,
  month =	 PLDI2005date,
  abstract =
   "We present a new approach for supporting user-defined type refinements,
    which augment existing types to specify and check additional invariants of
    interest to programmers. We provide an expressive language in which users
    define new refinements and associated type rules. These rules are
    automatically incorporated by an \emph{extensible typechecker} during
    static typechecking of programs. Separately, a \emph{soundness checker}
    automatically proves that each refinement's type rules ensure the intended
    invariant, for all possible programs. We have formalized our approach and
    have instantiated it as a framework for adding new type qualifiers to C
    programs. We have used this framework to define and automatically prove
    sound a host of type qualifiers of different sorts, including \texttt{pos}
    and \texttt{neg} for integers, \texttt{tainted} and \texttt{untainted} for
    strings, and \texttt{nonnull} and \texttt{unique} for pointers, and we have
    applied our qualifiers to ensure important invariants on open-source C
    programs.",
}


@InProceedings{ChinMMP2006,
  author = 	 "Brian Chin and Shane Markstrum and Todd Millstein and Jens Palsberg",
  title = 	 "Inference of user-defined type qualifiers and qualifier rules",
  booktitle = ESOP2006,
  pages = 	 "264--278",
  year = 	 2006,
  address = 	 ESOP2006addr,
  month = 	 ESOP2006date,
}



@InProceedings{MandelbaumWH2003,
  author = 	 "Yitzhak Mandelbaum and David Walker and Robert Harper",
  title = 	 "An effective theory of type refinements",
  booktitle = ICFP2003,
  pages = 	 "213--225",
  year = 	 2003,
  address = 	 ICFP2003addr,
  month = 	 ICFP2003date,
  abstract =
   "We develop an explicit two level system that allows programmers to reason
    about the behavior of effectful programs. The first level is an ordinary
    ML-style type system, which confers standard properties on program
    behavior. The second level is a conservative extension of the first that
    uses a logic of type refinements to check more precise properties of
    program behavior. Our logic is a fragment of intuitionistic linear logic,
    which gives programmers the ability to reason locally about changes of
    program state. We provide a generic resource semantics for our logic as
    well as a sound, decidable, syntactic refinement-checking system. We also
    prove that refinements give rise to an optimization principle for
    programs. Finally, we illustrate the power of our system through a number
    of examples.",
}




@InProceedings{deline04typestates,
  author = 	 "Robert DeLine and Manuel F{\"a}hndrich",
  title = 	 "Typestates for objects",
  booktitle =	 ECOOP2004,
  pages =	 "465--490",
  year = 	 2004,
  address =	 ECOOP2004addr,
  month =	 ECOOP2004date,
}


@InProceedings{DeLineF2001,
  author = 	 "Robert DeLine and Manuel F{\"a}hndrich",
  title = 	 "Enforcing high-level protocols in low-level software",
  booktitle = PLDI2001,
  pages = 	 "59--69",
  year = 	 2001,
  address = 	 PLDI2001addr,
  month = 	 PLDI2001date,
}


@InProceedings{ShankarTFW2001,
  author = 	 "Umesh Shankar and Kunal Talwar and Jeffrey S. Foster and David Wagner",
  title = 	 "Detecting format string vulnerabilities with type qualifiers",
  booktitle = USENIXSec2001,
  NEEDpages = 	 "*",
  year = 	 2001,
  address = 	 USENIXSec2001addr,
  month = 	 USENIXSec2001date,
}


@InProceedings{VolpanoS97,
  author = 	 "Dennis M. Volpano and Geoffrey Smith",
  title = 	 "A type-based approach to program security",
  booktitle = TAPSOFT97,
  pages = 	 "607--621",
  year = 	 1997,
  address = 	 TAPSOFT97addr,
  month = 	 TAPSOFT97date,
}


@InProceedings{PalsbergO95,
  author = 	 "Jens Palsberg and Peter {\O}rb{\ae}k",
  authorASCII =	 "Peter Orbaek",
  title = 	 "Trust in the $\lambda$-calculus",
  booktitle =    SAS95,
  pages = 	 "314--329",
  year = 	 1995,
  address = 	 SAS95addr,
  month = 	 SAS95date,
}




@InProceedings{PratikakisSH2004,
  author = 	 "Polyvios Pratikakis and Jaime Spacco and Michael Hicks",
  title = 	 "Transparent proxies for {Java} futures",
  booktitle = OOPSLA2004,
  pages = 	 "206--223",
  year = 	 2004,
  address = 	 OOPSLA2004addr,
  month = 	 OOPSLA2004date,
}


@InProceedings{JohnsonW2004,
  author = 	 "Rob Johnson and David Wagner",
  title = 	 "Finding user/kernel pointer bugs with type inference",
  booktitle = USENIXSec2004,
  pages = 	 "119--134",
  year = 	 2004,
  address = 	 USENIXSec2004addr,
  month = 	 USENIXSec2004date,
}



@Article{YelickSPMLKHGGCA1998,
  author = 	 "Kathy Yelick and Luigi Semenzato and Geoff Pike and Carleton Miyamoto and Ben Liblit and Arvind Krishnamurthy and Paul Hilfinger and Susan Graham and David Gay and Phil Colella and Alex Aiken",
  title = 	 "Titanium: A high-performance {Java} dialect",
  journal = 	 "Concurrency: Practice and Experience",
  year = 	 1998,
  volume = 	 10,
  number = 	 "11--13",
  pages = 	 "825--836",
  month = 	 sep # "--" # nov,
  abstract =
   "Titanium is a language and system for high-performance parallel
    scientific computing. Titanium uses Java as its base, thereby leveraging
    the advantages of that language and allowing us to focus attention on
    parallel computing issues. The main additions to Java are immutable
    classes, multidimensional arrays, an explicitly parallel SPMD model of
    computation with a global address space, and zone-based memory
    management. We discuss these features and our design approach, and
    report progress on the development of Titanium, including our current
    driving application: a three-dimensional adaptive mesh refinement
    parallel Poisson solver.",
}




%%%
%%% Non-null (nonnull) types and nullness/nullity analysis
%%%





@InProceedings{FahndrichL2003,
  author = 	 "Manuel F{\"a}hndrich and K. Rustan M. Leino",
  authorASCII =  "Manuel Fahndrich",
  title = 	 "Declaring and checking non-null types in an
                  object-oriented language",
  booktitle =	 OOPSLA2003,
  pages = 	 "302--312",
  year =	 2003,
  address =	 OOPSLA2003addr,
  month =	 OOPSLA2003date,
  abstract =
   "Distinguishing non-null references from possibly-null references at the
    type level can detect null-related errors in object-oriented programs at
    compile-time. This paper gives a proposal for retrofitting a language such
    as C\# or Java with non-null types. It addresses the central complications
    that arise in constructors, where declared non-null fields may not yet have
    been initialized, but the partially constructed object is already
    accessible. The paper reports experience with an implementation for
    annotating and checking null-related properties in C\# programs.",
}




@InProceedings{FahndrichX2007,
  author = 	 "Manuel F{\"a}hndrich and Songtao Xia",
  authorASCII =	 "Manuel Fahndrich and Songtao Xia",
  title = 	 "Establishing object invariants with delayed types",
  booktitle =    OOPSLA2007,
  pages = 	 "337-350",
  year = 	 2007,
  address = 	 OOPSLA2007addr,
  month = 	 OOPSLA2007date,
}






@TechReport{ChalinJ2006,
  author = 	 "Patrice Chalin and Perry James",
  title = 	 "Non-null references by default in {Java}:  Alleviating the nullity annotation burden",
  institution =  "Concordia University",
  year = 	 2006,
  type = 	 "ENCS-CSE",
  number = 	 "2006-003",
  address = 	 Montreal,
  month = 	 dec,
  note = 	 "Revision 3s",
  supersededby = "ChalinJ2007",
}

@InProceedings{ChalinJ2007,
  author = 	 "Patrice Chalin and Perry R. James",
  title = 	 "Non-null references by default in {Java}:  Alleviating the nullity annotation burden",
  booktitle = ECOOP2007,
  pages = 	 "227--247",
  year = 	 2007,
  address = 	 ECOOP2007addr,
  month = 	 ECOOP2007date,
  abstract =
   "With Java 5 annotations, we note a marked increase in tools that statically
    detect potential null dereferences. To be effective such tools require that
    developers annotate declarations with nullity modifiers and have annotated
    API libraries. Unfortunately, in our experience specifying moderately large
    code bases, the use of non-null annotations is more labor intensive than it
    should be.  Motivated by this experience, we conducted an empirical study
    of 5 open source projects totaling 700 KLOC which confirms that on average,
    3/4 of declarations are meant to be non-null, by design. Guided by these
    results, we propose adopting a non-null-by-default semantics. This new
    default has advantages of better matching general practice, lightening
    developer annotation burden and being safer. We adapted the Eclipse JDT
    Core to support the new semantics, including the ability to read the
    extensive API library specifications written in the Java Modeling Language
    (JML\@). Issues of backwards compatibility are addressed.",
}



@TechReport{ChalinJK2007,
  author = 	 "Patrice Chalin and Perry R. James and George Karabotsos",
  title = 	 "The architecture of {JML4}, a proposed integrated verification environment for {JML}",
  institution =  "Concordia University",
  year = 	 2007,
  type = 	 "ENCS-CSE",
  number = 	 "2007-006",
  month = 	 may,
  note = 	 "Revision 1",
}





@InProceedings{CieleckiFJJ2006,
  author = 	 "Maciej Cielecki and J\c{e}drzej Fulara and Krzysztof Jakubczyk and {\L}ukasz Jancewicz and Jacek Chrzaszcz and Aleksy Schubert and {\L}ukasz Kami{\'n}ski",
  authorASCII = 	 "Maciej Cielecki and Jedrzej Fulara and Krzysztof Jakubczyk and Lukasz Jancewicz and Jacek Chrzaszcz and Aleksy Schubert and Lukasz Kaminski",
  title = 	 "Propagation of {JML} non-null annotations in {Java} programs",
  booktitle = PPPJ2006,
  pages = 	 "135--140",
  year = 	 2006,
  address = 	 PPPJ2006addr,
  month = 	 PPPJ2006date,
  abstract =
   "Development of high quality code is notably difficult. Tools that help
    maintaining the proper quality of code produced by programmers can be very
    useful: they may increase the quality of produced software and help
    managers to ensure that the product is ready for the market. One of such
    tools is ESC/Java2, a static checker of Java Modeling Language
    annotations. These annotations can be used to ensure that a certain
    assertion is satisfied during the execution of the program, among the
    others --- to ensure that a certain variable never has a null
    value. Unfortunately, using ESC/Java2 can be very troublesome and
    time-consuming for programmers, as it lacks a friendly user interface and a
    function that propagates annotations. We present CANAPA, a tool that can
    highly reduce time and effort of eliminating null pointer exceptions in
    Java code. This tool can automatically propagate JML non-null annotations
    and comes with a handy Eclipse plug-in. We believe that functionality of
    CANAPA will minimize the effort required to benefit from using the JML
    non-null checking.",
}



@PhdThesis{Ekman2006,
  author = 	 "Torbj{\"o}rn Ekman",
  authorASCII =	 "Torbjorn Ekman",
  title = 	 "Extensible compiler construction",
  school = 	 "Lund University Department of Computer Science",
  year = 	 2006,
  address = 	 "Lund, Sweden",
}


@InProceedings{EkmanH2007:JastAdd,
  author = 	 "Torbj{\"o}rn Ekman and G{\"o}rel Hedin",
  authorASCII =	 "Torbjorn Ekman and Gorel Hedin",
  title = 	 "The {JastAdd} extensible {Java} compiler",
  booktitle = OOPSLA2007,
  pages = 	 "1--18",
  year = 	 2007,
  address = 	 OOPSLA2007addr,
  month = 	 OOPSLA2007date,
}



@Article{EkmanH2007:NonNull,
  author = 	 "Torbj{\"o}rn Ekman and G{\"o}rel Hedin",
  authorASCII =	 "Torbjorn Ekman and Gorel Hedin",
  title = 	 "Pluggable checking and inferencing of non-null types for {Java}",
  journal = 	 JOT,
  year = 	 2007,
  volume = 	 6,
  number = 	 9,
  pages = 	 "455--475",
  month = 	 oct,
  abstract =
   "We have implemented a non-null type checker for Java and a new non-null
    inferencing algorithm for analyzing legacy code. The tools are modular
    extensions to the JastAdd extensible Java compiler, illustrating how
    pluggable type systems can be achieved. The resulting implementation is
    compact, less than 230 lines of code for the non-null checker and 460
    for the inferencer. Non-null checking is a local analysis with little
    effect on compilation time. The inferencing algorithm is a
    whole-program analysis, yet it runs sufficiently fast for practical
    use, less than 10 seconds for 100.000 lines of code. We ran our
    inferencer on a large part of the JDK library, and could detect that
    around 70% of the dereferences, and around 24% of the method return
    values, were guaranteed to be non-null.",
}



@MastersThesis{Engelen2006,
  author = 	 "Arnout F. M. Engelen",
  title = 	 "Nullness analysis of {Java} source code",
  school = 	 "University of Nijmegen Dept. of Computer Science",
  year = 	 2006,
  month = 	 aug # "~10",
  abstract =
   "The research question for this project is as follows:  What is the
    current state of the art in annotation assistance, and what are the most
    relevant requirements and design considerations when implementing an
    annotations assistant?",
  usesDaikon = 1,
  downloads = "http://www.cs.ru.nl/iii/onderwijs/afstudereninfo/scripties/2006/ArnoutEngelenScriptie.pdf PDF",
}





@inproceedings{1028717,
 author = {Hovemeyer, David and Pugh, William},
 title = {Finding bugs is easy},
 booktitle = {OOPSLA '04: Companion to the 19th annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
 year = {2004},
 isbn = {1-58113-833-4},
 pages = {},
 location = {Vancouver, BC, CANADA},
 doi = {http://doi.acm.org/10.1145/1028664.1028717},
 publisher = {ACM},
 address = {New York, NY, USA},
 }

@InProceedings{HovemeyerP2004,
  author = 	 "David Hovemeyer and William Pugh",
  title = 	 "Finding bugs is easy",
  booktitle =    OOPSLA2004companion,
  pages = 	 "132--136",
  year = 	 2004,
  address = 	 OOPSLA2004addr,
  month = 	 OOPSLA2004date,
  abstract =
   "Many techniques have been developed over the years to automatically
   find bugs in software. Often, these techniques rely on formal methods
   and sophisticated program analysis. While these techniques are valuable,
   they can be difficult to apply, and they aren't always effective in
   finding real bugs.
   \par
   \emph{Bug patterns} are code idioms that are often errors. We have
   implemented automatic detectors for a variety of bug patterns found in
   Java programs. In this extended abstract, we describe how we have used
   bug pattern detectors to find serious bugs in several widely used Java
   applications and libraries. We have found that the effort required to
   implement a bug pattern detector tends to be low, and that even
   extremely simple detectors find bugs in real applications.
   \par
   From our experience applying bug pattern detectors to real programs, we
   have drawn several interesting conclusions. First, we have found that
   even well tested code written by experts contains a surprising number of
   obvious bugs. Second, Java (and similar languages) have many language
   features and APIs which are prone to misuse. Finally, that simple
   automatic techniques can be effective at countering the impact of both
   ordinary mistakes and misunderstood language features.",
}

@InProceedings{HovemeyerSP2006,
  author = 	 "David Hovemeyer and Jaime Spacco and William Pugh",
  title = 	 "Evaluating and tuning a static analysis to find null pointer bugs",
  booktitle = 	 PASTE2005,
  pages = 	 "13--19",
  year = 	 2005,
  address = 	 PASTE2005addr,
  month = 	 PASTE2005date,
  abstract =
   "Using static analysis to detect memory access errors, such as null pointer
    dereferences, is not a new problem.  However, much of the previous work has
    used rather sophisticated analysis techniques in order to detect such
    errors.  In this paper we show that simple analysis techniques can be used
    to identify many such software defects, both in production code and in
    student code.  In order to make our analysis both simple and effective, we
    use a non-standard analysis which is neither complete nor sound.  However,
    we find that it is effective at finding an interesting class of software
    defects.  We describe the basic analysis we perform, as well as the
    additional errors we can detect using techniques such as annotations and
    inter-procedural analysis.  In studies of both production software and
    student projects, we find false positive rates of around 20\% or less.  In
    the student code base, we find that our static analysis techniques are
    able to pinpoint 50\% to 80\% of the defects leading to a null pointer
    exception at runtime.",
}


@InProceedings{HovemeyerP2007,
  author = 	 "David Hovemeyer and William Pugh",
  title = 	 "Finding more null pointer bugs, but not too many",
  booktitle = 	 PASTE2007,
  pages = 	 "9--14",
  year = 	 2007,
  address = 	 PASTE2007addr,
  month = 	 PASTE2007date,
}



@MastersThesis{Artho2001,
  author = 	 "Cyrille Artho",
  title = 	 "Finding faults in multi-threaded programs",
  school = 	 "Swiss Federal Institute of Technology",
  year = 	 2001,
  month = 	 mar # "~15,",
  abstract =
   "Multi-threaded programming creates the fundamental problem that the
    execution of a program is no longer deterministic, because the thread
    schedule is not controlled by the application. This causes traditional
    testing methods to be rather ineffective. Trilogy, producing many
    multi-threaded server programs, also has to deal with the limitations of
    regression testing. New approaches to this problem --- static and extended
    dynamic checking --- promise to ameliorate the situation. Many tools are in
    development that try to find faults in multi-threaded programs in new ways.
    \par
    The first part of this report describes a detailed evaluation of a wide
    variety of dynamic and static checkers. That comparison always had the
    applicability to industrial software in mind. While none of the checking
    tools was a clear winner, certain tools are more useful in practice than
    others.
    \par
    Because simple cases are the most common ones in practice, the decision was
    made to extend Jlint, a simple, fast static Java program checker. The new
    Jlint can now also check for deadlocks in synchronized blocks in Java,
    which results in improved faultfinding capabilities. The extensions and
    their usefulness in an industrial environment are described in the second
    part of the report. Jlint has been applied to many core packages of
    Trilogy, and also a few other software packages, and shown various degrees
    of success.",
}


@Unpublished{MaleP2007,
  author = 	 "Chris Male and David J. Pearce",
  title = 	 "Non-null type inference with type aliasing for {Java}",
  note = 	 "\url{http://www.mcs.vuw.ac.nz/~djp/files/MP07.pdf}",
  month = 	 aug # "~20,",
  year = 	 2007,
  abstract =
   "Java's annotation mechanism allows us to extend its type system with
    non-null types. Type checking is a cumbersome approach to enforcing them,
    since conditionals provide the main source of nullness information. We
    present a novel non-null type inference system which extracts nullness
    information and type aliasing relationships from conditionals. We formalise
    this for a subset of Java Bytecode and report on experiences using an
    implementation of it.",
}



@InProceedings{MalePPD2008,
  author = 	 "Chris Male and David Pearce and Alex Potanin and Constantine Dymnikov",
  title = 	 "Java bytecode verification for {@NonNull} types",
  booktitle = CC2008,
  pages = 	 "229--244",
  year = 	 2008,
  address = 	 CC2008addr,
  month = 	 CC2008date,
  abstract =
   "Java's annotation mechanism allows us to extend its type system with
    non-null types. However, checking such types cannot be done using the
    existing bytecode verification algorithm. We extend this algorithm to
    verify non-null types using a novel technique that identifies aliasing
    relationships between local variables and stack locations in the
    JVM. We formalise this for a subset of Java Bytecode and report on
    experiences using our implementation.",
}



@InProceedings{Spoto2008,
  author = 	 "Fausto Spoto",
  title = 	 "Nullness analysis in boolean form",
  booktitle = SEFM2008,
  NEEDpages = 	 "*",
  year = 	 2008,
  address = 	 SEFM2008addr,
  month = 	 SEFM2008date,
  abstract =
   "Attempts to dereference \texttt{null} result in an exception or a
    segmentation fault. Hence it is important to know those program points
    where this might occur and prove the others (or the entire program)
    \emph{safe}. Nullness analysis of computer programs checks or infers
    non-\texttt{null} annotations for variables and object fields. Most
    nullness analyses currently use run-time checks or are incorrect or only
    verify manual annotations. We use here abstract interpretation to build and
    prove correct a static nullness analysis for Java bytecode which
    \emph{infers} non-\texttt{null} annotations. It is based on Boolean
    formulas, implemented with binary decision diagrams. Our experiments show
    it faster and more precise than the correct nullness analysis by Hubert,
    Jensen and Pichardie. We deal with static fields and exceptions, which is
    not the case of most other analyses. We claim that the result is
    theoretically clean and the implementation strong and scalable.",
}



@InProceedings{CousotC76:ISP,
  author =       "Patrick M. Cousot and Radhia Cousot",
  title = 	 "Static determination of dynamic properties of programs",
  booktitle = "2nd International Symposium on Programming",
  pages = 	 "106--130",
  year = 	 1976,
  address = 	 "Paris, France",
  month = 	 apr,
}



@InProceedings{HubertJP2008,
  author = 	 "Laurent Hubert and Thomas Jensen and David Pichardie",
  title = 	 "Semantic foundations and inference of non-null annotations",
  booktitle = FMOODS2008,
  pages = 	 "132--149",
  year = 	 2008,
  NEEDaddress = 	 FMOODS2008addr,
  NEEDmonth = 	 FMOODS2008date,
}


@INPROCEEDINGS{hubert09:soundly_handling_static_fields,
   AUTHOR = {Laurent Hubert and David Pichardie},
   TITLE = {Soundly Handling Static Fields: Issues, Semantics
                   and Analysis},
   BOOKTITLE = {Proceedings of ByteCode'09},
   INSTITUTION = {CNRS/INRIA/IRISA},
   YEAR = 2009,
   MONTH = {March},
   NOTE = {(To Appear)},
   PDF = {http://www.trebuh.net/publi/2009bytecode.pdf},
   SLIDES = {http://www.trebuh.net/publi/2009bytecode_slides.pdf},
}


@InProceedings{NandaS2009,
  author = 	 "Mangala Gowri Nanda and Saurabh Sinha",
  title = 	 "Accurate interprocedural null-dereference analysis for {Java}",
  booktitle = ICSE2009,
  pages = 	 "133-143",
  year = 	 2009,
  address = 	 ICSE2009addr,
  month = 	 ICSE2009date,
  abstract =
   "Null dereference is a commonly occurring defect in Java programs, and
    many static-analysis tools identify such defects. However, most of the
    existing tools perform a limited interprocedural analysis. In this
    paper, we present an interprocedural path-sensitive and
    context-sensitive analysis for identifying null dereferences. Starting
    at a dereference statement, our approach performs a backward
    demand-driven analysis to identify precisely paths along which null
    values may flow to the dereference. The demand-driven analysis avoids an
    exhaustive program exploration, which lets it scale to large
    programs. We present the results of empirical studies conducted using
    large open-source and commercial products. Our results show that: (1)
    our approach detects fewer false positives, and significantly more
    interprocedural true positives, than other commonly used tools; (2) the
    analysis scales to large subjects; and (3) the identified defects are
    often deleted in subsequent releases, which indicates that the reported
    defects are important.",
}


@Article{FreundM1999,
  author = 	 "Freund, Stephen N. and Mitchell, John C.",
  title = 	 "A type system for object initialization in the {Java} bytecode language",
  journal = 	 TOPLAS,
  year = 	 1999,
  volume = 	 21,
  number = 	 6,
  pages = 	 "1196--1250",
  month = 	 nov,
}



%%%
%%% Pluggable type systems
%%%

@Misc{checker-framework-website-20100203,
  key = 	 "Checker Framework",
  title = 	 "Checker Framework website",
  howpublished = "\url{http://types.cs.washington.edu/checker-framework/}",
  month = 	 feb # "~3,",
  year = 	 2010,
  IGNOREnote = 	 "Accessed Feb 3, 2010",
}

@Misc{annotation-file-utilities-website-20100203,
  key = 	 "Annotation File Utilities",
  title = 	 "Annotation File Utilities website",
  howpublished = "\url{http://types.cs.washington.edu/annotation-file-utilities/}",
  month = 	 feb # "~3,",
  year = 	 2010,
  IGNOREnote = 	 "Accessed Feb 3, 2010",
}

@InProceedings{Bracha2004,
  author = 	 "Gilad Bracha",
  title = 	 "Pluggable type systems",
  booktitle =    RDL2004,
  NEEDpages = 	 "*",
  year = 	 2004,
  address = 	 OOPSLA2004addr,
  month = 	 RDL2004date,
  abstract =
   "Traditionally, statically typed programming languages incorporate a
    built-in static type system. This system is typically mandatory: every
    legal program must successfully typecheck according to the rules of the
    type system. In contrast, optional type systems are neither syntactically
    nor semantically required, and have no effect on the dynamic semantics of
    the language. This in turn enables pluggable type systems [Bra03, Bra04],
    allowing multiple type systems to be used simultaneously and/or
    sequentially for various semantic analyses. We argue that pluggable types
    can provide most of the advantages of mandatory type systems without most
    of the drawbacks.",
}


@InProceedings{Fong2004,
  author = 	 "Philip W. L. Fong",
  title = 	 "Pluggable verification modules: An extensible protection mechanism for the {JVM}",
  booktitle = OOPSLA2004,
  pages = 	 "404--418",
  year = 	 2004,
  address = 	 OOPSLA2004addr,
  month = 	 OOPSLA2004date,
}


@InProceedings{BurdyP2006,
  author = 	 "Lilian Burdy and Mariela Pavlova",
  title = 	 "Java bytecode specification and verification",
  booktitle = SAC2006,
  pages = 	 "1835--1839",
  year = 	 2006,
  address = 	 SAC2006addr,
  month = 	 SAC2006date,
  doi = {http://doi.acm.org/10.1145/1141277.1141708},
  abstract =
   "We propose a framework for establishing the correctness of untrusted Java
    bytecode components w.r.t. to complex functional and/or security
    policies. To this end, we define a bytecode specification language (BCSL)
    and a weakest precondition calculus for sequential Java bytecode. BCSL and
    the calculus are expressive enough for verifying non-trivial properties of
    programs, and cover most of sequential Java bytecode, including exceptions,
    subroutines, references, object creation and method calls. Our approach
    does not require that bytecode components are provided with their source
    code. Nevertheless, we provide a means to compile JML annotations into BCSL
    annotations by defining a compiler from the Java Modeling Language (JML) to
    BCSL. Our compiler can be used in combination with most Java compilers to
    produce extended class files from JML-annotated Java source programs. All
    components, including the verification condition generator and the compiler
    are implemented and integrated in the Java Applet Correctness Kit (JACK).",
}


@InProceedings{BartheBCGHLPR2006,
  author = 	 "G. Barthe and L. Burdy and J. Charles and B. Gr{\'e}goire and M. Huisman and J.-L. Lanet and M. Pavlova and A. Requet",
  title = 	 "{JACK}:  A tool for validation of security and behaviour of {Java} applications",
  booktitle = FMCO2006,
  NEEDpages = 	 "*",
  year = 	 2006,
  address = 	 FMCO2006addr,
  month = 	 FMCO2006date,
}


@InProceedings{AndreaeNMM2006,
  author = 	 "Chris Andreae and James Noble and Shane Markstrum and Todd Millstein",
  title = 	 "A framework for implementing pluggable type systems",
  booktitle = OOPSLA2006,
  pages = 	 "57--74",
  year = 	 2006,
  address = 	 OOPSLA2006addr,
  month = 	 OOPSLA2006date,
  abstract =
   "Pluggable types have been proposed to support multiple type systems in the
    same programming language. We have designed and implemented JavaCOP, a
    program constraint system for implementing practical pluggable type systems
    for Java. JavaCOP enforces user-defined typing constraints written in a
    declarative and expressive rule language. We have validated our design by
    (re)implementing a range of type systems and program checkers. By using a
    program constraint system to implement pluggable types, programmers are
    able to check that their programs will operate correctly in restricted
    environments, adhere to strict programming rules, avoid null pointer errors
    or scoped memory exceptions, and meet style guidelines, while programming
    language researchers can easily experiment with novel type systems.",
}
@Misc{MillsteinJavaCOP,
  author = 	 "Todd Millstein",
  howpublished = "Personal communication",
  month = 	 aug # "~5,",
  year = 	 2007,
}



@TechReport{MarkstrumMEM2008,
  author = 	 "Shane Markstrum and Daniel Marino and Matthew Esquivel and Todd Millstein",
  title = 	 "Practical enforcement and testing of pluggable type systems",
  institution =  "UCLA",
  year = 	 2008,
  number = 	 "CSD-TR-080013",
  month = 	 apr,
}




@InProceedings{NystromCM2003,
  author = 	 "N. Nystrom and M. R. Clarkson and A. C. Myers",
  title = 	 "Polyglot: An extensible compiler framework for {Java}",
  booktitle = CC2003,
  pages =        "138--152",
  year = 	 2003,
  address = 	 CC2003addr,
  month = 	 CC2003date,
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Parameterized types (generics)
%%%


@InProceedings{BrachaOSW98,
  author = 	 "Gilad Bracha and Martin Odersky and David Stoutamire and Philip Wadler",
  title = 	 "Making the Future Safe for the Past: Adding Genericity to the {Java} Programming Language",
  booktitle =	 OOPSLA98,
  pages =	 "183--200",
  year =	 1998,
  address =	 OOPSLA98addr,
  month =	 OOPSLA98date
}



@InProceedings{Duggan99,
  author = 	 "Dominic Duggan",
  title = 	 "Modular type-based reverse engineering of parameterized
                  types in {Java} code",
  booktitle =	 OOPSLA99,
  pages =	 "97--113",
  year =	 1999,
  address =	 OOPSLA99addr,
  month =	 OOPSLA99date
}




@InProceedings{WangS01,
  author = 	 "Tiejun Wang and Scott Smith",
  title = 	 "Precise constraint-based type inference for {Java}",
  booktitle =	 ECOOP2001,
  pages = 	 "99--117",
  year =	 2001,
  address =	 ECOOP2001addr,
  month =	 ECOOP2001date,
  abstract =
   "Precise type information is invaluable for analysis and optimization of
    object-oriented programs. Some forms of polymorphism found in
    object-oriented languages pose significant difficulty for type inference,
    in particular data polymorphism. Agesen's Cartesian Product Algorithm (CPA)
    can analyze programs with parametric polymorphism in a reasonably precise
    and efficient manner, but CPA loses precision for programs with data
    polymorphism. This paper presents a precise constraint-based type inference
    system for Java. It uses Data Polymorphic CPA, a constraint-based type
    inference algorithm which extends CPA with the ability to accurately and
    efficiently analyze data polymorphic programs. The system is implemented
    for the full Java language, and is used to statically verify the
    correctness of Java downcasts. Benchmark results are given which show the
    system performs very well: it is significantly more accurate and is nearly
    as efficient as CPA. The implementation itself contains a number of novel
    optimizations which proved necessary to achieve scalability."
}




@InProceedings{GagnonHM2000,
  author = 	 "Etienne Gagnon and Laurie J. Hendren and Guillaume Marceau",
  title = 	 "Efficient inference of static types for {Java} bytecode",
  booktitle =    "Static Analysis Symposium",
  pages = 	 "199--219",
  year = 	 2000,
  address = 	 SAS2000addr,
  month = 	 SAS2000date,
  abstract =
   "Even though Java bytecode has a significant amount of type information
    embedded in it, there are no explicit types for local variables. However,
    knowing types for local variables is very useful for both program
    optimization and decompilation. In this paper, we present an efficient and
    practical algorithm for inferring static types for local variables in a
    3-address, stackless, representation of Java bytecode.
    \par
    By decoupling the type inference problem from the low level bytecode
    representation, and abstracting it into a constraint system, we show that
    there exists verifiable bytecode that cannot be statically typed. Further,
    we show that, without transforming the program, the static typing problem
    is NP-hard. In order to develop a practical approach we have developed an
    algorithm that works efficiently for the usual cases and then applies
    efficient program transformations to simplify the hard cases.
    \par
    Our solution is an multi-stage algorithm. In the first stage, we propose an
    efficient algorithm that infers static types for most bytecode found in
    practice. In case this stage fails, the second stage is applied. It
    consists of a simple and efficient variable splitting operation that
    renders most bytecode typeable using the algorithm of stage one. Finally,
    for completeness of the algorithm, we present a final stage that
    efficiently transforms and infers types for all remaining bytecode (such
    bytecode is likely to be a contrived example, and not code produced from a
    compiler).
    \par
    We have implemented this algorithm in the Soot framework. Our experimental
    results show that all of the 17,000 methods used in our tests were
    successfully typed, 99.8% of those required only the first stage, 0.2%
    required the second stage, and no methods required the third stage."
}




@InProceedings{Agesen95,
  author = 	 "Ole Agesen",
  title = 	 "The cartesian product algorithm: Simple and precise type
                  inference of parametric polymorphism",
  booktitle =	 ECOOP95,
  pages =	 "2--26",
  year =	 1996,
  address =	 ECOOP95addr,
  month =	 ECOOP95date
}


@InProceedings{IgarashiPW01:Raw,
  author = 	 "Atsushi Igarashi and Benjamin C. Pierce and Philip Wadler",
  title = 	 "A Recipe for Raw Types",
  booktitle =	 FOOL2001,
  NEEDpages = 	 "",
  year =	 2001,
  address =	 FOOL2001addr,
  month =	 FOOL2001date,
  abstract =
   "The design of GJ (Bracha, Odersky, Stoutamire and Wadler), an extension of
    Java with parametric polymorphism, was significantly affected by the issue
    of compatibility between legacy Java code and new GJ code. In particular,
    the introduction of raw types made it easier to interface polymorphic code
    with monomorphic code. In GJ, for example, a polymorphic class List<X>,
    parameterized by the element type X, provides not only parameterized types
    such as List<Object> or List<String> but also the raw type List; then, a
    Java class using List can be compiled without adding element types to where
    List is used. Raw types, therefore, can reduce (or defer, at least)
    programmers' burden of modifying their old Java code to match with new
    polymorphic code.
    \par
    From the type-theoretic point of view, raw types are close to existential
    types in the sense that clients using a raw type C expect some
    implementation of a polymorphic class of the same name C. Unlike ordinary
    existential types, however, raw types allow several unsafe operations such
    as coercion from the raw type List, whose element type is abstract, to
    List<T> for any concrete type T. In this paper, basing on Featherweight GJ,
    proposed by the authors as a tiny core language of GJ, we formalize a type
    system and direct reduction semantics of raw types. The bottom type, which
    is subtype of any type, plays a key role in our type-preserving reduction
    semantics. In the course of the work, we have found a flaw in the typing
    rules from the GJ specification; type soundness is stated with respect to a
    repaired version of the type system.",
}


@InProceedings{FlattKF98,
  author = 	 "Matthew Flatt and Shriram Krishnamurthi and Matthias Felleisen",
  title = 	 "Classes and mixins",
  booktitle =	 POPL98,
  pages =	 "171--183",
  year =	 1998,
  address =	 POPL98addr,
  month =	 POPL98date
}

@article{MitchellP88,
 author = {John C. Mitchell and Gordon D. Plotkin},
 title = {Abstract types have existential type},
 journal = TOPLAS,
 volume = {10},
 number = {3},
 year = {1988},
 issn = {0164-0925},
 pages = {470--502},
 doi = {http://doi.acm.org/10.1145/44501.45065},
}

@InProceedings{CartwrightS98:NextGen,
  author = 	 "Robert Cartwright and Guy L. {Steele Jr}",
  title = 	 "Compatible genericity with run-time types for the {Java}
                  programming language",
  booktitle =	 OOPSLA98,
  pages =	 "201--215",
  year =	 1998,
  address =	 OOPSLA98addr,
  month =	 OOPSLA98date
}

@InProceedings{IgarashiV2002,
  author = 	 "Atsushi Igarashi and Mirko Viroli",
  title = 	 "On Variance-Based Subtyping for Parametric Types",
  booktitle =	 ECOOP2002,
  pages =	 "441--469",
  year =	 2002,
  address =	 ECOOP2002addr,
  month =	 ECOOP2002date
}

@article{1152650,
 author = {Atsushi Igarashi and Mirko Viroli},
 title = {Variant parametric types: A flexible subtyping scheme for generics},
 journal = TOPLAS,
 volume = {28},
 number = {5},
 year = {2006},
 issn = {0164-0925},
 pages = {795--847},
 doi = {http://doi.acm.org/10.1145/1152649.1152650},
 }


@InProceedings{MyersBL97,
  author = 	 "Andrew C. Myers and Joseph A. Bank and Barbara Liskov",
  title = 	 "Parameterized types for {Java}",
  booktitle =	 POPL97,
  pages =	 "132--145",
  year =	 1997,
  address =	 POPL97addr,
  month =	 POPL97date
}


@InProceedings{vonDincklageD2004,
  author =	 "Daniel von Dincklage and Amer Diwan",
  title =	 "Converting {Java} classes to use generics",
  booktitle =	 OOPSLA2004,
  pages = 	 "1--14",
  year =	 2004,
  address =	 OOPSLA2004addr,
  month =	 OOPSLA2004date,
  abstract =
   "Generics offer significant software engineering benefits since they provide
    code reuse without compromising type safety. Thus generics will be added to
    the Java language in the next release. While this extension to Java will
    help programmers when they are writing new code, it will not help legacy
    code unless it is rewritten to use generics. In our experience, manually
    modifying existing programs to use generics is complex and can be error
    prone and labor intensive. We describe a system, Ilwith, that (i) converts
    non-generic classes to generic classes and (ii) rewrites their clients to
    use the newly generified classes. Our experiments with a number of Java
    container classes show that our system is effective in modifying legacy
    code to use generics.",
}



@Article{cardelli85understanding,
  author = 	 "Luca Cardelli and Peter Wegner",
  title = 	 "On understanding types, data abstraction, and polymorphism",
  journal = 	 "ACM Computing Surveys",
  year = 	 1985,
  volume =	 17,
  number =	 4,
  pages =	 "471--522",
  month =	 dec
}


@Misc{java-treemap-buildFromSorted,
  author = 	 "Doug Lea",
  howpublished = "Personal communication",
  month = 	 aug # "~1,",
  year = 	 2004
}


@misc{sun-url-jsr14,
    howpublished = {\url{http://jcp.org/jsr/detail/14.html}},
    author = {{JavaSoft, Sun Microsystems}},
    title = "Prototype for {JSR014}: Adding Generics to the {Java} Programming Language v. 1.3",
    year = 2001,
    month = may # "~7,",
}

@misc{bracha98gjspec,
    author = "Gilad Bracha and Martin Odersky and David Stoutamire and Philip Wadler",
    title = "{GJ} Specification",
    howpublished = "\url{http://www.cis.unisa.edu.au/~pizza/gj/Documents/#gj-specification}",
    year = 1998,
    month = may,
}


@InProceedings{YuKS2004,
  author = 	 "Dachuan Yu and Andrew Kennedy and Don Syme",
  title = 	 "Formalization of generics for the {.NET} common language
                  runtime",
  booktitle =	 POPL2004,
  pages =	 "39--51",
  year =	 2004,
  address =	 POPL2004addr,
  month =	 POPL2004date
}


@InProceedings{PotaninNCB2006,
  author = 	 "Alex Potanin and James Noble and Dave Clarke and Robert Biddle",
  title = 	 "Generic ownership for generic {Java}",
  booktitle = OOPSLA2006,
  pages = 	 "311--324",
  year = 	 2006,
  address = 	 OOPSLA2006addr,
  month = 	 OOPSLA2006date,
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Type and effect systems
%%%


@TechReport{GiffordJLS87,
  author = 	 "David K. Gifford and Pierre Jouvelot and John M. Lucassen
                  and Mark Sheldon",
  title = 	 "FX-87 Reference Manual",
  institution =  MITLCS,
  year = 	 1987,
  number =	 "MIT/LCS/TR-407",
  address =	 MITaddr,
  month =	 sep
}

@InProceedings{LucassenG88,
  author = 	 "John M. Lucassen and David K. Gifford",
  title = 	 "Polymorphic effect systems",
  booktitle =	 POPL88,
  pages =	 "47--57",
  year =	 1988,
  address =	 POPL88addr,
  month =	 POPL88date
}


@InProceedings{JouvelotG91,
  author = 	 "Pierre Jouvelot and David K. Gifford",
  title = 	 "Algebraic reconstruction of types and effects",
  booktitle =	 POPL91,
  pages =	 "303--310",
  year =	 1991,
  address =	 POPL91addr,
  month =	 POPL91date
}

@InProceedings{TalpinJ92,
  author = 	 "Jean-Pierre Talpin and Pierre Jouvelot",
  title = 	 "The type and effect discipline",
  booktitle =	 LICS92,
  pages =	 "162--173",
  year =	 1992,
  address =	 LICS92addr,
  month =	 LICS92date
}

@InCollection{NiNi99tes,
  author =       "F. Nielson and H. R. Nielson",
  title =        "Type and Effect Systems",
  booktitle =    "Correct System Design",
  publisher =    "Springer-Verlag",
  year =         1999,
  OMITeditor =       "E. R. Olderog and B. Steffen",
  number =       1710,
  series =       LNCS,
  pages =        "114--136",
  abstract =
   "The design and implementation of a correct system can benefit 
    from employing static techniques for ensuring that the dynamic 
    behaviour satisfies the specification. Many programming languages 
    incorporate types for ensuring that certain operations are only
    applied to data of the appropriate form. A natural extension of 
    type checking techniques is to enrich the types with annotations 
    and effects that further describe intensional aspects of the dynamic 
    behaviour.",
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Inference
%%%

@InProceedings{OxhojPS92,
  author = 	 "Nicholas Oxh{\o}j and Jens Palsberg and Michael I. Schwartzbach",
  authorASCII =  "Nicholas Oxhoj",
  title = 	 "Making Type Inference Practical",
  booktitle =	 ECOOP92,
  pages =	 "329--349",
  year =	 1992,
  address =	 ECOOP92addr,
  month =	 ECOOP92date
}

@InProceedings{PlevyakC94,
  author = 	 "John Plevyak and Andrew A. Chien",
  title = 	 "Precise concrete type inference for object-oriented languages",
  booktitle =	 OOPSLA94,
  pages =	 "324--340",
  year =	 1994,
  address =	 OOPSLA94addr,
  month =	 OOPSLA94date,
  doi = {http://doi.acm.org/10.1145/191080.191130},
}

@InProceedings{PalsbergS91,
  author = 	 "Jens Palsberg and Michael I. Schwartzbach",
  title = 	 "Object-oriented type inference",
  booktitle =	 OOPSLA91,
  pages =	 "146--161",
  year =	 1991,
  address =	 OOPSLA91addr,
  month =	 OOPSLA91date
}

@InProceedings{OhoriB89,
  author = 	 "Atsushi Ohori and Peter Buneman",
  title = 	 "Static type inference for parametric classes",
  booktitle =	 OOPSLA89,
  pages =	 "445--456",
  year =	 1989,
  address =	 OOPSLA89addr,
  month =	 OOPSLA89date
}

@InProceedings{EifrigST95,
  author = 	 "Jonathan Eifrig and Scott Smith and Valery Trifonov",
  title = 	 "Sound polymorphic type inference for objects",
  booktitle =	 OOPSLA95,
  pages =	 "169--184",
  year =	 1995,
  address =	 OOPSLA95addr,
  month =	 OOPSLA95date
}


@InProceedings{SpoonS2004,
  author = 	 {S. Alexander Spoon and Olin Shivers},
  title = 	 {Demand-Driven Type Inference with Subgoal Pruning: Trading Precision for Scalability},
  booktitle = 	 ECOOP2004,
  pages =        "51--74",
  year =	 2004,
  address =	 ECOOP2004addr,
  month =	 ECOOP2004date
}

@InProceedings{FlanaganFKWF96,
  author = 	 {Cormac Flanagan and Matthew Flatt and Shriram Krishnamurthi and Stephanie Weirich and Matthias Felleisen},
  title = 	 {Catching Bugs in the Web of Program Invariants},
  booktitle = 	 PLDI96,
  pages =        "23--32",
  year =	 1996,
  address =	 PLDI96addr,
  month =	 PLDI96date
}


%   booktitle = 	 {Proceedings of the ECOOP '98 International Workshop: Experiences in Object-Oriented Reengineering},
@InProceedings{RapicaultBDD98,
  author = 	 {Pascal Rapicault and Mireille Blay-Fornarino and St{\'e}phane Ducasse and Anne-Marie Dery},
  authorASCII =  "Stephane Ducasse",
  title = 	 {Dynamic Type Inference to Support Object-Oriented Reengineering in {Smalltalk}},
  booktitle =    {ECOOP '98 Workshop on OO Reengineering},
  pages =        "76--77",
  year =	 1998,
  address =	 ECOOP98addr,
  month =	 ECOOP98date
}




@InProceedings{PolishchukLS2007,
  author = 	 "Marina Polishchuk and Ben Liblit and Chlo{\"e} Schulze",
  authorASCII =	 "Chloe Schulze",
  title = 	 "Dynamic heap type inference for program understanding and debugging",
  booktitle =    POPL2007,
  pages = 	 "39--46",
  year = 	 2007,
  address = 	 POPL2007addr,
  month = 	 POPL2007date,
  abstract =
   "C programs can be difficult to debug due to lax type enforcement
    and low-level access to memory. We present a dynamic analysis
    for C that checks heap snapshots for consistency with program
    types. Our approach builds on ideas from physical subtyping and
    conservative garbage collection. We infer a program-defined type
    for each allocated storage location or identify ``untypable'' blocks
    that reveal heap corruption or type safety violations. The analysis
    exploits symbolic debug information if present, but requires no
    annotation or recompilation beyond a list of defined program types
    and allocated heap blocks. We have integrated our analysis into the
    GNU Debugger (gdb), and describe our initial experience using this
    tool with several small to medium-sized programs.",
}




@InProceedings{LiuM2007,
  author = 	 "Y. Liu and A. Milanova",
  title = 	 "Ownership and Immutability Inference for {UML}-based Object Access Control",
  booktitle = ICSE2007,
  pages = 	 "323--332",
  year = 	 2007,
  address = 	 ICSE2007addr,
  month = 	 ICSE2007date,
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Ownership
%%%







@InProceedings{ClarkD2002,
  author = 	 "Dave Clarke and Sophia Drossopoulou",
  title = 	 "Ownership, encapsulation and the disjointness of type and
                  effect",
  booktitle =	 OOPSLA2002,
  pages =	 "292--310",
  year =	 2002,
  address =	 OOPSLA2002addr,
  month =	 OOPSLA2002date
}

@PhdThesis{Clark2001,
  author = 	 "David Clarke",
  title = 	 "Object Ownership and Containment",
  school = 	 "University of New South Wales",
  year = 	 2001,
  address =	 "Sydney, Australia"
}

@InProceedings{ClarkeW2003,
  author = 	 "David Clarke and Tobias Wrigstad",
  title = 	 "External uniqueness",
  booktitle =	 FOOL2003,
  NEEDpages = 	 "",
  year =	 2003,
  month =	 FOOL2003date,
  organization = FOOL2003addr
}

@InProceedings{ClarkeNP2001,
  author = 	 "David G. Clarke and James Noble and John M. Potter",
  title = 	 "Simple ownership types for object containment",
  booktitle =	 ECOOP2001,
  pages =	 "53--76",
  year =	 2001,
  address =	 ECOOP2001addr,
  month =	 ECOOP2001date
}

@InProceedings{ClarkePN98,
  author = 	 "David G. Clarke and John M. Potter and James Noble",
  title = 	 "Ownership types for flexible alias protection",
  booktitle =	 OOPSLA98,
  pages =	 "48--64",
  year =	 1998,
  address =	 OOPSLA98addr,
  month =	 OOPSLA98date
}

@InProceedings{YuP2006,
  author = 	 "Yi Lu and John Potter",
  title = 	 "Protecting representation with effect encapsulation",
  booktitle = POPL2006,
  pages = 	 "359--371",
  year = 	 2006,
  address = 	 POPL2006addr,
  month = 	 POPL2006date,
}


@InProceedings{Boyland2003,
  author = 	 "John Boyland",
  title = 	 "Checking interference with fractional permissions",
  booktitle =	 SAS2003,
  pages =	 "55--72",
  year =	 2003,
  address =	 SAS2003addr,
  month =	 SAS2003date
}

@InProceedings{BoyapatiLR2002,
  author = 	 "Chandrasekhar Boyapati and Robert Lee and Martin Rinard",
  title = 	 "Ownership types for safe programming:  Preventing data races and deadlocks",
  booktitle = OOPSLA2002,
  pages = 	 "211--230",
  year = 	 2002,
  address = 	 OOPSLA2002addr,
  month = 	 OOPSLA2002date,
}

@InProceedings{AndreaCGNVZ2006,
  author = 	 "Chris Andrea and Yvonne Coady and Celina Gibbs and James Noble and Jan Vitek and Tian Zhao",
  title = 	 "Scoped types and aspects for real-time systems",
  booktitle = ECOOP2006,
  pages = 	 "124--147",
  year = 	 2006,
  address = 	 ECOOP2006addr,
  month = 	 ECOOP2006date,
}


@InProceedings{BoyapatiSBR2003,
  author = 	 "Chandrasekhar Boyapati and Alexandru Salcianu and William {Beebee, Jr.} and Martin Rinard",
  title = 	 "Ownership types for safe region-based memory management in real-time Java",
  booktitle = PLDI2003,
  pages = 	 "324--337",
  year = 	 2003,
  address = 	 PLDI2003addr,
  month = 	 PLDI2003date,
}



@InProceedings{BanerjeeN2002,
  author = 	 "Anindya Banerjee and David A. Naumann",
  title = 	 "Representation independence, confinement, and access control",
  booktitle = POPL2002,
  pages = 	 "166--177",
  year = 	 2002,
  address = 	 POPL2002addr,
  month = 	 POPL2002date,
}



@TechReport{AbiAntounA2006:TR,
  author = 	 "Marwan Abi-Antoun and Jonathan Aldrich",
  title = 	 "{JavaD}: Bringing ownership domains to mainstream {Java}",
  institution =  CMUSCS,
  year = 	 2006,
  number = 	 "CMU-ISRI-06-110",
  address = 	 CMUaddr,
  month = 	 may,
  abstract =
   "Unlike many proposed designs for ownership type systems, AliasJava has had
    a publicly available implementation for a few years and has been applied on
    several case studies. However, AliasJava is currently implemented as a
    non-backwards compatible extension of Java. As a result, none of the tool
    support for Java programs is available for AliasJava programs, making it
    harder to justify the case that Java programs are easier to evolve with
    AliasJava annotations than without. Furthermore, using language extensions
    makes it harder to specify the ownership and aliasing annotations for a
    large legacy system since the program cannot be annotated partially and
    incrementally with AliasJava. We present and evaluate JavaD, a
    re-implementation of the AliasJava language and analysis as a set of Java
    1.5 annotations, using the Eclipse Java Development Tooling (JDT)
    infrastructure and the Crystal Data Flow Analysis framework. We conclude
    with limitations, lessons learned and future plans.",
}


@InProceedings{AbiAntounA2006:OOPSLA,
  author = 	 "Marwan Abi-Antoun and Jonathan Aldrich",
  title = 	 "Bringing ownership domains to mainstream {Java}",
  booktitle = OOPSLA2006companion,
  pages = 	 "702--703",
  year = 	 2006,
  address = 	 OOPSLA2006addr,
  month = 	 OOPSLA2006date,
  abstract =
   "AliasJava is a type annotation system that extends Java to express how data
    is confined within, passed among, or shared between objects in a software
    system. We present an implementation of the AliasJava system as Java 1.5
    annotations and an analysis using the Eclipse infrastructure.",
}




@InProceedings{AbiAntounA2007,
  author = 	 "Marwan Abi-Antoun and Jonathan Aldrich",
  title = 	 "Ownership domains in the real world",
  booktitle = IWACO2007,
  NEEDpages = 	 "*",
  year = 	 2007,
  address = 	 IWACO2007addr,
  month = 	 IWACO2007date,
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Information-flow type systems
%%%

@InProceedings{MyersL97,
  author = 	 {Andrew C. Myers and Barbara Liskov},
  title = 	 {A Decentralized Model for Information Flow Control},
  booktitle = 	 SOSP97,
  pages =	 "129--142",
  year =	 1997,
  address =	 SOSP97addr,
  month =	 SOSP97date
}

@InProceedings{Myers99,
  author = 	 {Andrew C. Myers},
  title = 	 {{JFlow}: Practical Mostly-Static Information Flow Control},
  pages =        "228--241",
  booktitle = 	 POPL99,
  year =	 1999,
  address =	 POPL99addr,
  month =	 POPL99date
}

@InProceedings{AskarovS2005,
  author = 	 {Aslan Askarov and Andrei Sabelfeld},
  title = 	 {Security-typed languages for implementation of cryptographic protocols: A case study},
  pages =        "197--221",
  booktitle = 	 ESORICS2005,
  year =	 2005,
  address =	 ESORICS2005addr,
  month =	 ESORICS2005date
}

@InProceedings{HicksAM2006,
  author = 	 {Boniface Hicks and Kiyan Ahmadizadeh and Patrick McDaniel},
  title = 	 {From Languages to Systems:  Understanding Practical Application Development in Security-typed Languages},
  pages =        "153--164",
  booktitle = 	 ACSAC2006,
  year =	 2006,
  address =	 ACSAC2006addr,
  month =	 ACSAC2006date
}

@Article{VolpanoSI96,
  author = 	 {Dennis Volpano and Geoffrey Smith and Cynthia Irvine},
  title = 	 {A Sound Type System for Secure Flow Analysis},
  journal = 	 {Journal of Computer Security},
  year = 	 1996,
  volume =	 4,
  number =	 3,
  pages =	 {167--187},
  month =	 dec
}

@InProceedings{PottierSimonet2002,
  author = 	 {Fran{\c{c}}ois Pottier and Vincent Simonet},
  authorASCII =	 {Francois Pottier},
  title = 	 {Information Flow Inference for {ML}},
  booktitle = 	 POPL2002,
  pages =	 "319--330",
  year =	 2002,
  address =	 POPL2002addr,
  month =	 POPL2002date
}

@InProceedings{Simonet2003,
  author = 	 {Vincent Simonet},
  title = 	 {{Flow Caml} in a Nutshell},
  booktitle = 	 APPSEMII2003,
  pages =	 "152--165",
  year =	 2003,
  address =	 APPSEMII2003addr,
  month =	 APPSEMII2003date
}

@InProceedings{LiZ2006,
  author = 	 {Peng Li and Steve Zdancewic},
  title = 	 {Encoding Information Flow in {Haskell}},
  pages =        "16--27",
  booktitle = 	 CSFW2006,
  year =	 2006,
  address =	 CSFW2006addr,
  month =	 CSFW2006date
}

@InProceedings{ChongM2008,
  author = 	 {Stephen Chong and Andrew C. Myers},
  title = 	 {End-to-End Enforcement of Erasure and Declassification},
  booktitle = 	 CSF2008,
  NEEDpages = 	 {},
  year =	 2008,
  address =	 CSF2008addr,
  month =	 CSF2008date
}

@InProceedings{MyersSZ2004,
  author = 	 {Andrew C. Myers and Andrei Sabelfeld and Steve Zdancewic},
  title = 	 {Enforcing Robust Declassificaiton},
  booktitle = 	 CSFW2004,
  pages =	 "172--186",
  year =	 2004,
  address =	 CSFW2004addr,
  month =	 CSFW2004date
}

@InProceedings{SabelfeldS2005,
  author = 	 {Andrei Sabelfeld and David Sands},
  title = 	 {Dimensions and Principles of Declassification},
  booktitle = 	 CSFW2005,
  pages =	 "255--269",
  year =	 2005,
  address =	 CSFW2005addr,
  month =	 CSFW2005date
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Typed assembly, types for low-level code, etc.
%%%

@Article{MorrisettWCG99,
  author =       "Greg Morrisett and David Walker and Karl Crary and
                 Neal Glew",
  title =        "From {System F} to typed assembly language",
  journal =      TOPLAS,
  year =         1999,
  volume =       21,
  number =       3,
  pages =        "527--568",
  month =        may,
  abstract =     "We motivate the design of typed assembly language
                 (TAL) and present a type-preserving translation from
                 System F to TAL. The typed assembly language we present
                 is based on a conventional RISC assembly language, but
                 its static type system provides support for enforcing
                 high-level language abstractions, such as closures,
                 tuples, and user-defined abstract data types. The type
                 system ensures that well-typed programs cannot violate
                 these abstractions. In addition, the typing constructs
                 admit many low-level compiler optimizations. Our
                 translation to TAL is specified as a sequence of
                 type-preserving transformations, including CPS and
                 closure conversion phases; type-correct source programs
                 are mapped to type-correct assembly language. A key
                 contribution is an approach to polymorphic closure
                 conversion that is considerably simpler than previous
                 work. The compiler and typed assembly language provide
                 a fully automatic way to produce certified code,
                 suitable for use in systems where untrusted and
                 potentially malicious code must be checked for safety
                 before execution.",
}

@InProceedings{MorrisettCGGSSWWZ99,
  author = 	 {Greg Morrisett and Karl Crary and Neal Glew and Dan Grossman and Richard Samuels and Frederick Smith and David Walker and Stephanie Weirich and Steve Zdancewic},
  title = 	 {{TALx86}: A realistic typed assembly language},
  pages =	 "25--35",
  year =	 1999,
  booktitle = 	 WCSSS99,
  address =	 WCSSS99addr,
  month =	 WCSSS99date
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Annotations
%%%



@Article{CazzolaCC2005:JOT,
  author = 	 "Walter Cazzola and Antonio Cisternino and Diego Colombo",
  title = 	 "Freely Annotating {C}\#",
  journal = 	 JOT,
  year = 	 2005,
  volume = 	 4,
  number = 	 10,
  pages = 	 "31--48",
  month = 	 dec,
  note = 	 "Special Issue: OOPS Track at SAC 2005",
  abstract =
   "Reflective programming is becoming popular due to the increasing set of
    dynamic services provided by execution environments like JVM and CLR. With
    custom attributes Microsoft introduced an extensible model of reflection
    for CLR: they can be used as additional decorations on element
    declarations. The same notion has been introduced in Java 1.5. The
    annotation model, both in Java and in C\#, limits annotations to classes and
    class members. In this paper we describe [a]C\#, an extension of the C\#
    programming language, that allows programmers to annotate statements and
    code blocks and retrieve these annotations at run-time. We show how this
    extension can be reduced to the existing model. A set of operations on
    annotated code blocks to retrieve annotations and manipulate bytecode is
    introduced. We also discuss how to use [a]C\# to annotate programs giving
    hints on how to parallelize a sequential method and how it can be
    implemented by means of the abstractions provided by the run-time of the
    language. Finally, we show how our model for custom attributes has been
    realized.",
}

@InProceedings{CazzolaCC2005:SAC,
  author = 	 "Walter Cazzola and Antonio Cisternino and Diego Colombo",
  title = 	 "[a]C\#: C\# with a customizable code annotation mechanism",
  booktitle = SAC2005,
  pages = 	 "1264--1268",
  year = 	 2005,
  address = 	 SAC2005addr,
  month = 	 SAC2005date,
  supersededby = "CazzolaCC2005:JOT",
  abstract =
   "Reflective programming is becoming popular due to the increasing
    set of dynamic services provided by execution environments like
    JVM and CLR\@.  With custom attributes Microsoft introduced an extensible
    model of reflection for CLR: they can be used as additional
    decorations on element declarations. The same notion has been
    introduced in Java 1.5. The extensible model proposed in both
    platforms limits annotations to class members. In this paper we
    describe [a]C\#, an extension of the C\# programming language,
    that allows programmers to annotate statements or code blocks and
    retrieve these annotations at run-time. We show how this extension
    can be reduced to the existing model. A set of operations on annotated
    code blocks to retrieve annotations and manipulate bytecode
    is introduced. Finally, we discuss how to use [a]C\# to annotate
    programs giving hints on how to parallel a sequential method and
    how it can be implemented by means of the abstractions provided
    by the run-time of the language.",
}


@InProceedings{HarmonK2007,
  author = 	 "Trevor Harmon and Raymond Klefstad",
  title = 	 "Toward a Unified Standard for Worst-Case Execution Time Annotations in Real-Time {Java}",
  booktitle = "WPDRTS 2007, Fifteenth International Workshop on Parallel and Distributed Real-Time Systems",
  NEEDpages = 	 "*",
  year = 	 2007,
  address = 	 "Long Beach, CA, USA",
  month = 	 mar,
}


@PhdThesis{Pechtchanski2003,
  author = 	 "Igor Pechtchanski",
  title = 	 "A Framework for Optimistic Program Optimization",
  school = 	 "New York University",
  year = 	 2003,
  month = 	 sep,
  abstract =
   "The problem of program optimization is a non-trivial one. Compilers do a
    fair job, but can't always deliver the best performance. The expressibility
    of general-purpose languages is limited, not allowing programmers to
    describe expected run-time behavior, for example, and some programs are
    thus more amenable to optimization than others, depending on what the
    compiler expects to see.
    \par
    We present a generic framework that allows addressing this problem in two
    ways: through specifying verifiable source annotations to guide compiler
    analyses, and through optimistically using some assumptions and analysis
    results for the subset of the program seen so far. Two novel applications
    are presented, one for each of the above approaches: a dynamic optimistic
    interprocedural type analysis algorithm, and a mechanism for specifying
    immutability assertions. Both applications result in measurable speedups,
    demonstrating the feasibility of each approach.",
}




@InProceedings{KirnerP2005,
  author = 	 "Raimund Kirner and Peter Puschner",
  title = 	 "Classification of code annotations and discussion of compiler-support for worst-case execution time analysis",
  booktitle = WCET2005,
  NEEDpages = 	 "*",
  year = 	 2005,
  address = 	 WCET2005addr,
  month = 	 WCET2005date,
}




@InProceedings{EichbergM2004,
  author = 	 "Michael Eichberg and Mira Mezini",
  title = 	 "Alice:  Modularization of middleware using aspect-oriented programming",
  booktitle = "4th International Workshop on Software Engineering and Middleware (SEM04)",
  pages = 	 "47--63",
  year = 	 2004,
  address = 	 "Linz, Austria",
  month = 	 dec,
}

@Article{Eichberg2005,
  author = 	 "Michael Eichberg",
  title = 	 "Component-based software development with aspect-oriented programming",
  journal = 	 JOT,
  year = 	 2005,
  volume = 	 4,
  number = 	 3,
  pages = 	 "21--26",
  month = 	 apr,
}




@InProceedings{BurdyHP2007,
  author = 	 "Lilian Burdy and Marieke Huisman and Mariela Pavlova",
  title = 	 "Preliminary design of {BML}:  A behavioral interface specification language for {Java} bytecode",
  booktitle = FASE2007,
  pages = 	 "215--229",
  year = 	 2007,
  address = 	 FASE2007addr,
  month = 	 FASE2007date,
  abstract =
   "We present the Bytecode Modeling Language (BML), the Java bytecode cousin
    of JML\@.  BML allows the application developer to specify the behaviour of
    an application in the form of annotations, directly at the level of the
    bytecode. An extension of the class file format is defined to store the
    specification directly with the bytecode. This is a first step towards the
    development of a platform for Proof Carrying Code, where applications come
    together with their specification and a proof of correctness. BML is
    designed to be closely related with JML\@. In particular, JML specifications
    can be compiled into BML specifications. We briefly discuss the tools that
    are currently being developed for BML, and that will result in a tool set
    where an application can be validated throughout its development, both at
    source code and at bytecode level.",
}



@Article{HartmannAvRF2003,
  author = 	 "Andreas Hartmann and Wolfram Amme and Jeffery von Ronne and Michael Franz",
  title = 	 "Code Annotation for Safe and Efficient Dynamic Object Resolution",
  journal = 	 ENTCS,
  year = 	 2003,
  volume = 	 82,
  number = 	 2,
  NOpages = 	 "*",
}




@InProceedings{GrantMPCE97,
  author = 	 "Brian Grant and Markus Mock and Matthai Philipose and Craig Chambers and Susan J. Eggers",
  title = 	 "Annotation-Directed Run-Time Specialization in {C}",
  booktitle = PEPM97,
  pages = 	 "163--178",
  year = 	 1997,
  address = 	 PEPM97addr,
  month = 	 PEPM97date,
}



@InCollection{Henglein91,
  author =       "Fritz Henglein",
  title =        "Efficient Type Inference for Higher-Order Binding-Time
                 Analysis",
  booktitle =    "Functional Programming Languages and Computer Architecture",
  address =      "Cambridge, MA",
  pages =        "448--472",
  publisher =    "Springer Verlag",
  year =         1991,
  month =        aug,
  note =         LNCS # " 523.",
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% JACK (Java Applet Correctness Kit)
%%%



@INPROCEEDINGS{BRL-JACK,
   Author =   {L. Burdy and A. Requet and J.-L. Lanet},
   Title =    {Java Applet Correctness: A Developer-Oriented Approach},
   Booktitle = {FME 2003: Formal Methods: International Symposium of Formal Methods Europe},
   Editor =   {K. Araki and S. Gnesi and D. Mandrioli},
   Volume =   {2805},
   Series =   {Lecture Notes in Computer Science},
   Pages =    {422--439},
   Publisher = {Springer-Verlag},
   Year =     {2003},
   PSurl =    {ftp://ftp-sop.inria.fr/everest/publis/2003/BRL03fme.ps.gz}
}

@INPROCEEDINGS{gpt04:csfw,
  AUTHOR =   {G. Barthe and P. D'Argenio and T. Rezk},
  TITLE =    {{Secure Information Flow by Self-Composition}},
  BOOKTITLE = {CSFW2004},
  year =     2004,
  PAGES =    {100-114},
  TOPICS =   {team}
}


@INPROCEEDINGS{m+04:cardis,
  AUTHOR =   {M. Pavlova and G. Barthe and L. Burdy and M. Huisman and J.-L. Lanet},
  TITLE =    {Enforcing High-Level Security Properties For Applets},
  BOOKTITLE = {CARDIS2004},
  year =     2004,
  PAGES =    {},
  TOPICS =   {team}
}



@unpublished{gmg05:sefm,
  author =   {G. Barthe and M. Pavlova and G. Schneider},
  title =    {{Precise analysis of memory consumption using program logics}},
  year =     {2005},
  note=      {Manuscript}
}



@unpublished{BP05:acc,
  title=     {Java Bytecode Specification and Verification},
  author=    {L. Burdy and M. Pavlova},
  note=      {Manuscript},
  year=      {2005}
} 

@InProceedings{Charles06,
  author =    {Julien Charles},
  title =     {Adding Native Specifications to {JML}},
  booktitle = {ECOOP workshop on Formal Techniques for Java-like Programs (FTfJP2006)},
  year =     2006, 
} 

@INPROCEEDINGS{BBCGHLPR07:FMCO,
  author = {G. Barthe and L. Burdy and J. Charles and B. Gr{\'e}goire and M. Huisman and J.-L. Lanet and M. Pavlova and A. Requet},
  title = {{JACK}:  a tool for validation of security and behaviour of {Java} applications},
  booktitle = {FMCO: Proceedings of 5th International Symposium on Formal Methods for Components and Objects},
  publisher = {Springer-Verlag},
  series = {Lecture Notes in Computer Science},
  year = {2007},
  pdfurl = {ftp://ftp-sop.inria.fr/everest/Marieke.Huisman/fmco06.pdf},
  topics = {team}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Typestate
%%%


@InProceedings{KondohO2008,
  author = 	 "Goh Kondoh and Tamiya Onodera",
  title = 	 "Finding bugs in {Java} {Native} {Interface} programs",
  booktitle = ISSTA2008,
  pages = 	 "109--118",
  year = 	 2008,
  address = 	 ISSTA2008addr,
  month = 	 ISSTA2008date,
  abstract =
   "In this paper, we describe static analysis techniques for finding bugs in
    programs using the Java Native Interface (JNI). The JNI is both tedious and
    error-prone because there are many JNI-specific mistakes that are not
    caught by a native compiler. This paper is focused on four kinds of common
    mistakes. First, explicit statements to handle a possible exception need to
    be inserted after a statement calling a Java method. However, such
    statements tend to be forgotten. We present a typestate analysis to detect
    this exception-handling mistake. Second, while the native code can allocate
    resources in a Java VM, those resources must be manually released, unlike
    Java. Mistakes in resource management cause leaks and other errors. To
    detect Java resource errors, we used the typestate analysis also used for
    detecting general memory errors. Third, if a reference to a Java resource
    lives across multiple native method invocations, it should be converted
    into a global reference. However, programmers sometimes forget this rule
    and, for example, store a local reference in a global variable for later
    uses. We provide a syntax checker that detects this bad coding
    practice. Fourth, no JNI function should be called in a critical region. If
    called there, the current thread might block and cause a
    deadlock. Misinterpreting the end of the critical region, programmers
    occasionally break this rule. We present a simple typestate analysis to
    detect an improper JNI function call in a critical region.
    \par
    We have implemented our analysis techniques in a bug-finding tool called
    BEAM, and executed it on opensource software including JNI code. In the
    experiment, our analysis techniques found 86 JNI-specific bugs without any
    overhead and increased the total number of bug reports by 76\%.",
}









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Combining static and dynamic typing
%%%


@InProceedings{MeijerD2005,
  author = 	 "Erik Meijer and Peter Drayton",
  title = 	 "Static typing where possible, dynamic typing when needed:  The end of the cold war between programming languages",
  booktitle = RDL2004,
  NEEDpages = 	 "*",
  year = 	 2004,
  address = 	 OOPSLA2004addr,
  month = 	 RDL2004date,
  abstract =
   "This paper argues that we should seek the golden middle way
    between dynamically and statically typed languages.",
}



@InProceedings{BrachaG1993,
  author = 	 "Gilad Bracha and David Griswold",
  title = 	 "Strongtalk: Typechecking {Smalltalk} in a production environment",
  booktitle = OOPSLA93,
  pages = 	 "215--230",
  year = 	 1993,
  address = 	 OOPSLA93addr,
  month = 	 OOPSLA93date,
}



@Proceedings{STOP2009,
  key =          "STOP2009",
  title = 	 STOP2009,
  year = 	 2009,
  address = 	 STOP2009addr,
  month = 	 STOP2009date,
}


%%%
%%% Soft typing and type inference approach
%%%




@InProceedings{CartwrightF91,
  author =       "Robert Cartwright and Mike Fagan",
  title =        "Soft Typing",
  pages =        "278--292",
  ISBN =         "0-89791-428-7",
  booktitle =    PLDI91,
  address =      PLDI91addr,
  month =        PLDI91date,
  year =         1991,
}


@InProceedings{WrightAndr1994a,
  author =       "Andrew K. Wright and Robert Cartwright",
  booktitle =    "Conference on Lisp and Functional programming",
  title =        "{A} Practical Soft Type System for Scheme",
  year =         "1994",
  url =          "ftp://cs.rice.edu/public/languages/tr93-218.dvi.Z",
  scope =        "imptype",
}


@Article{Wright:1997:PST,
  author =       "Andrew K. Wright and Robert Cartwright",
  title =        "A Practical Soft Type System for {Scheme}",
  journal =      "ACM Transactions on Programming Languages and
                 Systems",
  volume =       19,
  number =       1,
  pages =        "87--152",
  month =        jan,
  year =         1997,
  coden =        "ATPSDT",
  ISSN =         "0164-0925",
  url =          "http://www.acm.org/pubs/citations/journals/toplas/1997-19-1/p87-wright/",
  abstract =     "A {\em soft type system\/} infers types for the
                 procedures and data structures of dynamically typed
                 programs. Like conventional static types, soft types
                 express program invariants and thereby provide valuable
                 information for program optimization and debugging. A
                 soft type {\em checker\/} uses the types inferred by a
                 soft type system to eliminate run-time checks that are
                 provably unnecessary; any remaining run-time checks are
                 flagged as potential program errors. {\em Soft
                 Scheme\/} is a practical soft type checker for R4RS
                 Scheme. Its underlying type system generalizes
                 conventional Hindley-Milner type inference by
                 incorporating recursive types and a limited form of
                 union type. Soft Scheme accommodates all of R4RS Scheme
                 including uncurried procedures of fixed and variable
                 arity, assignment, and continuations.",
  keywords =     "performance; reliability",
  subject =      "{\bf F.3.3}: Theory of Computation, LOGICS AND
                 MEANINGS OF PROGRAMS, Studies of Program Constructs,
                 Type structure. {\bf D.3.2}: Software, PROGRAMMING
                 LANGUAGES, Language Classifications, Applicative
                 languages. {\bf D.3.4}: Software, PROGRAMMING
                 LANGUAGES, Processors, Optimization.",
}


@InProceedings{AnconaLZ2007,
  author = 	 "Davide Ancona and Giovanni Lagorio and Elena Zucca",
  title = 	 "Type inference for polymorphic methods in {Java}-like languages",
  booktitle = "Theoretical Computer Science: Proceedings of the 10th Italian Conference on ICTCS '07",
  NEEDpages = 	 "*",
  year = 	 2007,
  NEEDaddress = 	 "*",
  NEEDmonth = 	 "*",
  abstract =
   "In languages like C++, Java and C#, typechecking algorithms require methods
    to be annotated with their parameter and result types, which are either fixed
    or constrained by a bound.
    \par
    We show that, surprisingly enough, it is possible to infer the polymorphic
    type of a method where parameter and result types are left unspecified, as
    happens in most functional languages. These types intuitively capture the (less
    restrictive) requirements on arguments needed to safely apply the method.
    We formalize our ideas on a minimal Java subset, for which we define a
    type system with polymorphic types and prove its soundness. We then describe
    an algorithm for type inference and prove its soundness and completeness. A
    prototype implementing inference of polymorphic types is available.",
}





@TechReport{CamphuijsenHH2009,
  author = 	 "Camphuijsen, Patrick and Hage, Jurriaan and Holdermans, Stefan",
  title = 	 "Soft typing {PHP}",
  institution =  "Department of Information and Computing Sciences, Utrecht University",
  year = 	 2009,
  number = 	 "UU-CS-2009-004",
  OMITaddress = 	 "Utrecht",
  urlpdf = {{http://www.cs.uu.nl/research/techreps/repo/CS-2009/2009-004.pdf}},
}



@Article{LagorioZ2007,
  author = 	 "Giovanni Lagorio and Elena Zucca",
  title = 	 "Just: Safe unknown types in {Java}-like languages",
  journal = 	 JOT,
  year = 	 2007,
  volume = 	 6,
  number = 	 2,
  pages = 	 "71--100",
  abstract =
   "Most mainstream object-oriented languages, like C++, Java and C#, are
    statically typed. In recent years, untyped languages, in particular
    scripting languages for the web, have gained a lot of popularity
    notwithstanding the fact that the advantages of static typing, such as
    earlier detection of errors, are widely accepted. We think that one of the
    main reasons for their widespread adoption is that, in many situations, the
    ability of ignoring types can be handy to write simpler and more readable
    code.
    \par
    We propose an extension of Java-like languages which allows developers to
    forget about typing in strategic places of their programs without losing
    type-safety. That is, we allow programmers to write simpler code without
    sacrificing the advantages of static typing. This is achieved by means of
    inferred type constraints. These constraints describe the implicit
    requirements on untyped code to be correctly invoked. 
    \par
    This flexibility comes at a cost: field accesses and method invocations on
    objects of unknown types are less efficient than regular field accesses and
    method invocations. Also, our type system is currently more restrictive
    than it should be; its extension is the subject of ongoing work.
    \par
    We have implemented our approach on a small, yet significant, Java subset.",
}


@InProceedings{Nystrom2003,
  author = 	 "Nystr{\"o}m, Sven-Olof",
  authorASCII =	 "Nystrom, Sven-Olof",
  title = 	 "A soft-typing system for {Erlang}",
  booktitle = "ERLANG '03: Proceedings of the 2003 ACM SIGPLAN workshop on Erlang",
  pages = 	 "56--71",
  year = 	 2003,
  address = 	 "Uppsala, Sweden",
  month = 	 aug # "~29,",
  abstract =
   "This paper presents a soft-typing system for the programming language
    Erlang. The system is based on two concepts; a (forward) data flow analysis
    that determines upper approximations of the possible values of expressions
    and other constructs, and a specification language that allows the
    programmer to specify the interface of a module. We examine the programming
    language Erlang and point to various aspects of the language that make it
    hard to type. We present experimental result of applying the soft-typing
    system to some previously written programs.",
}



@InProceedings{Aycock2000,
  author = 	 "John Aycock",
  title = 	 "Aggressive type inference",
  OPTcrossref =  "",
  OPTkey = 	 "",
  booktitle =    "International Python Conference",
  OPTpages = 	 "",
  year = 	 "2000",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  OPTaddress = 	 "",
  OPTmonth = 	 "",
}


@InProceedings{HolknerH2009,
  author = 	 "Alex Holkner and James Harland",
  title = 	 "Evaluating the dynamic behavior of Python applications",
  OPTcrossref =  "",
  OPTkey = 	 "",
  booktitle =    "Australasian Computer Science Conference (ACSC)",
  OPTpages = 	 "",
  year = 	 "2009",
  OPTeditor = 	 "",
  OPTvolume = 	 "",
  OPTnumber = 	 "",
  OPTseries = 	 "",
  OPTaddress = 	 "",
  OPTmonth = 	 "",
}


@MastersThesis{Salib2004,
  author = 	 "Michael Salib",
  title = 	 "Starkiller: A static type inferencer and compiler for Python",
  school = 	 MITEECS,
  year = 	 2004,
  address = 	 MITAddr,
  month = 	 may,
  abstract =
   "Starkiller is a type inferencer and compiler for the dynamic language
    Python designed to generate fast native code. It analyzes Python source
    programs and converts them into equivalent C++ programs. Starkiller's type
    inference algorithm is based on the Cartesian Product Algorithm but has
    been significantly modified to support a radically different language. It
    includes an External Type Description Language that enables extension
    authors to document how their foreign code extensions interact with
    Python. This enables Starkiller to analyze Python code that interacts with
    foreign code written in C, C++, or Fortran. The type inference algorithm
    also handles data polymorphism in addition to parametric polymorphism, thus
    improving precision.  Starkiller supports the entire Python language except
    for dynamic code insertion features such as eval and dynamic module
    loading. While the system is not yet complete, early numeric benchmarks
    show that Starkiller compiled code performs almost as well as hand made C
    code and substantially better than alternative Python compilers.",
}


@InProceedings{AnconaACM2007,
  author = 	 "Davide Ancona and Massimo Ancona and Antonio Cuni and Nicholas D. Matsakis",
  title = 	 "RPython: a Step Towards Reconciling Dynamically and Statically Typed OO Languages",
  booktitle = DLS2007,
  pages = 	 "53-64",
  year = 	 2007,
  address = 	 OOPSLA2007addr,
  month = 	 DLS2007date,
  abstract =
   "Although the C-based interpreter of Python is reasonably fast,
    implementations on the CLI or the JVM platforms offers some advantages
    in terms of robustness and interoperability. Unfortunately, because the
    CLI and JVM are primarily designed to execute statically typed,
    object-oriented languages, most dynamic language implementations cannot
    use the native bytecodes for common operations like method calls and
    exception handling; as a result, they are not able to take full
    advantage of the power offered by the CLI and JVM. We describe a
    different approach that attempts to preserve the flexibility of Python,
    while still allowing for efficient execution. This is achieved by
    limiting the use of the more dynamic features of Python to an initial,
    bootstrapping phase. This phase is used to construct a final RPython
    (Restricted Python) program that is actually executed. RPython is a
    proper subset of Python, is statically typed, and does not allow dynamic
    modification of class or method definitions; however, it can still take
    advantage of Python features such as mixins and first-class methods and
    classes. This paper presents an overview of RPython, including its
    design and its translation to both CLI and JVM bytecode. We show how the
    bootstrapping phase can be used to implement advanced features, like
    extensible classes and generative programming. We also discuss what work
    remains before RPython is truly ready for general use, and compare the
    performance of RPython with that of other approaches.",
}




@InProceedings{FurrAFH2009,
  author = 	 "Furr, Michael and An, Jong-hoon (David) and Foster, Jeffrey S. and Hicks, Michael",
  title = 	 "Static type inference for Ruby",
  booktitle = SAC2009,
  pages = 	 "1859--1866",
  year = 	 2009,
  address = 	 SAC2009addr,
  month = 	 SAC2009date,
  abstract =
   "Many general-purpose, object-oriented scripting languages are dynamically
    typed, which provides flexibility but leaves the programmer without the
    benefits of static typing, including early error detection and the
    documentation provided by type annotations. This paper describes
    Diamondback Ruby (DRuby), a tool that blends Ruby's dynamic type system
    with a static typing discipline. DRuby provides a type language that is
    rich enough to precisely type Ruby code we have encountered, without
    unneeded complexity. When possible, DRuby infers static types to discover
    type errors in Ruby programs. When necessary, the programmer can provide
    DRuby with annotations that assign static types to dynamic code. These
    annotations are checked at run time, isolating type errors to unverified
    code. We applied DRuby to a suite of benchmarks and found several bugs that
    would cause run-time type errors. DRuby also reported a number of warnings
    that reveal questionable programming practices in the benchmarks. We
    believe that DRuby takes a major step toward bringing the benefits of
    combined static and dynamic typing to Ruby and other object-oriented
    languages.",
}


@InProceedings{FurrAF2009,
  author = 	 "Furr, Michael and An, Jong-hoon (David) and Foster, Jeffrey S.",
  title = 	 "Profile-guided static typing for dynamic scripting languages",
  booktitle = OOPSLA2009,
  pages = 	 "283--300",
  year = 	 2009,
  address = 	 OOPSLA2009addr,
  month = 	 OOPSLA2009date,
  abstract =
   "Many popular scripting languages such as Ruby, Python, and Perl
    include highly dynamic language constructs, such as an eval method that
    evaluates a string as program text. While these constructs allow terse
    and expressive code, they have traditionally obstructed static
    analysis. In this paper we present PRuby, an extension to Diamondback
    Ruby (DRuby), a static type inference system for Ruby. PRuby augments
    DRuby with a novel dynamic analysis and transformation that allows us
    to precisely type uses of highly dynamic constructs. PRuby's analysis
    proceeds in three steps. First, we use run-time instrumentation to
    gather per-application profiles of dynamic feature usage. Next, we
    replace dynamic features with statically analyzable alternatives based
    on the profile. We also add instrumentation to safely handle cases when
    subsequent runs do not match the profile. Finally, we run DRuby's
    static type inference on the transformed code to enforce type safety.
    \par
    We used PRuby to gather profiles for a benchmark suite of sample Ruby
    programs. We found that dynamic features are pervasive throughout the
    benchmarks and the libraries they include, but that most uses of these
    features are highly constrained and hence can be effectively
    profiled. Using the profiles to guide type inference, we found that
    DRuby can generally statically type our benchmarks modulo some
    refactoring, and we discovered several previously unknown type
    errors. These results suggest that profiling and transformation is a
    lightweight but highly effective approach to bring static typing to
    highly dynamic languages.",
}



@InProceedings{AndersonGD2005,
  author = 	 "Christopher Anderson and Paola Giannini and Sophia Drossopoulou1",
  title = 	 "Towards type inference for {JavaScript}",
  booktitle = ECOOP2005,
  pages = 	 "428--452",
  year = 	 2005,
  address = 	 ECOOP2005addr,
  month = 	 ECOOP2005date,
  abstract =
   "Object-oriented scripting languages like Javascript and Python are
   popular partly because of their dynamic features. These include the
   runtime modification of objects and classes through addition of fields
   or updating of methods. These features make static typing difficult and
   so usually dynamic typing is used. Consequently, errors such as access
   to non-existent members are not detected until runtime.
   \par
   We first develop a formalism for an object based language, JS$_0$ with
   features from Javascript, including dynamic addition of fields and
   updating of methods. We give an operational semantics and static type
   system for JS$_0$ using structural types. Our types allow objects to evolve
   in a controlled manner by classifying members as definite or potential.
   \par
   We define a type inference algorithm for JS$_0$ that is sound with respect
   to the type system. If the type inference algorithm succeeds, then the
   program is typeable. Therefore, programmers can benefit from the safety
   offered by the type system, without the need to write explicitly types
   in their programs.",
}



@InProceedings{OlmosV2003,
  author = 	 "Karina Olmos and Eelco Visser",
  title = 	 "Turning dynamic typing into static typing by program specialization in a compiler front-end for {Octave}",
  booktitle = SCAM2003,
  NEEDpages = 	 "*",
  year = 	 2003,
  address = 	 SCAM2003addr,
  month = 	 SCAM2003date,
  abstract =
   "Array processing languages such as APL, Matlab and Octave rely on dynamic
    typechecking by the interpreter rather than static typechecking and are
    designed for user convenience with a syntax close to mathematical
    notation. Functions and operators are highly overloaded. The price to be
    paid for this flexibility is computational performance, since the run-time
    system is responsible for type checking, array shape determination,
    function call dispatching, and handling possible run-time errors. In order
    to produce effecient code, an Octave compiler should address those issues
    at compile-time as much as possible. In particular, static type and shape
    inferencing can improve the quality of the generated code. In this paper we
    discuss how overloading in dynamically typed Octave programs can be
    resolved by program specialization. We discuss the typing issues in
    compilation of Octave programs and give an overview of the implementation
    of the specializer in the transformation language Stratego.",
}



%%%
%%% Adding a "Dynamic" type to a statically typed language
%%%

@InProceedings{AbadiCPP89,
  author = 	 "Mart{\'\i}n Abadi and Luca Cardelli and Benjamin Pierce and Gordon Plotkin",
  authorASCII =	 "Martin Abadi and Luca Cardelli and Benjamin Pierce and Gordon Plotkin",
  title = 	 "Dynamic typing in a statically-typed language",
  booktitle = POPL89,
  pages = 	 "213-227",
  year = 	 1989,
  address = 	 POPL89addr,
  month = 	 POPL89date,
  abstract =
   "Statically-typed programming languages allow earlier error checking,
    better enforcement of disciplined programming styles, and generation of
    more efficient object code than languages where all type-consistency
    checks are performed at runtime. However, even in statically-type
    languages, there is often the need to deal with data whose type cannot be
    known at compile time. To handle such situations safely, we propose to add
    a type Dynamic whose values are pairs of a value v and a type tag T where
    v has the type denoted by T. Instances of Dynamic are built with an
    explicit tagging construct and inspected with a type-safe typecase
    construct.
    \par
    This paper is an exploration of the syntax, operational semantics, and
    denotational semantics of a simple language with the type Dynamic. We give
    examples of how dynamically-typed values might be used in programming. Then
    we discuss an operational semantics for our language and obtain a soundness
    theorem. We present two formulations of the denotational semantics of this
    language and relate them to the operational semantics. Finally, we consider
    the implications of polymorphism and some implementation issues.",
}


@Article{AbadiCPP91,
  author = 	 "Mart{\'\i}n Abadi and Luca Cardelli and Benjamin Pierce and Gordon Plotkin",
  authorASCII =	 "Mart{\'\i}n Abadi and Luca Cardelli and Benjamin Pierce and Gordon Plotkin",
  title = 	 "Dynamic typing in a statically typed language",
  journal = 	 TOPLAS,
  year = 	 1991,
  volume = 	 13,
  number = 	 2,
  pages = 	 "237--268",
  month = 	 apr,
  abstract =
   "Statically typed programming languages allow earlier error checking,
    better enforcement of diciplined programming styles, and the generation of
    more efficient object code than languages where all type consistency
    checks are performed at run time. However, even in statically typed
    languages, there is often the need to deal with data whose type cannot be
    determined at compile time. To handle such situations safely, we propose
    to add a type Dynamic whose values are pairs of a value v and a type tag T
    where v has the type denoted by T. Instances of Dynamic are built with an
    explicit tagging construct and inspected with a type safe typecase
    construct.
    \par
    This paper explores the syntax, operational semantics, and denotational
    semantics of a simple language that includes the type Dynamic. We give
    examples of how dynamically typed values can be used in programming. Then
    we discuss an operational semantics for our language and obtain a soundness
    theorem. We present two formulations of the denotational semantics of this
    language and relate them to the operational semantics. Finally, we consider
    the implications of polymorphism and some implementation issues.",
}


@InProceedings{BloomFNORSVW2009,
  author = 	 "Bloom, Bard and Field, John and Nystrom, Nathaniel and {\"O}stlund, Johan and Richards, Gregor and Strni\v{s}a, Rok and Vitek, Jan and Wrigstad, Tobias",
  authorASCII = 	 "Bloom, Bard and Field, John and Nystrom, Nathaniel and Ostlund, Johan and Richards, Gregor and Strnisa, Rok and Vitek, Jan and Wrigstad, Tobias",
  title = 	 "Thorn: Robust, concurrent, extensible scripting on the {JVM}",
  booktitle = OOPSLA2009,
  pages = 	 "117--136",
  year = 	 2009,
  address = 	 OOPSLA2009addr,
  month = 	 OOPSLA2009date,
  abstract =
   "Scripting languages enjoy great popularity due to their support for
    rapid and exploratory development. They typically have lightweight
    syntax, weak data privacy, dynamic typing, powerful aggregate data
    types, and allow execution of the completed parts of incomplete
    programs. The price of these features comes later in the software life
    cycle. Scripts are hard to evolve and compose, and often slow. An
    additional weakness of most scripting languages is lack of support for
    concurrency - though concurrency is required for scalability and
    interacting with remote services. This paper reports on the design and
    implementation of Thorn, a novel programming language targeting the
    JVM. Our principal contributions are a careful selection of features
    that support the evolution of scripts into industrial grade programs -
    e.g., an expressive module system, an optional type annotation facility
    for declarations, and support for concurrency based on message passing
    between lightweight, isolated processes. On the implementation side,
    Thorn has been designed to accommodate the evolution of the language
    itself through a compiler plugin mechanism and target the Java virtual
    machine.",
}

@InProceedings{WrigstadZNLOV2010,
  author = 	 "Tobias Wrigstad and Francesco {Zappa Nardelli} and Sylvain Lebresne and Johan {\"O}stlund and Jan Vitek",
  authorASCII =  "Tobias Wrigstad and Francesco Zappa Nardelli and Sylvain Lebresne and Johan Ostlund and Jan Vitek",
  title = 	 "Integrating typed and untyped code in a scripting language",
  booktitle = POPL2010,
  NEEDpages = 	 "*",
  year = 	 2010,
  address = 	 POPL2010addr,
  month = 	 POPL2010date,
  abstract =
   "Many large software systems originate from untyped scripting language
    code. While good for initial development, the lack of static
    type annotations can impact code-quality and performance in the
    long run. We present an approach for integrating untyped code
    and typed code in the same system to allow an initial prototype to
    smoothly evolve into an efficient and robust program.We introduce
    like types, a novel intermediate point between dynamic and static
    typing. Occurrences of like types variables are checked statically
    within their scope but, as they may be bound to dynamic values,
    their usage is checked dynamically. Thus like types provide some
    of the benefits of static typing without decreasing the expressiveness
    of the language. We provide a formal account of like types in
    a core object calculus and evaluate their applicability in the context
    of a new scripting language.",
}






@InProceedings{AhmedFMW2009,
  author = 	 "Amal Ahmed and Robert Bruce Findler and Jacob Matthews and Philip Wadler",
  title = 	 "Blame for all",
  booktitle = STOP2009,
  NEEDpages = 	 "*",
  year = 	 2009,
  address = 	 STOP2009addr,
  month = 	 STOP2009date,
  abstract =
   "We present a language that integrates statically and dynamically typed
    components, similar to the gradual types of Siek and Taha (2006), and
    extend it to incorporate parametric polymorphism. Our system permits a
    dynamically typed value to be cast to a polymorphic type, with the type
    enforced by dynamic sealing along the lines proposed by Pierce and Sumii
    (2000), Matthews and Ahmed (2008), and Neis, Dreyer, and Rossberg (2009),
    in a way that ensures all terms satisfy relational parametricity. Our
    system includes a notion of blame, which allows us to show that when
    more-typed and less-typed portions of a program interact, that any type
    failures are due to the less-typed portion.",
}






@InProceedings{Flanagan2006,
  author = 	 "Cormac Flanagan",
  title = 	 "Hybrid type checking",
  booktitle = POPL2006,
  NEEDpages = 	 "*",
  year = 	 2006,
  address = 	 POPL2006addr,
  month = 	 POPL2006date,
  abstract =
   "Traditional static type systems are very effective for verifying basic
    interface specifications, but are somewhat limited in the kinds
    specifications they support. Dynamically-checked contracts can enforce
    more precise specifications, but these are not checked until run time,
    resulting in incomplete detection of defects.Hybrid type checking is a
    synthesis of these two approaches that enforces precise interface
    specifications, via static analysis where possible, but also via
    dynamic checks where necessary. This paper explores the key ideas and
    implications of hybrid type checking, in the context of the
    simply-typed \lambda-calculus with arbitrary refinements of base types.",
}


@InProceedings{OuTMW2004,
  author = 	 "Xinming Ou and Gang Tan and Yitzhak Mandelbaum and David Walker",
  title = 	 "Dynamic typing with dependent types",
  booktitle = TCS2004,
  pages = 	 "437--450",
  year = 	 2004,
  address = 	 TCS2004addr,
  month = 	 TCS2004date,
  abstract =
    "Dependent type systems are promising tools programmers can use to
    increase the reliability and security of their programs. Unfortunately,
    dependently-typed programming languages require programmers to annotate
    their programs with many typing specifications to help guide the type
    checker. This paper shows how to make the process of programming with
    dependent types more palatable by defining a language in which programmers
    have fine-grained control over the trade-off between the number of
    dependent typing annotations they must place on programs and the degree of
    compile-time safety. More specifically, certain program fragments are
    marked dependent, in which case the programmer annotates them in detail and
    a dependent type checker verifies them at compile time. Other fragments are
    marked simple, in which case they may be annotation-free and dependent
    constraints are verified at run time.",
}





@InProceedings{KnowlesTGFF2006,
  author = 	 "Kenneth Knowles and Aaron Tomb and Jessica Gronski and Stephen N. Freund and Cormac Flanagan",
  title = 	 "Sage: Unified hybrid checking for first-class types, general refinement types, and \texttt{Dynamic}",
  booktitle = SFP2006,
  NEEDpages = 	 "*",
  year = 	 2006,
  address = 	 SFP2006addr,
  month = 	 SFP2006date,
  abstract =
   "This paper presents Sage, a functional programming language with a rich
    type system that supports a broad range of typing paradigms, from
    dynamically-typed Scheme-like programming, to decidable ML-like types,
    to precise refinement types. This type system is a synthesis of three
    general concepts --- first-class types, general refinement types, and
    the type Dynamic --- that add expressive power in orthogonal and
    complementary ways.
    \par
    None of these concepts are statically decidable. The Sage compiler
    uniformly circumvents this limitation using hybrid type checking, which
    inserts occasional run-time casts in particularly complicated
    situations that cannot be statically checked. We describe a prototype
    implementation of Sage and preliminary experimental results showing
    that most or all types are enforced via static type checking --- the
    number of compiler-inserted casts is very small or zero on all our
    benchmarks.",
}


@InProceedings{Thatte90,
  author = 	 "S. Thatte",
  title = 	 "Quasi-static typing",
  booktitle = POPL90,
  pages = 	 "367--381",
  year = 	 1990,
  address = 	 POPL90addr,
  month = 	 POPL90date,
  OPTabstract =  "",
}



@InProceedings{AndersonD2003,
  author = 	 "Christopher Anderson and Sophia Drossopoulou",
  title = 	 "{BabyJ}: From object based to class based programming via types ",
  booktitle = "WOOD2003, Workshop on Object Oriented Developments",
  pages = 	 "53--81",
  year = 	 2003,
  address = 	 "Warsaw, Poland",
  month = 	 oct,
  abstract =
   "Object oriented programming can be classified into the object based, and
    the class based paradigm. Object based languages typically are weakly typed
    and interpreted, allow member addition and removal, and thus they support
    flexibility and prototyping. Class based languages are usually strongly
    typed and compiled, require a rigid class structure and class membership,
    and thus they support more robust, type safe programs.
    \par
    The two paradigms therefore address the needs of different stages in the
    programming lifecycle: object based programming better fits the earlier,
    exploratory phases, whereas class based better fits the latter,
    consolidation and maintenance phases. Because the transition from one
    paradigm to the other is not straightforward, programs tend to be developed
    in one of the two paradigms, thus foregoing the advantages of the other.
    \par
    We suggest that this need not be so, and that the benefits of the two
    paradigms can be combined: The earlier, exploratory, programming phases
    should take place in an object based setting. Then, the program should be
    incrementally annotated with types. Once fully typed, the program can be
    mapped onto an equivalent class based program.
    \par
    We demonstrate these ideas through the introduction of BabyJ, a
    formalization of Javascript. We define BabyJ$^T$, a typed extension of
    BabyJ. A permissive type in BabyJ allows the typing process to be
    incremental. We then define a meaning preserving transformation of
    BabyJ$^T$ programs to Java programs.",
}



@InProceedings{FindlerF2002,
  author = 	 "Robert Bruce Findler and Matthias Felleisen",
  title = 	 "Contracts for higher-order functions",
  booktitle = ICFP2002,
  pages = 	 "48-59",
  year = 	 2002,
  address = 	 ICFP2002addr,
  month = 	 ICFP2002date,
  abstract =
   "Assertions play an important role in the construction of robust software.
    Their use in programming languages dates back to the 1970s.
    Eiffel, an object-oriented programming language, wholeheartedly
    adopted assertions and developed the ``Design by Contract'' philosophy.
    Indeed, the entire object-oriented community recognizes the
    value of assertion-based contracts on methods.
    \par
    In contrast, languages with higher-order functions do not support
    assertion-based contracts. Because predicates on functions are,
    in general, undecidable, specifying such predicates appears to be
    meaningless. Instead, the functional languages community developed
    type systems that statically approximate interesting predicates.
    In this paper, we show how to support higher-order function contracts
    in a theoretically well-founded and practically viable manner.
    Specifically, we introduce lCON, a typed lambda calculus with
    assertions for higher-order functions. The calculus models the assertion
    monitoring system that we employ in DrScheme. We establish
    basic properties of the model (type soundness, etc.) and
    illustrate the usefulness of contract checking with examples from
    DrScheme's code base.
    \par
    We believe that the development of an assertion system for higherorder
    functions serves two purposes. On one hand, the system has
    strong practical potential because existing type systems simply cannot
    express many assertions that programmers would like to state.
    On the other hand, an inspection of a large base of invariants may
    provide inspiration for the direction of practical future type system
    research.",
}



@InProceedings{GrayFF2005,
  author = 	 "Gray, Kathryn E. and Findler, Robert Bruce and Flatt, Matthew",
  title = 	 "Fine-grained interoperability through mirrors and contracts",
  booktitle = OOPSLA2005,
  pages = 	 "231--245",
  year = 	 2005,
  address = 	 OOPSLA2005addr,
  month = 	 OOPSLA2005date,
  abstract =
   "As a value flows across the boundary between interoperating languages, it
    must be checked and converted to fit the types and representations of the
    target language. For simple forms of data, the checks and coercions can be
    immediate; for higher order data, such as functions and objects, some must
    be delayed until the value is used in a particular way. Typically, these
    coercions and checks are implemented by an ad-hoc mixture of wrappers,
    reflection, and dynamic predicates. We observe that 1) the wrapper and
    reflection operations fit the profile of mirrors, 2) the checks correspond
    to contracts, and 3) the timing and shape of mirror operations coincide
    with the timing and shape of contract operations. Based on these insights,
    we present a new model of interoperability that builds on the ideas of
    mirrors and contracts, and we describe an interoperable implementation of
    Java and Scheme that is guided by the model.",
}



@InProceedings{FindlerLF2001,
  author = 	 "Findler, Robert Bruce and Latendresse, Mario and Felleisen, Matthias",
  title = 	 "Behavioral contracts and behavioral subtyping",
  booktitle = FSE2001,
  pages = 	 "229--236",
  year = 	 2001,
  address = 	 FSE2001addr,
  month = 	 FSE2001date,
  abstract =
   "Component-based software manufacturing has the potential to bring
    division-of-labor benefits to the world of software engineering. In order
    to make a market of software components viable, however, producers and
    consumers must agree on enforceable software contracts.
    \par
    In this paper, we show how to enforce contracts if components are
    manufactured from class and interface hierarchies. In particular, we focus
    on one style of contract: pre- and post-conditions. Programmers annotate
    class and interface methods with pre- and post-conditions and the run-time
    system checks these conditions during evaluation. These contracts guarantee
    that methods are called properly and provide appropriate results.
    \par
    In procedural languages, the use of pre- and post-condition contracts is
    well-established and studies have demonstrated its value. In
    object-oriented languages, however, assigning blame for pre- and
    post-condition failures poses subtle and complex problems. Specifically,
    assigning blame for malformed class and interface hierarchies is so
    difficult that none of the existing contract monitoring tools correctly
    assign blame for these failures. In this paper, we show how to overcome
    these problems in the context of Java. Our work is based on the notion of
    behavioral subtyping.",
}



@InProceedings{WadlerF2009,
  author = 	 "Wadler, Philip and Findler, Robert Bruce",
  title = 	 "Well-typed programs can't be blamed",
  booktitle = ESOP2009,
  pages = 	 "1--16",
  year = 	 2009,
  address = 	 ESOP2009addr,
  month = 	 ESOP2009date,
  abstract =
   "We introduce the blame calculus, which adds the notion of blame from
    Findler and Felleisen's contracts to a system similar to Siek and Taha's
    gradual types and Flanagan's hybrid types. We characterise where
    positive and negative blame can arise by decomposing the usual notion of
    subtype into positive and negative subtypes, and show that these
    recombine to yield naive subtypes. Naive subtypes previously appeared in
    type systems that are unsound, but we believe this is the first time
    naive subtypes play a role in establishing type soundness.",
}

@InProceedings{SiekT2006,
  author = 	 "Jeremy G. Siek and Walid Taha",
  title = 	 "Gradual typing for functional languages",
  booktitle = SFP2006,
  pages = 	 "81--92",
  year = 	 2006,
  address = 	 SFP2006addr,
  month = 	 SFP2006date,
  abstract =
   "Static and dynamic type systems have well-known strengths and
    weaknesses, and each is better suited for different programming
    tasks. There have been many efforts to integrate static and dynamic
    typing and thereby combine the benefits of both typing disciplines
    in the same language. The flexibility of static typing can be improved
    by adding a type Dynamic and a typecase form. The safety
    and performance of dynamic typing can be improved by adding
    optional type annotations or by performing type inference (as in
    soft typing). However, there has been little formal work on type
    systems that allow a programmer-controlled migration between dynamic
    and static typing. Thatte proposed Quasi-Static Typing, but
    it does not statically catch all type errors in completely annotated
    programs. Anderson and Drossopoulou defined a nominal type system
    for an object-oriented language with optional type annotations.
    However, developing a sound, gradual type system for functional
    languages with structural types is an open problem.
    \par
    In this paper we present a solution based on the intuition that the
    structure of a type may be partially known/unknown at compile time
    and the job of the type system is to catch incompatibilities
    between the known parts of types. We define the static and dynamic
    semantics of a $\lambda$-calculus with optional type annotations and we
    prove that its type system is sound with respect to the simply-typed
    $\lambda$-calculus for fully-annotated terms. We prove that this calculus
    is type safe and that the cost of dynamism is ``pay-as-you-go''.",
}



@InProceedings{HermanTF2007,
  author = 	 "David Herman and Aaron Tomb and Cormac Flanagan",
  title = 	 "Space-efficient gradual typing",
  booktitle = "Trends in Functional Programming (TFP)",
  NEEDpages = 	 "*",
  year = 	 2007,
  NEEDaddress = 	 "*",
  NEEDmonth = 	 "*",
  abstract =
   "Gradual type systems offer a smooth continuum between static and dynamic
    typing by permitting the free mixture of typed and untyped code. The
    runtime systems for these languages---and other languages with hybrid type
    checking---typically enforce function types by dynamically generating
    function proxies. This approach can result in unbounded growth in the
    number of proxies, however, which drastically impacts space efficiency and
    destroys tail recursion.
    \par
    We present an implementation strategy for gradual typing that is based on
    coercions instead of function proxies, and which combines adjacent
    coercions to limit their space consumption. We prove bounds on the space
    consumed by coercions as well as soundness of the type system,
    demonstrating that programmers can safely mix typing disciplines without
    incurring unreasonable overheads. Our approach also detects certain errors
    earlier than prior work.",
}



@InProceedings{SiekT2007,
  author = 	 "Siek, Jeremy and Taha, Walid",
  title = 	 "Gradual typing for objects",
  booktitle = ECOOP2007,
  pages = 	 "2--27",
  year = 	 2007,
  address = 	 ECOOP2007addr,
  month = 	 ECOOP2007date,
  abstract =
   "Static and dynamic type systems have well-known strengths and
    weaknesses. In previous work we developed a gradual type system for a
    functional calculus named $\lambda^?_\rightarrow$. Gradual typing provides
    the benefits of both static and dynamic checking in a single language by
    allowing the programmer to control whether a portion of the program is type
    checked at compile-time or run-time by adding or removing type annotations
    on variables. Several object-oriented scripting languages are preparing to
    add static checking. To support that work this paper develops Ob$^?_{<:}$,
    a gradual type system for object-based languages, extending the Ob$_{<:}$
    calculus of Abadi and Cardelli. Our primary contribution is to show that
    gradual typing and subtyping are orthogonal and can be combined in a
    principled fashion. We also develop a small-step semantics, provide a
    machine-checked proof of type safety, and improve the space efficiency of
    higher-order casts.",
}


@InProceedings{SiekV2008,
  author = 	 "Jeremy Siek and Manish Vachharajani",
  title = 	 "Gradual typing with unification-based inference",
  booktitle = DLS2008,
  NEEDpages = 	 "*",
  year = 	 2008,
  address = 	 DLS2008addr,
  month = 	 DLS2008date,
  abstract =
   "Static and dynamic type systems have well-known strengths and
    weaknesses. Gradual typing provides the benefits of both in a
    single language by giving the programmer control over which portions
    of the program are statically checked based on the presence or absence
    of type annotations.  This paper studies the combination of gradual
    typing and unification-based type inference with the goal of
    developing a system that helps programmers increase the amount of
    static checking in their program.  The key question in combining
    gradual typing and type inference is how should the dynamic type of a
    gradual system interact with the type variables of a type inference
    system. This paper explores the design space and shows why three
    straightforward approaches fail to meet our design goals.  This paper
    presents a new type system based on the idea that a solution for a
    type variable should be as informative as any type that constrains the
    variable.  The paper also develops an efficient inference algorithm
    and proves it sound and complete with respect to the type system.",
}


@InProceedings{SiekGT2009,
  author = 	 "Jeremy G. Siek and Ronald Garcia and Walid Taha",
  title = 	 "Exploring the design space of higher-order casts",
  booktitle = ESOP2009,
  NEEDpages = 	 "*",
  year = 	 2009,
  address = 	 ESOP2009addr,
  month = 	 ESOP2009date,
  abstract =
   "This paper explores the surprisingly rich design space for the simply typed
    lambda calculus with casts and a dynamic type. Such a calculus is the
    target intermediate language of the gradually typed lambda calculus but it
    is also interesting in its own right. In light of diverse requirements for
    casts, we develop a modular semantic framework, based on Henglein's
    Coercion Calculus, that instantiates a number of space-efficient,
    blame-tracking calculi, varying in what errors they detect and how they
    assign blame. Several of the resulting calculi extend work from the
    literature with either blame tracking or space efficiency, and in doing so
    reveal previously unknown connections. Furthermore, we introduce a new
    strategy for assigning blame under which casts that respect traditional
    subtyping are statically guaranteed to never fail. One particularly
    appealing outcome of this work is a novel cast calculus that is well-suited
    to gradual typing.",
}


@InProceedings{SiekW2009,
  author = 	 "Jeremy G. Siek and Philip Wadler",
  title = 	 "Threesomes, with and without blame",
  booktitle = STOP2009,
  pages = 	 "34--46",
  year = 	 2009,
  address = 	 STOP2009addr,
  month = 	 STOP2009date,
  supersededby = "SiekW2010"
}


@InProceedings{SiekW2010,
  author = 	 "Jeremy G. Siek and Philip Wadler",
  title = 	 "Threesomes, with and without blame",
  booktitle =    POPL2010,
  NEEDpages = 	 "*",
  year = 	 2010,
  address = 	 POPL2010addr,
  month = 	 POPL2010date,
  abstract =
   "How to integrate static and dynamic types? Recent work focuses
    on casts to mediate between the two. However, adding casts may
    degrade tail calls into a non-tail calls, increasing space consumption
    from constant to linear in the depth of calls.
    \par
    We present a new solution to this old problem, based on the
    notion of a threesome. A cast is specified by a source and a target
    type---a twosome. Any twosome factors into a downcast from the
    source to an intermediate type, followed by an upcast from the
    intermediate to the target---a threesome. Any chain of threesomes
    collapses to a single threesome, calculated by taking the greatest
    lower bound of the intermediate types. We augment this solution
    with blame labels to map any failure of a threesome back to the
    offending twosome in the source program.
    \par
    Herman, Tomb, and Flanagan (2007) solve the space problem
    by representing casts with the coercion calculus of Henglein
    (1994). While they provide a theoretical limit on the space overhead,
    there remains the practical question of how best to implement
    coercion reduction. The threesomes presented in this paper
    provide a streamlined data structure and algorithm for representing
    and normalizing coercions. Furthermore, threesomes provide a
    typed-based explanation of coercion reduction."
}



@InProceedings{TobinHochstadtF2006,
  author = 	 "Sam Tobin-Hochstadt and Matthias Felleisen",
  title = 	 "Interlanguage migration: From scripts to programs",
  booktitle = DLS2006,
  NEEDpages = 	 "*",
  year = 	 2006,
  address = 	 DLS2006addr,
  month = 	 DLS2006date,
  abstract =
   "As scripts grow into full-fledged applications, programmers should want to
    port portions of their programs from scripting languages to languages with
    sound and rich type systems.  This form of interlanguage migration ensures
    type-safety and provides minimal guarantees for reuse in other
    applications, too.
    \par
    In this paper, we present a framework for expressing this form of
    interlanguage migration. Given a program that consists of modules in the
    untyped lambda calculus, we prove that rewriting one of them in a simply
    typed lambda calculus produces an equivalent program and adds the expected
    amount of type safety, i.e., code in typed modules can't go wrong. To
    ensure these guarantees, the migration process infers constraints from the
    statically typed module and imposes them on the dynamically typed modules
    in the form of behavioral contracts.",
}



@InProceedings{TobinHochstadtF2008,
  author = 	 "Sam Tobin-Hochstadt and Matthias Felleisen",
  title = 	 "The design and implementation of {Typed} {Scheme}",
  booktitle = POPL2008,
  NEEDpages = 	 "*",
  year = 	 2008,
  address = 	 POPL2008addr,
  month = 	 POPL2008date,
  abstract =
   "When scripts in untyped languages grow into large programs, maintaining
    them becomes difficult. A lack of types in typical scripting
    languages means that programmers must (re)discover critical
    pieces of design information every time they wish to change a program.
    This analysis step both slows down the maintenance process
    and may even introduce mistakes due to the violation of undiscovered
    invariants.
    \par
    This paper presents Typed Scheme, an explicitly typed extension
    of an untyped scripting language. Its type system is based on
    the novel notion of occurrence typing, which we formalize and mechanically
    prove sound. The implementation of Typed Scheme additionally
    borrows elements from a range of approaches, including
    recursive types, true unions and subtyping, plus polymorphism
    combined with a modicum of local inference. Initial experiments
    with the implementation suggest that Typed Scheme naturally accommodates
    the programming style of the underlying scripting language,
    at least for the first few thousand lines of ported code.",
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Other static analyses
%%%


@InProceedings{OCallahan97a,
  author =       "Robert O'Callahan and Daniel Jackson",
  title =        "Lackwit: A Program Understanding Tool Based on Type
                 Inference",
  booktitle =    ICSE97,
  address =      ICSE97addr,
  year =         1997,
  pages =        "338--348",
  month =        ICSE97date,
  abstract =
   "By determining, statically, where the structure of a program requires sets
    of variables to share a common representation, we can identify abstract
    data types, detect abstraction violations, find unused variables,
    functions, and fields of data structures, detect simple errors in
    operations on abstract datatypes, and locate sites of possible references
    to a value.  We compute representation sharing with type inference, using
    types to encode representations.  The method is efficient, fully automatic,
    and smoothly integrates pointer aliasing and higher-order functions.  We
    show how we used a prototype tool to answer a user's questions about a
    17,000 line program written in C.",
}


@TechReport{OCallahanJ96,
  author = 	 "Robert O'Callahan and Daniel Jackson",
  title = 	 "Practical program understanding with type inference",
  institution =  "School of Computer Science, Carnegie Mellon University",
  year = 	 1996,
  number =	 "CMU-CS-96-130",
  address =	 "Pittsburgh, PA",
  month =	 may
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Etc (perhaps will later be broken into more sections)
%%%

@Book{pierce:2002:types-and-pls,
  author =  {Benjamin C. Pierce},
  title =  {Types and Programming Languages},
  publisher =  {MIT Press},
  year =  2002
}


@Article{Milner78,
   Author={Robin Milner},
   Journal=JCSS,
   Title={A Theory of Type Polymorphism in Programming},
   Year=1978,
   Pages={348--375},
   Volume=17,
   Number=3,
   }


@InProceedings{FlanaganQ2003,
  author = 	 "Cormac Flanagan and Shaz Qadeer",
  title = 	 "A type and effect system for atomicity",
  booktitle =	 POPL2003,
  pages =	 "338--349",
  year =	 2003,
  address =	 POPL2003addr,
  month =	 POPL2003date,
  abstract =
   "Ensuring the correctness of multithreaded programs is difficult, due to the
    potential for unexpected and nondeterministic interactions between
    threads. Previous work addressed this problem by devising tools for
    detecting race conditions, a situation where two threads simultaneously
    access the same data variable, and at least one of the accesses is a
    write. However, verifying the absence of such simultaneous-access race
    conditions is neither necessary nor sufficient to ensure the absence of
    errors due to unexpected thread interactions.
    \par
    We propose that a stronger non-interference property is required, namely
    atomicity. Atomic methods can be assumed to execute serially, without
    interleaved steps of other threads. Thus, atomic methods are amenable to
    sequential reasoning techniques, which significantly simplifies both formal
    and informal reasoning about program correctness.
    \par
    This paper presents a type system for specifying and verifying the
    atomicity of methods in multithreaded Java programs. The atomic type system
    is a synthesis of Lipton's theory of reduction and type systems for race
    detection.
    \par
    We have implemented this atomic type system for Java and used it to check a
    variety of standard Java library classes. The type checker uncovered subtle
    atomicity violations in classes such as java.lang.String and
    java.lang.StringBuffer that cause crashes under certain thread
    interleavings."
}


@InProceedings{DeanGC95,
  author = 	 "Jeffrey Dean and David Grove and Craig Chambers",
  title = 	 "Optimization of Object-Oriented Programs Using Static
                  Class Hierarchy Analysis",
  booktitle =	 ECOOP95,
  pages =	 "77--101",
  year =	 1995,
  address =	 ECOOP95addr,
  month =	 ECOOP95date,
  abstract =
   "Optimizing compilers for object-oriented languages apply static class
    analysis and other techniques to try to deduce precise information about
    the possible classes of the receivers of messages; if successful,
    dynamically-dispatched messages can be replaced with direct procedure calls
    and potentially further optimized through inline-expansion. By examining
    the complete inheritance graph of a program, which we call class hierarchy
    analysis, the compiler can improve the quality of static class information
    and thereby improve run-time performance. In this paper we present class
    hierarchy analysis and describe techniques for implementing this analysis
    effectively in both statically- and dynamically-typed languages and also in
    the presence of multi-methods. We also discuss how class hierarchy analysis
    can be supported in an interactive programming environment and, to some
    extent, in the presence of separate compilation. Finally, we assess the
    bottom-line performance improvement due to class hierarchy analysis alone
    and in combination with two other ``competing'' optimizations, profile-guided
    receiver class prediction and method specialization.",
}


@InProceedings{BaconS96,
  author = 	 "David F. Bacon and Peter F. Sweeney",
  title = 	 "Fast static analysis of {C++} virtual function calls",
  booktitle =	 OOPSLA96,
  pages =	 "324--341",
  year =	 1996,
  address =	 OOPSLA96addr,
  month =	 OOPSLA96date,
  doi = {http://doi.acm.org/10.1145/236337.236371},
}




@InProceedings{TipP2000,
  author = 	 "Frank Tip and Jens Palsberg",
  title = 	 "Scalable propagation-based call graph construction algorithms",
  booktitle =	 OOPSLA2000,
  pages =	 "281--293",
  year =	 2000,
  address =	 OOPSLA2000addr,
  month =	 OOPSLA2000date
}


@InProceedings{Palsberg01,
  author = 	 "Jens Palsberg",
  title = 	 "Type-based analysis and applications",
  booktitle =	 PASTE2001,
  pages = 	 "20--27",
  year =	 2001,
  address =	 PASTE2001addr,
  month =	 PASTE2001date
}




@InProceedings{AntoniuSKNF,
  author = 	 "Tudor Antoniu and Paul Steckler and Shriram Krishnamurthi
                  and Erich Neuwirth and Matthias Felleisen",
  title = 	 "Validating the unit correctness of spreadsheet programs",
  booktitle =	 ICSE2004,
  pages = 	 "439--448",
  year =	 2004,
  address =	 ICSE2004addr,
  month =	 ICSE2004date,
  abstract =
   "Financial companies, engineering firms and even scientists create
    increasingly larger spreadsheets and spreadsheet programs. The creators of
    large spreadsheets make errors and must track them down. One common class
    of errors concerns unit errors, because spreadsheets often employ formulas
    with physical or monetary units.
    \par
    In this paper, we describe XeLda, our tool for unit checking Excel
    spreadsheets. The tool highlights cells if their formulas process values
    with incorrect units and if derived units clash with unit annotations. In
    addition, it draws arrows to the sources of the formulas for debugging. The
    tool is sensitive to many of the intricacies of Excel spreadsheets
    including tables, matrices, and even circular references. Using XeLda, we
    have detected errors in some published scientific spreadsheets.",
}




@InProceedings{ValleeRaiHSLGC99,
  author = 	 "Raja Vall{\'e}e-Rai and Laurie Hendren and Vijay
                  Sundaresan and Patrick Lam and Etienne Gagnon and Phong
                  Co",
  title = 	 "Soot --- a {Java} bytecode optimization framework",
  booktitle =	 CASCON1999,
  pages =	 "125--135",
  year =	 1999,
  address =	 CASCON1999addr,
  month =	 CASCON1999date,
  OMITpublisher = "IBM Press"
}

@InProceedings{NeculaMRW2002,
  author =       {George C. Necula and Scott McPeak and S.P. Rahul and Westley Weimer},
  title =        {{CIL}: Intermediate Language and Tools for Analysis and Transformation of {C} Programs},
  booktitle =    CC2002,
  year =         2002,
  address =      CC2002addr,
  month =        CC2002date,
  pages =        "213--228"
}

@InProceedings{AikenW93,
  author = 	 "Alexander Aiken and Edward L. Wimmers",
  title = 	 "Type inclusion constraints and type inference",
  booktitle =	 FPCA93,
  pages =	 "31--41",
  year =	 1993,
  address =	 FPCA93addr,
  month =	 FPCA93date
}


@book{PalsbergS94,
 author = {Jens Palsberg and Michael I. Schwartzbach},
 title = {Object-Oriented Type Systems},
 year = {1994},
 isbn = {0-471-94128-X},
 publisher = {John Wiley and Sons},
 }


@InProceedings{McAdamKB2001,
  author = 	 "Bruce McAdam and Andrew Kennedy and Nick Benton",
  title = 	 "Type Inference for {MLj}",
  booktitle =	 "Scottish Functional Programming Workshop",
  pages =	 "159--172",
  year =	 2001,
  note =	 "Trends in Functional Programming, volume 2, Chapter 13",
  URL =          "http://www.dcs.ed.ac.uk/home/stg/sfpw/book/McAdam/cameraready.ps",
}


@InProceedings{DeSutterTD2004,
  author = 	 "Bjorn {De Sutter} and Frank Tip and Julian Dolby",
  title = 	 "Customization of {Java} library classes using type
                  constraints and profile information",
  booktitle =	 ECOOP2004,
  pages = 	 "585--610",
  year =	 2004,
  address =	 ECOOP2004addr,
  month =	 ECOOP2004date,
  abstract =
   "The use of class libraries increases programmer productivity by allowing
    programmers to focus on the functionality unique to their
    application. However, library classes are generally designed with some
    typical usage pattern in mind, and performance may be suboptimal if the
    actual usage differs. We present an approach for rewriting applications to
    use customized versions of library classes that are generated using a
    combination of static analysis and profile information. Type constraints
    are used to determine where customized classes may be used, and profile
    information is used to determine where customization is likely to be
    profitable. We applied this approach to a number of Java applications by
    customizing various standard container classes and the omnipresent
    StringBuffer class, and measured speedups up to 78\% and memory footprint
    reductions up to 46\%. The increase in application size due to the added
    custom classes is limited to 12\% for all but the smallest programs.",
}




@InProceedings{SiffCBKR99,
  author = 	 "Michael Siff and Satish Chandra and Thomas Ball and Krishna Kunchithapadam and Thomas Reps",
  title = 	 "Coping with type casts in {C}",
  booktitle =	 FSE99,
  pages =	 "180--198",
  year =	 1999,
  address =	 FSE99addr,
  month =	 FSE99date,
  abstract =
   "The use of type casts is pervasive in C. Although casts provide great
    flexibility in writing programs, their use obscures the meaning of
    programs, and can present obstacles during maintenance. Casts involving
    pointers to structures (C structs) are particularly problematic, because by
    using them, a programmer can interpret any memory region to be of any
    desired type, thereby compromising C's already weak type system.This paper
    presents an approach for making sense of such casts, in terms of
    understanding their purpose and identifying fragile code. We base our
    approach on the observation that casts are often used to simulate
    object-oriented language features not supported directly in C. We first
    describe a variety of ways --- idioms --- in which this is done in C
    programs. We then develop a notion of physical subtyping, which provides a
    model that explains these idioms.We have created tools that automatically
    analyze casts appearing in C programs. Experimental evidence collected by
    using these tools on a large amount of C code (over a million lines) shows
    that, of the casts involving struct types, most (over 90\%) can be
    associated meaningfully --- and automatically --- with physical
    subtyping. Our results indicate that the idea of physical subtyping is
    useful in coping with casts and can lead to valuable software productivity
    tools.",
}




@Misc{Morris1978,
  author =	 "James H. Morris",
  title =	 "Sniggering Type Checker experiment",
  howpublished = "Experiment at Xerox PARC",
  year =	 1978,
  note =	 "Personal communication, May 2004"
}



@InProceedings{Tichy79,
  author = 	 "Walter F. Tichy",
  title = 	 "Software development control based on module interconnection",
  booktitle =	 ICSE79,
  pages =	 "29--41",
  year =	 1979,
  address =	 ICSE79addr,
  month =	 ICSE79date,
  abstract =
   "Constructing large software systems is not merely a matter of programming,
    but also a matter of communication and coordination. Problems arise because
    many people work on a joint project and use each other's programs. This
    paper presents an integrated development and maintenance system that
    provides a controlling environment to insure the consistency of a software
    system at the module interconnection level. It assists the programmers with
    two facilities: Interface control and version control. Interface control
    establishes consistent interfaces between software modules and maintains
    this consistency when changes are made. Version control coordinates the
    generation and integration of the various versions and configurations. Both
    facilities derive their information from an overall system description
    formulated in the module interconnection language INTERCOL. A demonstration
    system is sketched that runs under the UNIX time-sharing system."
}


@Article{PrecheltT98,
  author = 	 "Lutz Prechelt and Walter F. Tichy",
  title = 	 "A Controlled Experiment to Assess the Benefits of
                  Procedure Argument Type Checking",
  journal = 	 TSE,
  year = 	 1998,
  volume =	 24,
  number =	 4,
  pages =	 "302--312",
  month =	 apr,
  abstract =
   "Type checking is considered an important mechanism for detecting
    programming errors, especially interface errors. This report describes an
    experiment to assess the defect-detection capabilities of static,
    intermodule type checking. The experiment uses ANSI C and Kernighan&Ritchie
    (K&R) C. The relevant difference is that the ANSI C compiler checks module
    interfaces (i.e., the parameter lists calls to external functions), whereas
    K&R C does not. The experiment employs a counterbalanced design in which
    each of the 40 subjects, most of them CS PhD students, writes two
    nontrivial programs that interface with a complex library (Motif). Each
    subject writes one program in ANSI C and one in K&R C. The input to each
    compiler run is saved and manually analyzed for defects. Results indicate
    that delivered ANSI C programs contain significantly fewer interface
    defects than delivered K&R C programs. Furthermore, after subjects have
    gained some familiarity with the interface they are using, ANSI C
    programmers remove defects faster and are more productive (measured in both
    delivery time and functionality implemented).",
}


@InProceedings{PrecheltT96,
  author = 	 "Lutz Prechelt and Walter F. Tichy",
  title = 	 "An experiment to assess the benefits of inter-module type checking",
  booktitle =	 "METRICS Symposium",
  pages = 	 "112--119",
  year =	 1996,
  address =	 "Berlin",
  month =	 mar # "~25--26,",
  supersededby = "PrecheltT98",
}


@Article{Gannon77,
  author = 	 "John D. Gannon",
  title = 	 "An experimental evaluation of data type conventions",
  journal = 	 CACM,
  year = 	 1977,
  volume =	 20,
  number =	 8,
  pages =	 "584--595",
  month =	 aug
}


@InProceedings{GannonH75,
  author = 	 "John D. Gannon and James J. Horning",
  title = 	 "The impact of language design on the production of
                  reliable software",
  booktitle =	 "Proceedings of the international conference on Reliable software",
  pages =	 "10--22",
  year =	 1975,
  address =	 "Los Angeles, CA",
  NEEDmonth = 	 ""
}




% ACM cite key is 968162
@InProceedings{TorgersenPHEvdABG2004,
  author = 	 "Mads Torgersen and Christian Plesner Hansen and Erik
                  Ernst and Peter von der Ah{\'e} and Gilad Bracha and
                  Neal Gafter",
  title = 	 "Adding wildcards to the {Java} programming language",
  booktitle =	 SAC2004,
  pages =	 "1289--1296",
  year =	 2004,
  address =	 SAC2004addr,
  month =	 SAC2004date,
  doi = {http://doi.acm.org/10.1145/967900.968162},
}


@InProceedings{EdwardsJT2004,
  author = 	 "Jonathan Edwards and Daniel Jackson and Emina Torlak",
  title = 	 "A type system for object models",
  booktitle =	 FSE2004,
  pages =	 "189--199",
  year =	 2004,
  address =	 FSE2004addr,
  month =	 FSE2004date
}



@InProceedings{AnconaDDZ2005,
  author = 	 "Davide Ancona and Ferruccio Damiani and Sophia Drossopoulou and Elena Zucca",
  title = 	 "Polymorphic bytecode: compositional compilation for {Java}-like languages",
  booktitle =	 POPL2005,
  pages =	 "26--37",
  year =	 2005,
  address =	 POPL2005addr,
  month =	 POPL2005date
}



@InProceedings{Reynolds90,
  author = 	 "John C. Reynolds",
  title = 	 "Introduction to Part {II}, Polymorphic Lambda Calculus",
  booktitle =	 "Logical Foundations of Functional Programming",
  pages =	 "77--86",
  year =	 1990,
  editor =	 "G{\'e}rard Huet",
  address =	 "Reading, Massachusetts",
  publisher =	 "Addison-Wesley"
}

@InProceedings{ErwigB2002,
  author = 	 {Martin Erwig and Margaret M. Burnett},
  title = 	 {Adding Apples and Oranges},
  pages =        "171--191",
  booktitle = 	 PADL2002,
  year =	 2002,
  address =	 PADL2002addr,
  month =	 PADL2002date
}


@InProceedings{ChinM2006,
  author = 	 "Brian Chin and Todd Millstein",
  title = 	 "Responders: Language Support for Interactive Applications",
  booktitle = ECOOP2006,
  pages = 	 "255--278",
  year = 	 2006,
  address = 	 ECOOP2006addr,
  month = 	 ECOOP2006date,
}





@InProceedings{TorgersenEPH2005,
  author = 	 "Torgersen, Mads and Ernst, Erik and Plesner Hansen, Christian",
  title = 	 "Wild {FJ}",
  booktitle = FOOL2005,
  NOpages = 	 "*",
  year = 	 2005,
  address = 	 FOOL2005addr,
  month = 	 FOOL2005date,
  abstract = 	 "This paper presents a formalization of
                  wildcards, which is one of the new features of
                  the Java programming language in version
                  JDK5.0. Wildcards help alleviating the
                  impedance mismatch between generics, or
                  parametric polymorphism, and traditional
                  object-oriented subtype polymorphism. They do
                  this by quantifying over parameterized types
                  with different type arguments. Wildcards take
                  inspiration from several sources including
                  use-site variance, and they could be considered
                  as a way to introduce a syntactically
                  light-weight kind of existential types into a
                  main-stream language. This formalization
                  describes the mechanism, in particular the
                  wildcard capture process where the existential
                  nature of wildcards becomes evident.",
}


@Article{Igarashi:2001:FJM,
  author =       "Atsushi Igarashi and Benjamin C. Pierce and Philip
                 Wadler",
  title =        "Featherweight {Java}: a minimal core calculus for
                 {Java} and {GJ}",
  journal =      TOPLAS,
  volume =       "23",
  number =       "3",
  pages =        "396--450",
  month =        may,
  year =         "2001",
  CODEN =        "ATPSDT",
  ISSN =         "0164-0925",
  bibdate =      "Tue Feb 19 15:41:56 MST 2002",
  bibsource =    "http://www.acm.org/pubs/contents/journals/toplas/",
  acknowledgement = ack-nhfb,
}



@InProceedings{BalabanTF2005,
  author = 	 "Ittai Balaban and Frank Tip and Robert Fuhrer",
  title = 	 "Refactoring support for class library migration",
  booktitle = OOPSLA2005,
  pages = 	 "265--279",
  year = 	 2005,
  address = 	 OOPSLA2005addr,
  month = 	 OOPSLA2005date,
}


@InProceedings{SteimannMM2006,
  author = 	 "Friedrich Steimann and Philip Mayer and Andreas Mei{\ss}ner",
  authorASCII =  "Andreas Meiner    Andreas Meissner",
  title = 	 "Decoupling classes with inferred interfaces",
  booktitle = SAC2006,
  pages = 	 "1404--1408",
  year = 	 2006,
  address = 	 SAC2006addr,
  month = 	 SAC2006date,
}




@PhdThesis{Xi1998,
  author = 	 "Hongwei Xi",
  title = 	 "Dependent Types in Practical Programming",
  school = 	 "Carnegie Mellon University",
  year = 	 1998,
  address = 	 "Pittsburgh, PA, USA",
  month = 	 dec,
}


@InProceedings{McKinna,
  author = 	 "James McKinna",
  title = 	 "Why dependent types matter",
  booktitle = POPL2006,
  pages = 	 1,
  year = 	 2006,
  address = 	 POPL2006addr,
  month = 	 POPL2006date,
}





@Booklet{ECMA334-4th,
  key =          "ECMA 334",
  title = 	 "{ECMA} 334: C\# Language Specification, 4th edition",
  titleASCII = 	 "ECMA 334: C# Language Specification, 4th edition",
  howpublished = "ECMA International",
  month = 	 jun,
  year = 	 2006,
}


@Book{HejlsbergWG2003,
  author = 	 "Anders Hejlsberg and Scott Wiltamuth and Peter Golde",
  title = 	 "C\# Language Specification",
  publisher = 	 "Addison-Wesley Longman Publishing Co., Inc.",
  year = 	 2003,
  address = 	 "Boston, MA, USA",
}


@InProceedings{HuangZS2007:cJ,
  author = 	 "Shan Shan Huang and David Zook and Yannis Smaragdakis",
  title = 	 "{cJ}:  Enhancing {Java} with safe type conditions",
  booktitle = AOSD2007,
  pages = 	 "185--198",
  year = 	 2007,
  address = 	 AOSD2007addr,
  month = 	 AOSD2007date,
  abstract =
   "cJ is an extension of Java that allows supertypes, fields, and methods of a
    class or interface to be provided only under some static subtyping
    condition. For instance, a cJ generic class, C<P>, may provide a member
    method m only when the type provided for parameter P is a subtype of a
    specific type Q.
    \par
    From a practical standpoint, cJ adds to generic Java classes and interfaces
    the ability to express case-specific code. Unlike conditional compilation
    techniques (e.g., the C/C++ ``#ifdef'' construct) cJ is statically type safe
    and maintains the modular type-checking properties of Java generic classes:
    a cJ generic class can be checked independently of the code that uses
    it. Just like regular Java, checking a cJ class implies that all uses are
    safe, under the contract for type parameters specified in the class's
    signature.
    \par
    As a specific application, cJ addresses the well-known shortcomings of the
    Java Collections Framework (JCF). JCF data structures often throw run-time
    errors when an ``optional'' method is called upon an object that does not
    support it. Within the constraints of standard Java, the authors of the JCF
    had to either sacrifice static type safety or suffer a combinatorial
    explosion of the number of types involved. cJ avoids both problems,
    maintaining both static safety and conciseness.",
}


@InProceedings{HuangZS2007:Morphing,
  author = 	 "Shan Shan Huang and David Zook and Yannis Smaragdakis",
  title = 	 "Morphing:  Safely shaping a class in the image of others",
  booktitle = ECOOP2007,
  pages = 	 "399--424",
  year = 	 2007,
  address = 	 ECOOP2007addr,
  month = 	 ECOOP2007date,
  abstract =
   "We present MJ: a language for specifying general classes whose members are
    produced by iterating over members of other classes.  We call this
    technique ``class morphing'' or just ``morphing''. Morphing extends the
    notion of genericity so that not only types of methods and fields, but also
    the structure of a class can vary according to type variables. This offers
    the ability to express common programming patterns in a highly generic way
    that is otherwise not supported by conventional techniques. For instance,
    morphing lets us write generic proxies (i.e., classes that can be
    parameterized with another class and export the same public methods as that
    class); default implementations (e.g., a generic do-nothing type,
    configurable for any interface); semantic extensions (e.g., specialized
    behavior for methods that declare a certain annotation); and more. MJ's
    hallmark feature is that, despite its emphasis on generality, it allows
    modular type checking: an MJ class can be checked independently of its
    uses. Thus, the possibility of supplying a type parameter that will lead to
    invalid code is detected early---an invaluable feature for highly general
    components that will be statically instantiated by other programmers.",
}


@InProceedings{Wadler92,
  author = 	 "Philip Wadler",
  title = 	 "Comprehending monads",
  booktitle =    LFP92,
  pages = 	 "461--493",
  year = 	 1992,
  address = 	 LFP92addr,
  month = 	 LFP92date,
}


@Misc{JSR133,
  author =       "William Pugh",
  title =        "{JSR} 133: \textsc{Java} Memory Model and Thread Specification Revision",
  howpublished = "\url{http://jcp.org/en/jsr/detail?id=133}",
  month =        sep # "~30,",
  year =         2004,
}



@Misc{Goetz2006:typedef,
  author = 	 "Brian Goetz",
  title = 	 "The pseudo-typedef antipattern: Extension is not type definition",
  howpublished = "\url{http://www.ibm.com/developerworks/library/j-jtp02216.html}",
  month = 	 feb # "~21,",
  year = 	 2006,
}



@InProceedings{LernerFGC2007,
  author = 	 "Benjamin S. Lerner and Matthew Flower and Dan Grossman and Craig Chambers",
  title = 	 "Searching for type-error messages",
  booktitle = PLDI2007,
  pages = 	 "425--434",
  year = 	 2007,
  address = 	 PLDI2007addr,
  month = 	 PLDI2007date,
  abstract =
   "Advanced type systems often need some form of type inference to reduce the
    burden of explicit typing, but type inference often leads to poor error
    messages for ill-typed programs. This work pursues a new approach to
    constructing compilers and presenting type-error messages in which the
    type-checker itself does not produce the messages. Instead, it is an oracle
    for a search procedure that finds similar programs that do type-check. Our
    two-fold goal is to improve error messages while simplifying compiler
    construction.
    \par
    Our primary implementation and evaluation is for Caml, a language with full
    type inference. We also present a prototype for C++ template functions,
    where type instantiation is implicit. A key extension is making our
    approach robust even when the program has multiple independent type errors.",
}




@Misc{Eiffel-ECMA367,
  key = 	 "Eiffel",
  OPTauthor = 	 "",
  title = 	 "Eiffel: Analysis, Design and Programming Language",
  howpublished = "Standard ECMA-367",
  month = 	 jun,
  year = 	 2006,
  note = 	 "2nd edition",
}


@Manual{Nice-users-manual,
  title = 	 "The {Nice} user's manual",
  OPTkey = 	 "",
  author = 	 "Daniel Bonniot and Bryn Keller and Francis Barber",
  OPTorganization = "",
  OPTaddress = 	 "",
  OPTedition = 	 "",
  OPTmonth = 	 "",
  year = 	 2003,
  note = 	 "\url{http://nice.sourceforge.net/}",
  OPTannote = 	 "",
}


@Book{OderskySV2008,
  author = 	 "Martin Odersky and Lex Spoon and Bill Venners",
  title = 	 "Programming in Scala:  A comprehensive step-by-step guide",
  publisher = 	 "Artima",
  year = 	 2008,
}


@InProceedings{CohenGM2005,
  author = 	 "Tal Cohen and Joseph (Yossi) Gil and Itay Maman",
  title = 	 "JTL: The {Java} tools language",
  booktitle = OOPSLA2006,
  pages = 	 "89--108",
  year = 	 2006,
  address = 	 OOPSLA2006addr,
  month = 	 OOPSLA2006date,
  abstract =
   "We present an overview of JTL (the Java Tools Language, pronounced
    ``Gee-tel''), a novel language for querying Java [8] programs. JTL was
    designed to serve the development of source code software tools for Java,
    and as a small language which to aid programming language extensions to
    Java. Applications include definition of pointcuts for aspect-oriented
    programming, fixing type constraints for generic programming, specification
    of encapsulation policies, definition of micro-patterns, etc. We argue that
    the JTL expression of each of these is systematic, concise, intuitive and
    general.
    \par
    JTL relies on a simply-typed relational database for program
    representation, rather than an abstract syntax tree. The underlying
    semantics of the language is restricted to queries formulated in First
    Order Predicate Logic augmented with transitive closure (FOPL*).
    \par
    Special effort was taken to ensure terse, yet readable expression of
    logical conditions. The JTL pattern \texttt{public abstract class}, for
    example, matches all abstract classes which are publicly accessible, while
    \texttt{class (public clone();)} matches all classes in which method clone
    is public. To this end, JTL relies on a Datalog-like syntax and semantics,
    enriched with quantifiers and pattern matching which all but entirely
    eliminate the need for recursive calls.
    \par
    JTL's query analyzer gives special attention to the fragility of the
    ``closed world assumption'' in examining Java software, and determines
    whether a query relies on such an assumption.
    \par
    The performance of the JTL interpreter is comparable to that of JQuery
    after it generated its database cache, and at least an order of magnitude
    faster when the cache has to be rebuilt.",
}




@Book{Copeland2005,
  author = 	 "Tom Copeland",
  title = 	 "PMD Applied",
  publisher = 	 "Centennial Books",
  year = 	 2005,
  month = 	 nov,
}


@TechReport{MitchellMS79,
  author = 	 "James G. Mitchell and William Maybury and Richard Sweet",
  title = 	 "The {Mesa} language manual",
  institution =  PARC,
  year = 	 1979,
  number = 	 "CSL-79-3",
  NEEDaddress = 	 "*",
  month = 	 apr,
}



@TechReport{Lampson83,
  author = 	 "Butler Lampson",
  title = 	 "A description of the {Cedar} language",
  institution =  PARC,
  year = 	 1983,
  number = 	 "CSL-83-15",
  NEEDaddress = 	 "*",
  month = 	 dec,
  abstract =
   "The Cedar language is a programming language derived from Mesa, which
   in turn is derived from Pascal. It is meant to be used for a wide
   variety of programming tasks, ranging from low level systems software to
   large applications. In addition to the sequential control constructs,
   static type checking and structured types of Pascal, and the modules,
   exception handling, and concurrency control constructs of Mesa, Cedar
   also has garbage collection, dynamic types, and a limited form of type
   parameterization.
   \par
   This report describes the Cedar language. Except for chapter 2, it is
   written strictly in the style of a reference manual, not a
   tutorial. Furthermore, it describes the entire language, including a
   number of obsolete constructs and historical accidents. Hence it tells
   much more than you probably want to know. A summary of the safe language
   and comments throughout the manual suggest which constructs should be
   preferred for new programs.",
}



@Manual{Haskell98,
  title = 	 "Haskell 98 Language and Libraries:  The revised report",
  author = 	 "Simon {Peyton Jones}",
  year = 	 2002,
  note = 	 "\url{http://haskell.org/onlinereport/}",
}

@InProceedings{Meijer2007,
  author = 	 "Meijer, Erik",
  title = 	 "Confessions of a used programming language salesman:  Getting the masses hooked on {Haskell}",
  booktitle = OOPSLA2007companion,
  pages = 	 "677--694",
  year = 	 2007,
  address = 	 OOPSLA2007addr,
  month = 	 OOPSLA2007date,
  abstract =
   "For many years I had been fruitlessly trying to sell functional
   programming and Haskell to solve real world problems such as scripting
   and data-intensive three-tier distributed web applications. The lack of
   widespread adoption of Haskell is a real pity. Functional programming
   concepts are key to curing many of the headaches that plague the
   majority of programmers, who today are forced to use imperative
   languages. If the mountain won't come to Mohammed, Mohammed must go to
   the mountain, and so I left academia to join industry. Instead of trying
   to convince imperative programmers to forget everything they already
   know and learn something completely new, I decided to infuse existing
   imperative object-oriented programming languages with functional
   programming features. As a result, functional programming has finally
   reached the masses, except that it is called Visual Basic 9 instead of
   Haskell 98.",
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% End
%%%


% LocalWords: mernst InProceedings PoratBKM Porat Biberstein Koved foo lcianu
% LocalWords: Bilba Mendelson NEEDpages booktitle CASCON addr fixpoint const int
% LocalWords: SkoglundW Skoglund Tobias Wrigstad jun writeable Heffter consts
% LocalWords: caseModeOf TechReport MuellerPoetzsch ller Poetzsch nter INTERCOL
% LocalWords: Fernuniversit KnieselT Kniesel Theisen JAC spe followon Kernighan
% LocalWords: readonly BoylandNR readimmutable readnothing JAC's Gomes NEEDmonth
% LocalWords: subtyping Stoutamire Vaysman Klawitter Sather Sather's authorASCII
% LocalWords: Zendra Colnet PechtchanskiS Pechtchanski Vivek Sarkar GJ bytecode
% LocalWords: JavaGrande immutableField deepImmutableField Boyland App Bytecodes
% LocalWords: immutableParam deepImmutableParam deepImmutableLocal SAS bytecodes
% LocalWords: Retert generalisation formalised Duggan PolyJava pexp al atomicity
% LocalWords: Classname ptype iclass MiniJava Hashtable addElement SSI DietlM
% LocalWords: setElementAt TVars WangS Tiejun Agesen's downcasts SSA scrollable
% LocalWords: GagnonHM Etienne Gagnon Hendren Guillaume stackless Ole genericity
% LocalWords: Jimple Tiuryn Agesen IgarashiPW Atsushi Igarashi Wadler Dietl pdf
% LocalWords: Bracha Odersky FGJ MitchellP Plotkin typeable TOPLAS doi bibname
% LocalWords: issn CartwrightS NextGen IgarashiV Mirko Viroli MyersBL FTFJP ADT
% LocalWords: Liskov PolyJ vonDincklageD von Dincklage Amer Diwan SCCs ChinMM
% LocalWords: Ilwith generified SCC TR addAll HashMap cardelli Luca gj pos neg
% LocalWords: Wegner dec Misc java treemap buildFromSorted misc url Yu nonnull
% LocalWords: howpublished jsr OLDhowpublished JavaSoft Microsystems NEEDvolume
% LocalWords: bracha gjspec Gilad YuKS Dachuan Syme GiffordJLS FX sep Markstrum
% LocalWords: Jouvelot Lucassen MITLCS MITaddr LucassenG JouvelotG tes Cqual YY
% LocalWords: TalpinJ Talpin LICS InCollection NiNi Olderog Steffen De ints oct
% LocalWords: behaviour OxhojPS Oxh Jens Palsberg Schwartzbach Oxhoj NEEDnumber
% LocalWords: PlevyakC Plevyak Chien PalsbergS OhoriB Ohori Buneman NN FlattKF
% LocalWords: EifrigST Eifrig Valery Trifonov Milner SalcianuR Rinard untainted
% LocalWords: Alexandru Salcianu multithreaded PPOPP ParkG PLDI Jong peerObject
% LocalWords: ChoiGSSM Deok Choi Manish Vugranam Sreedhar Midkiff pldi mixins
% LocalWords: Naftaly FosterFFA hndrich Tachio Terauchi aiken Kodumal LNCS ESOP
% LocalWords: FlanaganQ Cormac Shaz Qadeer cmpd unsafeties aug TreeMap Bornat
% LocalWords: http foobar barfoo barfoobar foobarfoo DeanGC inline CHA Calcagno
% LocalWords: BaconS RTA TipP XTA FahndrichL Fahndrich nullness vtable O'Hearn
% LocalWords: structs AssertInit KLOC AntoniuSKNF Antoniu Steckler Rai Boyapati
% LocalWords: Shriram Neuwirth Felleisen XeLda ValleeRaiHSLGC Vall MLj Beebee
% LocalWords: Vijay Sundaresan Phong OMITpublisher AikenW Wimmers FPCA Lindskov
% LocalWords: isbn McAdamKB DeSutterTD Bjorn Sutter SiffCBKR Siff FSE Cristiano
% LocalWords: Satish Kunchithapadam upcast upcasts bitfields PARC cmu SIGACT rb
% LocalWords: Tichy PrecheltT james edu Lutz Prechelt TSE apr Gannon OMITeditor
% LocalWords: typeless supersededby NNSSSS SSSS datatypes datatype ie ClarkD OO
% LocalWords: GannonH Horning Los TorgersenPHEvdABG Mads Torgersen der ClarkeW
% LocalWords: Plesner Gafter wildcards EdwardsJT Emina Torlak monomorphically
% LocalWords: typechecking decompilation DietlMueller ArrayStoreException Zucca
% LocalWords: typechecker SIGACTSIGPLAN Drossopoulou PhdThesis Davide DietlDM
% LocalWords: ClarkeNP ClarkePN AnconaDDZ Ancona Ferruccio Damiani jul eneric
% LocalWords: updateable ChinMMP Expr CQual browsable Mordani ElsmanFA niverse
% LocalWords: Elsman YYYY MandelbaumWH Yitzhak Mandelbaum ICFP DeLineF ypes RC
% LocalWords: effectful typestate DeLine ShankarTFW Umesh Shankar Kunal Mandana
% LocalWords: Talwar USENIXSec VolpanoS Volpano TAPSOFT PalsbergO Jqual Vaziri
% LocalWords: Orbaek GreenfieldboyceF BirkaE templated qual qthis nov consing
% LocalWords: qreturn Gizmoball PratikakisSH Polyvios Pratikakis Spacco deline
% LocalWords: nonproxy JohnsonW YelickSPMLKHGGCA Yelick Semenzato SPMD ChalinJ
% LocalWords: Miyamoto Liblit Krishnamurthy Hilfinger Colella Palo Blay Rioux
% LocalWords: bydefault Chalin nullability BrachaOSW CardelliW Potanin ENCS CSE
% LocalWords: PotaninNCB SpoonS FlanaganFKWF Weirich Reengineering Dery ESC JDT
% LocalWords: RapicaultBDD Rapicault Mireille Fornarino BibersteinGP GC NPEs Yi
% LocalWords: Metadata Rajiv cartesian phane Ducasse Stephane Chlo gdb JDT's io
% LocalWords: PolishchukLS Polishchuk Schulze untypable exif malloc Jif Nully
% LocalWords: placeholders MyersL SOSP JFlow AskarovS Aslan Askarov ois JastAdd
% LocalWords: Sabelfeld ESORICS Riemannian rgen HicksAM Kiyan ACSAC LiZ Engelen
% LocalWords: Ahmadizadeh JPmail DBLP VolpanoSI PottierSimonet Simonet nullable
% LocalWords: Caml APPSEMII Peng Zdancewic CSFW Flowarrows MorrisettWCG CANAPA
% LocalWords: Crary Glew TAL CPS MorrisettCGGSSWWZ TALx WCSSS JCSS rard Fulara
% LocalWords: FieldNotFoundException Huet ErwigB Erwig PADL SMcC Fong FindBugs
% LocalWords: classloader ChinM CLU Ittai Balaban Fuhrer SteimannMM Mei PPPJ rc
% LocalWords: Friedrich Steimann ner Meissner Hongwei McKinna ECMA CLR IntelliJ
% LocalWords: titleASCII HejlsbergWG Hejlsberg Wiltamuth Golde Cazzola Inferrer
% LocalWords: CazzolaCC Cisternino Markus Matthai Philipose Eggers PEPM Ekman
% LocalWords: EP TEPH WFJ FJ jan CODEN ATPSDT bibdate bibsource ack SEM Hedin
% LocalWords: nhfb BalabanTF citeable Longman Hartmann Amme Ronne WCET Cielecki
% LocalWords: Raimund Kirner Puschner Euromicro Palma Pini Massimo Linz Lund rn
% LocalWords: Eichberg Mezini Middleware Gschwind Mascolo HarmonK Shan Nijmegen
% LocalWords: Klefstad WPDRTS HuangZS Zook Yannis Smaragdakis cJ AOSD Jakubczyk
% LocalWords: ifdef JCF Resizeable ifdefs co DeleteOnly Morphing MJ typestates
% LocalWords: UnsupportedOperationException morphing ArgClass Jancewicz YuP Abi
% LocalWords: DietlDrossopoulouMueller Hovemeyer BoyapatiLR AndreaCGNVZ Andreae
% LocalWords: Coady Vitek Tian Zhao BoyapatiSBR BanerjeeN Anindya JavaD JavaCOP
% LocalWords: Banerjee Naumann AbiAntounA Marwan Antoun Aldrich CMUSCS NOpages
% LocalWords: VaziriTFD EnglerCHCC ISRI CMUaddr AliasJava IWACO annot MJ's LFP
% LocalWords: param arrayParam JavaCC HillClimber AndreaeNMM TorgersenEPH Goetz
% LocalWords: antipattern feb LernerFGC STL atsign ChalinJK Karabotsos Maciej
% LocalWords: CieleckiFJJ drzej Krzysztof ukasz Jedrzej Lukasz NonNull ArtziKGE
% LocalWords: HovemeyerSP nully MultiJava CZT JQual enum JNI greek CFL enums un
% LocalWords:  lang GuoPME applet Jacek Chrzaszcz Aleksy Kami Kaminski Torbj JN
% LocalWords:  Torbjorn rel Rewritable EkmanH Gorel LOC vol util NotNull Arnout
% LocalWords:  myField MastersThesis usesDaikon Engelen's arnouten bzzt INAPA
% LocalWords:  PossiblyNull JastAdd's init nowarn pragma annotatable fixups NPE
% LocalWords:  microbenchmarks deprioritize deprioritized CheckForNull MaleP NY
% LocalWords:  formalise mySet subpackages vars jbidwatcher ReadOnly Ahe aka CC
% LocalWords:  Ershov BESM Monocopy MarinovO Marinov O'Callahan OEP SpecJVM tre
% LocalWords:  ZendraC IWAOOS OMITvolume OMITseries Fateman Macsyma FilliatreC
% LocalWords:  Christophe Filli Sylvain Conchon Filliatre Ocaml Spitzen KaplanT
% LocalWords:  Acar Blelloch Deques Haim Tarjan Montoreano Nanokernel Artho Liu
% LocalWords:  Subsetting Cyrille BurdyP Burdy Mariela BCSL MillsteinJavaCOP Gr
% LocalWords:  NystromCM Nystrom Clarkson LiuM Milanova Guangyu Mahmut Kandemir
% LocalWords:  KirnerP BurdyHP BML aiT Marieke Huisman OOPSLA PFD Cronembold BP
% LocalWords:  HaackPSS Haack Sch codebases Darko hashtable SIGSAM memoization
% LocalWords:  Kaplan JAVACAM Greenfieldboyce JQual's Millstein subsumption gcc
% LocalWords:  Arvind JML's Rustan Leino SAVCBS chalin Echalin HovemeyerP Jlint
% LocalWords:  JLint filestamp ChecKer README MalePPD Dymnikov nonnullness ISP
% LocalWords:  javacc instanceof Spoto Fausto CousotC HubertJP Spoto's Cousot
% LocalWords:  Radhia Pichardie FMOODS Pichardie's BartheBCGHLPR Barthe goire
% LocalWords:  Lanet Requet FMCO javac MarkstrumMEM Esquivel CSD JavaChecker VM
% LocalWords:  TermWare monomorphic Krishnamurthi Birka ChongM Chong CSF AOP
% LocalWords:  MyersSZ Declassificaiton SabelfeldS EichbergM pointcut FASE HOL
% LocalWords:  middleware HartmannAvRF ENTCS SafeTSA GrantMPCE coden Hindley
% LocalWords:  Fagan WrightAndr Henglein Tobin Hochstadt typecase discriminator
% LocalWords:  PLT Redex BRL FME Araki Gnesi Mandrioli PSurl gpt csfw D'Argenio
% LocalWords:  Rezk cardis Applets gmg sefm acc Julien FTfJP BBCGHLPR pdfurl
% LocalWords:  KondohO Goh Kondoh Tamiya Onodera NeculaMRW Necula McPeak Rahul
% LocalWords:  Westley Weimer CIL OCaml
