% Software engineering bibliography


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Maintenance
%%%



@Article{Putnam78,
  author = 	 "Lawrence H. Putnam",
  title = 	 "A general empirical solution to the macro software sizing
                  and estimating problem",
  journal = 	 TSE,
  year = 	 1978,
  volume =	 4,
  number =	 4,
  pages =	 "345--361",
  month =	 jul
}

@Article{BalzerCG83,
  author = 	 "R. Balzer and T. E. Cheatham, Jr. and C. Green",
  title = 	 "Software technology in the 1990's: Using a new paradigm",
  journal = 	 "Computer",
  year = 	 1983,
  volume =	 16,
  number =	 11,
  pages =	 "39-45",
  month =	 nov
}

@Article{Boehm87:top10,
  author = 	 "Barry W. Boehm",
  title = 	 "Industrial software metrics top 10 list",
  journal = 	 "IEEE Software",
  year = 	 1987,
  volume =	 4,
  number =	 5,
  pages =	 "84--85",
  month =	 sep
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Refactoring
%%%

@TechReport{Griswold91,
  author = 	 "William G. Griswold",
  title = 	 "Program Restructuring To Aid Software Maintenance",
  institution =  UWCSE,
  year = 	 1991,
  number =	 "91-08-04",
  address =	 UWCSEaddr,
  month =	 aug,
  note =	 "PhD dissertation"
}

@TechReport{Opdyke92,
  author = 	 "W. F. Opdyke",
  title = 	 "Refactoring: A Program Restructuring Aid in Designing
                  Object-Oriented Applications Frameworks",
  institution =  "University of Illinois at Urbana-Champaign, Dept. of Computer Science",
  year = 	 1992,
  number =	 1759,
  note =	 "PhD dissertation"
}



@book{Fowler2000,
 title = {Refactoring: Improving the Design of Existing Code},
 author = {Martin Fowler},
 publisher = {Addison-Wesley},
 year = {2000}
}



@InProceedings{Parr94,
  author = 	 "Terence J. Parr",
  title = 	 "An overview of {SORCERER}: A simple tree-parser generator",
  booktitle =	 CC94,
  NEEDpages = 	 "",
  year =	 1994,
  address =	 CC94addr,
  month = 	 CC94date
}


@Article{MensT2004,
  author = 	 "Tom Mens and Tom Tourw{\'e}",
  authorASCII =  "Tom Mens and Tom Tourwe",
  title = 	 "A survey of software refactoring",
  journal = 	 TSE,
  year = 	 2004,
  volume =	 30,
  number =	 2,
  pages =	 "126--139",
  month =	 feb
}



@InProceedings{StreckenbachS2004,
  author = 	 "Mirko Streckenbach and Gregor Snelting",
  title = 	 "Refactoring class hierarchies with {KABA}",
  booktitle =	 OOPSLA2004,
  pages = 	 "315--330",
  year =	 2004,
  address =	 OOPSLA2004addr,
  month =	 OOPSLA2004date
}


@InProceedings{HenkelD2005,
  author = 	 "Johannes Henkel and Amer Diwan",
  title = 	 "CatchUp!  Capturing and replaying refactorings to support
                  {API} evolution",
  booktitle =	 ICSE2005,
  pages = 	 "274--283",
  year =	 2005,
  address =	 ICSE2005addr,
  month =	 ICSE2005date,
  abstract =
   "Library developers who have to evolve a library to accommodate changing
    requirements often face a dilemma: Either they implement a clean, efficient
    solution but risk breaking client code, or they maintain compatibility with
    client code, but pay with increased design complexity and thus higher
    maintenance costs over time.
    \par
    We address this dilemma by presenting a lightweight approach for evolving
    application programming interfaces (APIs), which does not depend on version
    control or configuration management systems. Instead, we capture API
    actions as a developer evolves an API. Users of the API can then replay the
    refactorings to bring their client software components up to date.
    \par
    We present CatchUp!, an implementation of our approach that captures and
    replays refactoring actions within an integrated development environment
    semi-automatically. Our experiments suggest that our approach could be
    valuable in practice.",
}



@InProceedings{MurphyHillPB2009,
  author = 	 "Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.",
  title = 	 "How we refactor, and how we know it",
  booktitle = ICSE2009,
  pages = 	 "287--297",
  year = 	 2009,
  address = 	 ICSE2009addr,
  month = 	 ICSE2009date,
  abstract =
   "Much of what we know about how programmers refactor in the wild is
    based on studies that examine just a few software projects. Researchers
    have rarely taken the time to replicate these studies in other contexts
    or to examine the assumptions on which they are based. To help put
    refactoring research on a sound scientific basis, we draw conclusions
    using four data sets spanning more than 13 000 developers, 240 000
    tool-assisted refactorings, 2500 developer hours, and 3400 version
    control commits. Using these data, we cast doubt on several previously
    stated assumptions about how programmers refactor, while validating
    others. For example, we find that programmers frequently do not indicate
    refactoring activity in commit logs, which contradicts assumptions made
    by several previous researchers. In contrast, we were able to confirm
    the assumption that programmers do frequently intersperse refactoring
    with other program changes. By confirming assumptions and replicating
    studies made by other researchers, we can have greater confidence that
    those researchers' conclusions are generalizable.",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous
%%% 


@Misc{Borland2004,
  author =	 "Borland",
  title =	 "Making Development A Team Sport",
  howpublished = "demo at JavaOne",
  month =	 jun # "~29,",
  year =	 2004
}



@InProceedings{ChowN96,
  author = 	 "Kingsum Chow and David Notkin",
  title = 	 "Semi-automatic update of applications in response to
                  library changes",
  booktitle =	 ICSM96,
  pages =	 "259--368",
  year =	 1996,
  address =	 ICSM96addr,
  month =	 ICSM96date
}



@InProceedings{MandelinXBK2005,
  author = 	 "David Mandelin and Lin Xu and Rastislav Bod{\'\i}k and
                  Doug Kimmelman",
  authorSEARCHABLE = "Rastislav Bodik",
  title = 	 "Jungloid mining: Helping to navigate the {API} jungle",
  booktitle =	 PLDI2005,
  pages = 	 "48--61",
  year =	 2005,
  address =	 PLDI2005addr,
  month =	 PLDI2005date,
  abstract =
   "Reuse of existing code from class libraries and frameworks is often
    difficult because APIs are complex and the client code required to use the
    APIs can be hard to write. We observed that a common scenario is that the
    programmer knows what type of object he needs, but does not know how to
    write the code to get the object.
    \par
    In order to help programmers write API client code more easily, we
    developed techniques for synthesizing jungloid code fragments automatically
    given a simple query that describes that desired code in terms of input and
    output types. A jungloid is simply a unary expression; jungloids are
    simple, enabling synthesis, but are also versatile, covering many coding
    problems, and composable, combining to form more complex code fragments. We
    synthesize jungloids using both API method signatures and jungloids mined
    from a corpus of sample client programs.
    \par
    We implemented a tool, Prospector, based on these techniques. Prospector is
    integrated with the Eclipse IDE code assistance feature, and it infers
    queries from context so there is no need for the programmer to write
    queries. We tested Prospector on a set of real programming problems
    involving APIs; Prospector found the desired solution for 18 of 20
    problems.We also evaluated Prospector in a user study, finding that
    programmers solved programming problems more quickly and with more reuse
    when using Prospector than without Prospector."
}




@InProceedings{RutarAF2004,
  author = 	 "Nick Rutar and Christian B. Almazan and Jeffrey S. Foster",
  title = 	 "A comparison of bug finding tools for {Java}",
  booktitle =	 ISSRE2004,
  pages =	 "245--256",
  year =	 2004,
  address =	 ISSRE2004addr,
  month =	 ISSRE2004date,
  abstract =
   "Bugs in software are costly and difficult to find and fix. In recent years,
    many tools and techniques have been developed for automatically finding
    bugs by analyzing source code or intermediate code statically (at compile
    time). Different tools and techniques have different tradeoffs, but the
    practical impact of these tradeoffs is not well understood. In this paper,
    we apply five bug finding tools, specifically Bandera, ESC/Java 2,
    FindBugs, JLint, and PMD, to a variety of Java programs. By using a variety
    of tools, we are able to cross-check their bug reports and warnings. Our
    experimental results show that none of the tools strictly subsumes another,
    and indeed the tools often find non-overlapping bugs. We discuss the
    techniques each of the tools is based on, and we suggest how particular
    techniques affect the output of the tools. Finally, we propose a meta-tool
    that combines the output of the tools together, looking for particular
    lines of code, methods, and classes that many tools warn about.",
}




@InProceedings{KimSNM2005,
  author = 	 "Miryung Kim and Vibha Sazawal and David Notkin 
                  and Gail C. Murphy",
  title = 	 "An empirical study of code clone genealogies",
  booktitle =	 FSE2005,
  pages =	 "187--196",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "It has been broadly assumed that code clones are inherently bad and that
    eliminating clones by refactoring would solve the problems of code
    clones. To investigate the validity of this assumption, we developed a
    formal definition of clone evolution and built a clone genealogy tool that
    automatically extracts the history of code clones from a source code
    repository. Using our tool we extracted clone genealogy information for two
    Java open source projects and analyzed their evolution.
    \par
    Our study contradicts some conventional wisdom about clones. In particular,
    refactoring may not always improve software with respect to clones for two
    reasons. First, many code clones exist in the system for only a short time;
    extensive refactoring of such short-lived clones may not be worthwhile if
    they are likely diverge from one another very soon. Second, many clones,
    especially long-lived clones that have changed consistently with other
    elements in the same group, are not easily refactorable due to programming
    language limitations. These insights show that refactoring will not help in
    dealing with some types of clones and open up opportunities for
    complementary clone maintenance tools that target these other classes of
    clones.",
}


@Book{GhezziJM91,
  author =       "Carlo Ghezzi and Mehdi Jazayeri and Dino Mandrioli",
  title =        "Fundamentals of Software Engineering",
  edition =      "1",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year =         "1991",
  ISBN =         "0-13-818204-3",
}


@Book{Lamb88,
  author =	 "David Alex Lamb",
  title = 	 "Software Engineering:  Planning for Change",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year = 	 1988
}

@Book{Sommerville:1996a,
  author =       "Ian Sommerville",
  title =        "Software Engineering",
  publisher =    "Addison-Wesley",
  year =         "1996",
  address =      "Wokingham, England",
  edition =      "Fifth",
}

@Book{Pressman92,
  author =	 "Roger S. Pressman",
  title = 	 "Software Engineering:  A Practitioner's Approach",
  publisher = 	 "McGraw-Hill",
  year = 	 1992,
  address =	 "New York",
  edition =	 "Third"
}




@InProceedings{VandevoordeG94,
  author =       "Mark T. Vandevoorde and John V. Guttag",
  title =        "Using specialized procedures and specification-based analysis
                  to reduce the runtime costs of modularity",
  booktitle =    "Symposium on the Foundations of Software Engineering",
  year =         1994,
  month =        dec
}

@InProceedings{KremenekAYE2004,
  author = 	 "Ted Kremenek and Ken Ashcraft and Junfeng Yang and Dawson Engler",
  title = 	 "Correlation exploitation in error ranking",
  booktitle =    FSE2004,
  pages = 	 "83--93",
  year =	 2004,
  address =	 FSE2004addr,
  month =	 FSE2004date
}



@InProceedings{BasitRJ2005,
  author = 	 "Hamid Abdul Basit and Damith C. Rajapakse and Stan Jarzabek",
  title = 	 "Beyond templates: A study of clones in the {STL} and some
                  general implications",
  booktitle =	 ICSE2005,
  pages = 	 "451--459",
  year =	 2005,
  address =	 ICSE2005addr,
  month =	 ICSE2005date,
  abstract =
   "Templates (or generics) help us write compact, generic code, which aids
    both reuse and maintenance. The STL is a powerful example of how templates
    help achieve these goals. Still, our study of the STL revealed substantial,
    and in our opinion, counter-productive repetitions (so-called clones)
    across groups of similar class or function templates. Clones occurred, as
    variations across these similar program structures were irregular and could
    not be unified by suitable template parameters in a natural way. We
    encountered similar problems in other class libraries as well as in
    application programs, written in a range of programming languages. In the
    paper, we present quantitative and qualitative results from our study. We
    argue that the difficulties we encountered affect programs in general. We
    present a solution that can treat such template-unfriendly cases of
    redundancies at the meta-level, complementing and extending the power of
    language features, such as templates, in areas of generic programming.",
}



@InProceedings{BasitJ2005,
  author = 	 "Hamid Abdul Basit and Stan Jarzabek",
  title = 	 "Detecting higher-level similarity patterns in programs",
  booktitle =	 FSE2005,
  pages =	 "156--165",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "Cloning in software systems is known to create problems during software
    maintenance. Several techniques have been proposed to detect the same or
    similar code fragments in software, so-called simple clones. While the
    knowledge of simple clones is useful, detecting design-level similarities
    in software could ease maintenance even further, and also help us identify
    reuse opportunities. We observed that recurring patterns of simple clones -
    so-called structural clones - often indicate the presence of interesting
    design-level similarities. An example would be patterns of collaborating
    classes or components. Finding structural clones that signify potentially
    useful design information requires efficient techniques to analyze the bulk
    of simple clone data and making non-trivial inferences based on the
    abstracted information. In this paper, we describe a practical solution to
    the problem of detecting some basic, but useful, types of design-level
    similarities such as groups of highly similar classes or files. First, we
    detect simple clones by applying conventional token-based techniques. Then
    we find the patterns of co-occurring clones in different files using the
    Frequent Itemset Mining (FIM) technique. Finally, we perform file
    clustering to detect those clusters of highly similar files that are likely
    to contribute to a design-level similarity pattern. The novelty of our
    approach is application of data mining techniques to detect design level
    similarities. Experiments confirmed that our method finds many useful
    structural clones and scales up to big programs. The paper describes our
    method for structural clone detection, a prototype tool called Clone Miner
    that implements the method and experimental results."
}






@InProceedings{LivshitsZ2005,
  author = 	 "Benjamin Livshits and Thomas Zimmermann",
  title = 	 "{DynaMine}: Finding common error patterns by mining
                  software revision histories",
  booktitle =	 FSE2005,
  pages =	 "296--305",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "A great deal of attention has lately been given to addressing software
    bugs such as errors in operating system drivers or security bugs. However,
    there are many other lesser known errors specific to individual
    applications or APIs and these violations of application-specific coding
    rules are responsible for a multitude of errors. In this paper we propose
    DynaMine, a tool that analyzes source code check-ins to find highly
    correlated method calls as well as common bug fixes in order to
    automatically discover application-specific coding patterns. Potential
    patterns discovered through mining are passed to a dynamic analysis tool
    for validation; finally, the results of dynamic analysis are presented to
    the user.
    \par
    The combination of revision history mining and dynamic analysis techniques
    leveraged in DynaMine proves effective for both discovering new
    application-specific patterns and for finding errors when applied to very
    large applications with many man-years of development and debugging effort
    behind them. We have analyzed Eclipse and jEdit, two widely-used, mature,
    highly extensible applications consisting of more than 3,600,000 lines of
    code combined. By mining revision histories, we have discovered 56
    previously unknown, highly application-specific patterns. Out of these, 21
    were dynamically confirmed as very likely valid patterns and a total of 263
    pattern violations were found.",
}



@InProceedings{SullivanGSCSTR2005,
  author = 	 "Kevin Sullivan and William G. Griswold and Yuanyuan Song
                  and Yuanfang Cai and Macneil Shonle and Nishit Tewari and
                  Hridesh Rajan",
  title = 	 "Information hiding interfaces for aspect-oriented design",
  booktitle =	 FSE2005,
  pages =	 "166--175",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date
}




@InProceedings{Przybylek2011,
  author = 	 "Adam Przyby{\l}ek",
  authorASCII =  "Adam Przyby≈Çek, Adam Przybylek",
  title = 	 "Where the truth lies: {AOP} and its impact on software modularity",
  booktitle = FASE2011,
  NEEDpages = 	 "*",
  year = 	 2011,
  address = 	 FASE2011addr,
  month = 	 FASE2011date,
  abstract =
   "Modularity is the single attribute of software that allows a program to be
    intellectually manageable [29]. The recipe for modularizing is to define a
    narrow interface, hide an implementation detail, keep low coupling and high
    cohesion. Over a decade ago, aspect-oriented programming (AOP) was proposed
    in the literature to ``modularize the un-modularizable'' [24]. Since then,
    aspect-oriented languages have been providing new abstraction and
    composition mechanisms to deal with concerns that could not be modularized
    because of the limited abstractions of the underlying programming
    language. This paper is a continuation of our earlier work [32] and further
    investigates AO software with regard to coupling and cohesion. We compare
    two versions (Java and AspectJ) of ten applications to review AOP within
    the context of software modularity. It turns out that the claim that ``the
    software built in AOP is more modular than the software built in OOP'' is a
    myth.",
}







@InProceedings{LiZ2005,
  author = 	 "Zhenmin Li and Yuanyuan Zhou",
  title = 	 "PR-Miner: automatically extracting implicit programming
                  rules and detecting violations in large software code",
  booktitle =	 FSE2005,
  pages =	 "306--315",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "Programs usually follow many \emph{implicit} programming rules, most of
    which are too tedious to be documented by programmers. When these rules are
    violated by programmers who are unaware of or forget about them, defects
    can be easily introduced. Therefore, it is highly desirable to have tools
    to automatically extract such rules and also to automatically detect
    violations. Previous work in this direction focuses on simple function-pair
    based programming rules and additionally requires programmers to provide
    rule templates.
    \par
    This paper proposes a \emph{general} method called PR-Miner that uses a
    data mining technique called frequent itemset mining to efficiently extract
    implicit programming rules from large software code written in an
    industrial programming language such as C, \emph{requiring little effort
    from programmers and no prior knowledge of the software}. Benefiting from
    frequent itemset mining, PR-Miner can extract programming rules in general
    forms (without being constrained by any fixed rule templates) that can
    contain multiple program elements of various types such as functions,
    variables and data types. In addition, we also propose an efficient
    algorithm to automatically detect violations to the extracted programming
    rules, which are strong indications of bugs.
    \par
    Our evaluation with large software code, including Linux, PostgreSQL Server
    and the Apache HTTP Server, with 84K--3M lines of code each, shows that
    PR-Miner can efficiently extract thousands of general programming rules and
    detect violations within 2 minutes. Moreover, PR-Miner has detected many
    violations to the extracted rules. Among the top 60 violations reported by
    PR-Miner, 16 have been confirmed as bugs in the \emph{latest version} of
    Linux, 6 in PostgreSQL and 1 in Apache. Most of them violate complex
    programming rules that contain more than 2 elements and are thereby
    difficult for previous tools to detect. We reported these bugs and they are
    currently being fixed by developers.",
}


@Book{Simon96,
  author = 	 "Herbert A. Simon",
  title = 	 "The Sciences of the Artificial",
  publisher = 	 "MIT Press",
  year = 	 1996,
  edition = 	 "Third",
}

@Book{Braude2003,
  author = 	 "Eric J. Braude",
  title = 	 "Software Design: From Programming to Architecture",
  publisher = 	 "Wiley",
  year = 	 2003,
}

@Book{Budgen2003,
  author = 	 "Software Design",
  title = 	 "David Budgen",
  publisher = 	 "Addison-Wesley",
  year = 	 2003,
}

@Book{Winograd1996,
  author = 	 "Terry Winograd",
  title = 	 "Bringing Design to Software",
  publisher = 	 "Addison-Wesley",
  year = 	 1996
}

@Book{CoplienS1995,
  author = 	 "James O. Coplien and Douglas C. Schmidt",
  title = 	 "Pattern Languages of Program Design",
  publisher = 	 "Addison-Wesley",
  year = 	 1995,
}

@Book{FelleisenFFK2001,
  author = 	 "Matthias Felleisen and Robert Bruce Findler and Matthew
                  Flatt and Shriram Krishnamurthi",
  title = 	 "How to Design Programs: An Introduction to Programming and Computing",
  publisher = 	 "MIT Press",
  year = 	 2001
}

@Book{CohoonD2005,
  author = 	 "James P. Cohoon and Jack W. Davidson ",
  title = 	 "Java 5.0 Program Design",
  publisher = 	 "McGraw-Hill",
  year = 	 2005,
}



@InProceedings{KuhnGG2005,
  author = 	 "Adrian Kuhn and Orla Greevy and Tudor G{\^\i}rba",
  title = 	 "Applying semantic analysis to feature execution traces",
  booktitle =    PCODA2005,
  pages = 	 "48--53",
  year = 	 2005,
  address = 	 PCODA2005addr,
  month = 	 PCODA2005date,
  abstract =
   "Recently there has been a revival of interest in feature
    analysis of software systems. Approaches to feature location
    have used a wide range of techniques such as dynamic
    analysis, static analysis, information retrieval and formal
    concept analysis. In this paper we introduce a novel approach
    to analyze the execution traces of features using Latent
    Semantic Indexing (LSI). Our goal is twofold. On the
    one hand we detect similarities between features based on
    the content of their traces, and on the other hand we categorize
    classes based on the frequency of the outgoing invocations
    involved in the traces. We apply our approach on
    two case studies and we discuss its benefits and drawbacks.",
}



@Article{EisenbarthKS2003,
  author = 	 "T. Eisenbarth and R. Koschke and D. Simon",
  title = 	 "Locating Features in Source Code",
  journal = 	 computer,
  year = 	 2003,
  volume = 	 29,
  number = 	 3,
  pages = 	 "210--224",
  month = 	 mar,
}


@InProceedings{GreevyD2005,
  author = 	 "O. Greevy and St{\'e}phane Ducasse",
  title = 	 "Correlating features and code using a compact two-sided
                  trace analysis approach",
  booktitle = CMSR2005,
  pages = 	 "314--323",
  year = 	 2005,
  address = 	 CMSR2005addr,
  month = 	 CMSR2005date,
}


@InProceedings{GreevyDG2005,
  author = 	 "Orla Greevy and St{\'e}phane Ducasse and Tudor G{\^\i}rba",
  title = 	 "Analyzing feature traces to incorporate the semantics of
		  change in software evolution analysis",
  booktitle = ICSM2005,
  pages = 	 "347--356",
  year = 	 2005,
  address = 	 ICSM2005addr,
  month = 	 ICSM2005date,
}


@Article{WongGH2000,
  author = 	 "W. E. Wong and S. S. Gokhale and J. R. Horgan",
  title = 	 "Quantifying the closeness between program components and features",
  journal = 	 j-systems-and-software,
  year = 	 2000,
  volume = 	 54,
  number = 	 2,
  pages = 	 "87--98",
  month = 	 oct,
}


@InProceedings{ZaidmanCDP2005,
  author = 	 "Andy Zaidman and Toon Calders and Serge Demeyer and Jan Paredaens",
  title = 	 "Applying Webmining Techniques to Execution Traces to
                  Support the Program Comprehension Process",
  booktitle =    CMSR2005,
  pages = 	 "134--142",
  year = 	 2005,
  address = 	 CMSR2005addr,
  month = 	 CMSR2005date,
  abstract =
   "Well-designed object-oriented programs typically consist
    of a few key classes that work tightly together to provide
    the bulk of the functionality. As such, these key classes are
    excellent starting points for the program comprehension
    process. We propose a technique that uses webmining
    principles on execution traces to discover these important
    and tightly interacting classes. Based on two medium-scale
    case studies --- Apache Ant and Jakarta JMeter --- and
    detailed architectural information from its developers, we
    show that our heuristic does in fact find a sizable number
    of the classes deemed important by the developers.",
}


@InProceedings{HaRDRCRW2007,
  author = 	 "Jungwoo Ha and Christopher J. Rossbach and Jason V. Davis and Indrajit Roy and David L. Chen and Hany E. Ramadan and Emmett Witchel",
  title = 	 "Improved error reporting for software that uses black-box components",
  booktitle = PLDI2007,
  pages = 	 "101--111",
  year = 	 2007,
  address = 	 PLDI2007addr,
  month = 	 PLDI2007date,
}



@InProceedings{ApiwattanapongOH2004,
  author = 	 "Taweesup Apiwattanapong and Alessandro Orso and Mary Jean Harrold",
  title = 	 "A differencing algorithm for object-oriented programs",
  booktitle = ASE2004,
  pages = 	 "2--13",
  year = 	 2004,
  address = 	 ASE2004addr,
  month = 	 ASE2004date,
  abstract =
   "During software evolution, information about changes between different
    versions of a program is useful for a number of software engineering
    tasks. For many of these tasks, a purely syntactic differencing may not
    provide enough information for the task to be performed effectively. This
    problem is especially relevant in the case of object-oriented software, for
    which a syntactic change can have subtle and unforeseen effects. In this
    paper, we present a technique for comparing object-oriented programs that
    identifies both differences and correspondences between two versions of a
    program. The technique is based on a representation that handles
    object-oriented features and, thus, can capture the behavior of
    object-oriented programs. We also present JDIFF, a tool that implements the
    technique for Java programs, and empirical results that show the efficiency
    and effectiveness of the technique on a real program.",
  supersededby = "ApiwattanapongOH2007",
}


@Article{ApiwattanapongOH2007,
  author = 	 "Taweesup Apiwattanapong and Alessandro Orso and Mary Jean Harrold",
  title = 	 "{JD}iff: A differencing technique and tool for object-oriented programs",
  journal = 	 ASEjournal,
  year = 	 2007,
  volume = 	 14,
  month =        mar,
  pages = 	 "3--36",
  abstract =
   "During software evolution, information about changes between different
    versions of a program is useful for a number of software engineering
    tasks. For example, configuration-management systems can use change
    information to assess possible conflicts among updates from different
    users. For another example, in regression testing, knowledge about which
    parts of a program are unchanged can help in identifying test cases that
    need not be rerun. For many of these tasks, a purely syntactic differencing
    may not provide enough information for the task to be performed
    effectively.  This problem is especially relevant in the case of
    object-oriented software, for which a syntactic change can have subtle and
    unforeseen effects. In this paper, we present a technique for comparing
    object-oriented programs that identifies both differences and
    correspondences between two versions of a program. The technique is based
    on a representation that handles object-oriented features and, thus, can
    capture the behavior of object-oriented programs.We also present JDiff, a
    tool that implements the technique for Java programs. Finally, we present
    the results of four empirical studies, performed on many versions of two
    medium-sized subjects, that show the efficiency and effectiveness of the
    technique when used on real programs.",
  usesDaikonAsTestSubject = 1,
  downloads = "http://dx.doi.org/10.1007/s10515-006-0002-0 DOI",
}


@InProceedings{XuRTQ2007,
  author = 	 "Guoqing Xu and Atanas Rountev and Yan Tang and Feng Qin",
  title = 	 "Efficient checkpointing of {Java} software using context-sensitive capture and replay",
  booktitle = FSE2007,
  pages = 	 "85--94",
  year = 	 2007,
  address = 	 FSE2007addr,
  month = 	 FSE2007date,
}



@InProceedings{DwyerKE2007,
  author = 	 "Matthew B. Dwyer and Alex Kinneer and Sebastian Elbaum",
  title = 	 "Adaptive Online Program Analysis",
  booktitle = ICSE2007,
  pages = 	 "220--229",
  year = 	 2007,
  address = 	 ICSE2007addr,
  month = 	 ICSE2007date,
}







@InProceedings{KoM2008,
  author = 	 "Andrew J. Ko and Brad A. Myers",
  title = 	 "Debugging reinvented: Asking and answering why and why not questions about program behavior",
  booktitle = ICSE2008,
  pages = 	 "301--310",
  year = 	 2008,
  address = 	 ICSE2008addr,
  month = 	 ICSE2008date,
}





@InProceedings{JonesH2005,
  author = 	 "James A. Jones and Mary Jean Harrold",
  title = 	 "Empirical evaluation of the {Tarantula} automatic fault-localization technique",
  booktitle = ASE2005,
  pages = 	 "273--282",
  year = 	 2005,
  address = 	 ASE2005addr,
  month = 	 ASE2005date,
}






@Book{IEEE-610.12-1990,
  editor = 	 "Jane Radatz",
  title = 	 "IEEE Std 610.12-1990 IEEE Standard Glossary of Software Engineering Terminology",
  publisher = 	 "IEEE Computer Society",
  year = 	 1990,
  month = 	 sep # "~28,",
  abstract =
   "Describes the IEEE Std 610.12-1990, IEEE standard glossary of software
   engineering terminology, which identifies terms currently in use in the
   field of software engineering. Standard definitions for those terms are
   established.",
}


@InProceedings{Cook2009,
  author = 	 "Cook, William R.",
  title = 	 "On understanding data abstraction, revisited",
  booktitle = OOPSLA2009companion,
  pages = 	 "557--572",
  year = 	 2009,
  address = 	 OOPSLA2009,
  month = 	 OOPSLA2009date,
}



@Book{Brooks1975,
  author = 	 "Brooks, Jr., Frederick P.",
  title = 	 "The Mythical Man-Month: Essays on Software Engineering",
  publisher = 	 "Addison-Wesley",
  year = 	 1975,
  address = {Boston, MA, USA},
  isbn = {0201006502},
}



@InProceedings{JeongKZ2009,
  author = 	 "Jeong, Gaeul and Kim, Sunghun and Zimmermann, Thomas",
  title = 	 "Improving bug triage with bug tossing graphs",
  booktitle = FSE2009,
  pages = 	 "111--120",
  year = 	 2009,
  address = 	 FSE2009addr,
  month = 	 FSE2009date,
}


@Article{WalradS2002,
  author = 	 "Walrad, Chuck and Strom, Darrel",
  title = 	 "The Importance of Branching Models in {SCM}",
  journal = 	 "Computer",
  year = 	 2002,
  volume = 	 35,
  number = 	 9,
  pages = 	 "31--38",
  month = 	 sep,
}

@InProceedings{BallKPS97,
  author = 	 "Thomas Ball and Jung-Min Kim and Adam A. Porter and Harvey P. Siy",
  title = 	 "If Your Version Control System Could Talk \ldots",
  booktitle = "ICSE '97 Workshop on Process Modelling and Empirical Studies of Software Engineering",
  NEEDpages = 	 "*",
  year = 	 1997,
  address = 	 ICSE97addr,
  NEEDmonth = 	 "*",
}


@InProceedings{NagappanBZ2006,
  author = 	 "Nagappan, Nachiappan and Ball, Thomas and Zeller, Andreas",
  title = 	 "Mining metrics to predict component failures",
  booktitle = ICSE2006,
  pages = 	 "452--461",
  year = 	 2006,
  address = 	 ICSE2006addr,
  month = 	 ICSE2006date,
}




@Article{Rochkind75,
  author = 	 "Marc J. Rochkind",
  title = 	 "Mining metrics to predict component failures",
  journal = 	 IEEETSE,
  year = 	 1975,
  volume = 	 1,
  number = 	 4,
  pages = 	 "364-370",
  NEEDmonth = 	 "*",
}


@InProceedings{BaconCPR2009,
  author = 	 "Bacon, David F. and Chen, Yiling and Parkes, David and Rao, Malvika",
  title = 	 "A market-based approach to software evolution",
  booktitle = OOPSLA2009companion,
  pages = 	 "973--980",
  year = 	 2009,
  address = 	 OOPSLA2009addr,
  month = 	 OOPSLA2009date,
  doi = {http://doi.acm.org/10.1145/1639950.1640066},
}

@Article{Sakthivel2007,
  author = 	 "Sakthivel, S.",
  title = 	 "Managing risk in offshore systems development",
  journal = 	 CACM,
  year = 	 2007,
  volume = 	 50,
  number = 	 4,
  pages = 	 "69--75",
  month = 	 apr,
  doi = {http://doi.acm.org/10.1145/1232743.1232750},
}


@InProceedings{FritzM2010,
  author = 	 "Fritz, Thomas and Murphy, Gail C.",
  title = 	 "Using information fragments to answer the questions developers ask",
  booktitle = ICSE2010,
  pages = 	 "175--184",
  year = 	 2010,
  address = 	 ICSE2010addr,
  month = 	 ICSE2010date,
}






@Article{Norman90,
  author = 	 "Donald A. Norman",
  title = 	 "The ``Problem'' with automation: Inappropriate feedback and interaction, not ``over-automation''",
  journal = 	 PTRSLB,
  year = 	 1990,
  volume = 	 327,
  number = 	 1241,
  pages = 	 "585--593",
}




@InProceedings{ApelLBLK2011,
  author = 	 "Sven Apel and J{\"o}rg Liebig and Benjamin Brandl and Christian Lengauer and Christian K{\"a}stner",
  authorASCII = 	 "Sven Apel and Jorg Liebig and Benjamin Brandl and Christian Lengauer and Christian Kastner",
  title = 	 "Semistructured Merge: Rethinking Merge in Revision Control Systems",
  booktitle = FSE2011,
  pages = 	 "190--200",
  year = 	 2011,
  address = 	 FSE2011addr,
  month = 	 FSE2011date,
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% LocalWords: GhezziJM Ghezzi Mehdi Jazayeri Mandrioli NJ ISBN Belady BasitRJ Xu
% LocalWords: Sommerville Wokingham InProceedings VandevoordeG Guttag Hamid STL
% LocalWords: Vandevoorde booktitle dec StreckenbachS Mirko Gregor al Basit XVCL
% LocalWords: Streckenbach Snelting KABA addr Kataoka ICSM KataokaEGN Damith TSE
% LocalWords: Kataoka's Kremenek Ashcraft Junfeng Engler FSE KremenekAYE ErnstBN
% LocalWords: Rajapakse Jarzabek NEEDpages CCFinder HenkelD Henkel Bod Balzer
% LocalWords: Amer Diwan CatchUp BCELMethod MandelinXBK Mandelin Bodik Cheatham
% LocalWords: Rastislav Kimmelman authorSEARCHABLE Jungloid jungloid SW Boehm
% LocalWords: jungloids composable int TRW's jul BalzerCG nov sep Walkthroughs
% LocalWords: TechReport UWCSE OPTkey UWCSEaddr aug Opdyke CC MensT XP BasitJ
% LocalWords: Tourw feb Tourwe Misc Borland howpublished JavaOne jun Robillard
% LocalWords: ChowN Kingsum ObjectWindows widenings datapoints RutarAF Livshits
% LocalWords: Rutar Almazan JLint PMD KimSNM Miryung dnsjava higo ist LivshitsZ
% LocalWords: Vibha Sazawal osaka ac jp ISSRE Bandera ESC overclaim co DynaMine
% LocalWords: asitJ Itemset FIM IDs MayrandLM tokenization java Zimmermann baz
% LocalWords: OpenMBeanAttributeInfoSpport ObjectFactory jEdit checkins itemset
% LocalWords: OpenMBeanParameterInfoSpport Apriori checkin SullivanGSCSTR Cai
% LocalWords: Yuanyuan Yuanfang Macneil Shonle Nishit Tewari Hridesh LiZ Zhou
% LocalWords: Rajan un AspectJ Zhenmin PR PostgreSQL HTTP Engler's FireWire rba
% LocalWords: FindBugs Braude Budgen CoplienS Coplien FelleisenFFK Orla IEEE UI
% LocalWords: Felleisen Findler CohoonD Cohoon KuhnGG Greevy PCODA LSI Urbana
% LocalWords: Taghi Khoshgoftaar Ruqun Shan Faundez Sekirkin Boland MMR Mens QA
% LocalWords: EisenbarthKS Eisenbarth Koschke GreevyD phane Ducasse oct APIs Ko
% LocalWords: CMSR GreevyDG WongGH Gokhale Horgan ZaidmanCDP Zaidman Champaign
% LocalWords: Toon Calders Demeyer Paredaens Webmining webmining JMeter Parnin
% LocalWords: Kleinberg's HaRDRCRW Jungwoo Rossbach Indrajit Hany Inlining DOI
% LocalWords: Witchel Borland's authorASCII MurphyHillPB toolsmiths downcasting
% LocalWords:  refactorable Englewood McGraw subsequences getters checkable Yan
% LocalWords:  Winograd ApiwattanapongOH Taweesup Apiwattanapong supersededby
% LocalWords:  ASEjournal JDiff usesDaikonAsTestSubject JABA XuRTQ Guoqing Feng
% LocalWords:  Atanas Rountev Qin checkpointed DwyerKE Dwyer Kinneer Elbaum KoM
% LocalWords:  optimizine FSAs Emre AjaxScope Kiciman SOSP redeployabiliy Manos
% LocalWords:  Whyline timeline JFrame prefast JonesH totalpassed totalfailed
% LocalWords:  RenierisR Renieris Reiss iComment Gopal Radatz issn doi ADT isbn
% LocalWords:  JeongKZ Jeong Gaeul Sunghun WalradS Walrad Strom SCM BallKPS Siy
% LocalWords:  NagappanBZ Nagappan Nachiappan Rochkind IEEETSE SCCS BaconCPR
% LocalWords:  Yiling Parkes Rao Malvika Sakthivel CACM apr FritzM subtable
% LocalWords:  DSketch Cossette ApelLBLK2011 Apel Jorg Liebig Brandl Lengauer
% LocalWords:  Putnam78 BalzerCG83 Kastner Semistructured FSE2011 FSE2011addr
% LocalWords:  FSE2011date semistructured FSTGENERATOR FSTMERGE
