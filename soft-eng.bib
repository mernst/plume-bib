% Software engineering bibliography






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Maintenance
%%%



@Article{Putnam78,
  author = 	 "Lawrence H. Putnam",
  title = 	 "A general empirical solution to the macro software sizing
                  and estimating problem",
  journal = 	 TSE,
  year = 	 1978,
  volume =	 4,
  number =	 4,
  pages =	 "345--361",
  month =	 jul
}

@Article{BalzerCG83,
  author = 	 "R. Balzer and T. E. Cheatham, Jr. and C. Green",
  title = 	 "Software technology in the 1990's: Using a new paradigm",
  journal = 	 "Computer",
  year = 	 1983,
  volume =	 16,
  number =	 11,
  pages =	 "39--45",
  month =	 nov
}

@Article{Boehm87:top10,
  author = 	 "Barry W. Boehm",
  title = 	 "Industrial software metrics top 10 list",
  journal = 	 IEEESoftware,
  year = 	 1987,
  volume =	 4,
  number =	 5,
  pages =	 "84--85",
  month =	 sep
}





@Article{Erlikh2000,
  author = 	 "Erlikh, Len",
  title = 	 "Leveraging legacy system dollars for e-business",
  journal = 	 "IT Professional",
  year = 	 2000,
  volume = 	 2,
  number = 	 3,
  pages = 	 "17--23",
  month = 	 may,
}



@Article{Eastwood1993,
  author = 	 "A. Eastwood",
  title = 	 "Firm fires shots at legacy systems",
  journal = 	 "Computing Canada",
  year = 	 1993,
  volume = 	 19,
  number = 	 2,
  pages = 	 17,
}


@Article{Moad1990,
  author = 	 "J. Moad",
  title = 	 "Maintaining the competitive edge",
  journal = 	 "DATAMATION",
  year = 	 1990,
  pages = 	 "61--66",
  month = 	 feb,
}






@Article{LientzS1981,
  author = 	 "Lientz, Bennet P. and Swanson, E. Burton",
  title = 	 "Problems in application software maintenance",
  journal = 	 CACM,
  year = 	 1981,
  volume = 	 24,
  number = 	 11,
  pages = 	 "763--769",
  month = 	 nov,
}


@Book{ZelkowitzSG1979,
  author = 	 "Zelkowitz, Marvin V. and Shaw, Alan C. and Gannon, John D.",
  title = 	 "Principles of Software Engineering and Design",
  publisher = 	 "Prentice Hall Professional Technical Reference",
  year = 	 1979,
}












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Refactoring
%%%

@TechReport{Griswold91,
  author = 	 "William G. Griswold",
  title = 	 "Program Restructuring To Aid Software Maintenance",
  institution =  UWCSE,
  year = 	 1991,
  number =	 "91-08-04",
  address =	 UWCSEaddr,
  month =	 aug,
  note =	 "PhD dissertation"
}

@TechReport{Opdyke92,
  author = 	 "W. F. Opdyke",
  title = 	 "Refactoring: A Program Restructuring Aid in Designing
                  Object-Oriented Applications Frameworks",
  institution =  "University of Illinois at Urbana-Champaign, Dept. of Computer Science",
  year = 	 1992,
  number =	 1759,
  note =	 "PhD dissertation"
}



@book{Fowler2000,
 title = {Refactoring: Improving the Design of Existing Code},
 author = {Martin Fowler},
 publisher = {Addison-Wesley},
 year = {2000}
}



@InProceedings{Parr94,
  author = 	 "Terence J. Parr",
  title = 	 "An overview of {SORCERER}: A simple tree-parser generator",
  crossref =     "CC94",
  NEEDpages = 	 "",
}


@Article{MensT2004,
  author = 	 "Tom Mens and Tom Tourw{\'e}",
  authorASCII =  "Tom Mens and Tom Tourwe",
  title = 	 "A survey of software refactoring",
  journal = 	 TSE,
  year = 	 2004,
  volume =	 30,
  number =	 2,
  pages =	 "126--139",
  month =	 feb
}



@InProceedings{StreckenbachS2004,
  author = 	 "Mirko Streckenbach and Gregor Snelting",
  title = 	 "Refactoring class hierarchies with {KABA}",
  crossref =     "OOPSLA2004",
  pages = 	 "315--330",
}


@InProceedings{HenkelD2005,
  author = 	 "Johannes Henkel and Amer Diwan",
  title = 	 "CatchUp!  Capturing and replaying refactorings to support
                  {API} evolution",
  crossref =     "ICSE2005",
  pages = 	 "274--283",
  abstract =
   "Library developers who have to evolve a library to accommodate changing
    requirements often face a dilemma: Either they implement a clean, efficient
    solution but risk breaking client code, or they maintain compatibility with
    client code, but pay with increased design complexity and thus higher
    maintenance costs over time.
    \par
    We address this dilemma by presenting a lightweight approach for evolving
    application programming interfaces (APIs), which does not depend on version
    control or configuration management systems. Instead, we capture API
    actions as a developer evolves an API. Users of the API can then replay the
    refactorings to bring their client software components up to date.
    \par
    We present CatchUp!, an implementation of our approach that captures and
    replays refactoring actions within an integrated development environment
    semi-automatically. Our experiments suggest that our approach could be
    valuable in practice.",
}



@InProceedings{MurphyHillPB2009,
  author = 	 "Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.",
  title = 	 "How we refactor, and how we know it",
  crossref =     "ICSE2009",
  pages = 	 "287--297",
  abstract =
   "Much of what we know about how programmers refactor in the wild is
    based on studies that examine just a few software projects. Researchers
    have rarely taken the time to replicate these studies in other contexts
    or to examine the assumptions on which they are based. To help put
    refactoring research on a sound scientific basis, we draw conclusions
    using four data sets spanning more than 13 000 developers, 240 000
    tool-assisted refactorings, 2500 developer hours, and 3400 version
    control commits. Using these data, we cast doubt on several previously
    stated assumptions about how programmers refactor, while validating
    others. For example, we find that programmers frequently do not indicate
    refactoring activity in commit logs, which contradicts assumptions made
    by several previous researchers. In contrast, we were able to confirm
    the assumption that programmers do frequently intersperse refactoring
    with other program changes. By confirming assumptions and replicating
    studies made by other researchers, we can have greater confidence that
    those researchers' conclusions are generalizable.",
}






@InProceedings{KashiwaSLBLKU2021,
  author = 	 "Kashiwa, Yutaro and Shimizu, Kazuki and Lin, Bin and Bavota, Gabriele and Lanza, Michele and Kamei, Yasutaka and Ubayashi, Naoyasu",
  title = 	 "Does Refactoring Break Tests and to What Extent?",
  crossref =  "ICSME2021",
  pages = 	 "171-182",
}



@article{10.1145/3632870,
author = {Pailoor, Shankara and Wang, Yuepeng and Dillig, I\c{s}\i{}l},
title = {Semantic Code Refactoring for Abstract Data Types},
year = {2024},
issue_date = {January 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {8},
number = {POPL},
url = {https://doi.org/10.1145/3632870},
doi = {10.1145/3632870},
abstract = {Modifications to the data representation of an abstract data type (ADT) can require significant semantic refactoring of the code. Motivated by this observation, this paper presents a new method to automate semantic code refactoring tasks. Our method takes as input the original ADT implementation, a new data representation, and a so-called relational representation invariant (relating the old and new data representations), and automatically generates a new ADT implementation that is semantically equivalent to the original version. Our method is based on counterexample-guided inductive synthesis (CEGIS) but leverages three key ideas that allow it to handle real-world refactoring tasks. First, our approach reduces the underlying relational synthesis problem to a set of (simpler) programming-by-example problems, one for each method in the ADT. Second, it leverages symbolic reasoning techniques, based on logical abduction, to deduce code snippets that should occur in the refactored version. Finally, it utilizes a notion of partial equivalence to make inductive synthesis much more effective in this setting. We have implemented the proposed approach in a new tool called Revamp for automatically refactoring Java classes and evaluated it on 30 Java class mined from Github. Our evaluation shows that Revamp can correctly refactor the entire ADT in 97\% of the cases and that it can successfully re-implement 144 out of the 146 methods that require modifications.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {28},
numpages = {32},
keywords = {Program Synthesis, Abstract Data Types, Refactoring}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Programmer productivity: lines of code per day
%%%





@Book{McConnell2006,
  author = 	 "Steve McConnell",
  title = 	 "Software Estimation: Demystifying the Black Art",
  publisher = 	 "Microsoft Press",
  year = 	 2006,
}


@Book{Jones2011,
  author = 	 "Capers Jones",
  title = 	 "The Economics of Software Quality",
  publisher = 	 "Addison-Wesley",
  year = 	 2011,
}



@Misc{Su2006,
  author = 	 "Philip Su",
  title = 	 "Broken {Windows} Theory",
  howpublished = "\url{http://blogs.msdn.com/b/philipsu/archive/2006/06/14/631438.aspx}",
  month = 	 jun,
  year = 	 2006,
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Experimental methodology
%%%




@Article{HostRW2000,
  author =       "H{\"o}st, Martin and Regnell, Bj{\"o}rn and Wohlin, Claes",
  authorASCII =  "Host, Martin and Regnell, Bjorn and Wohlin, Claes",
  title =        "Using Students As Subjects---A Comparative Study of Students and Professionals in Lead-Time Impact Assessment",
  journal =      JEmpiricalSE,
  year =         2000,
  volume =    5,
  number =    3,
  pages =     "201--214",
  month =     nov,
  abstract =
   "In many studies in software engineering students are used instead of
    professional software developers, although the objective is to draw
    conclusions valid for professional software developers. This paper presents
    a study where the difference between the two groups is evaluated. People
    from the two groups have individually carried out a non-trivial software
    engineering judgement task involving the assessment of how ten different
    factors affect the lead-time of software development projects. It is found
    that the differences are only minor, and it is concluded that software
    engineering students may be used instead of professional software
    developers under certain conditions. These conditions are identified and
    described based on generally accepted criteria for validity evaluation of
    empirical studies.",
}





@InProceedings{Runeson2003,
  author =       "Runeson, Per",
  title =        "Using students as experiment subjects -- An analysis on graduate and freshmen student data",
  booktitle = "Proceedings of the 7th International Conference on Empirical Assessment in Software Engineering",
  year =      2003,
  pages =     "95-102",
  month =     apr # "~8--10,",
  address =   "Keele, UK",
  abstract =
   "The question whether students can be used as subjects in
    software engineering experiments is debated. In order to
    investigate the feasibility of using students as subjects, a
    study is conducted in the context of the Personal Software
    Process (PSP) in which the performance of freshmen students
    and graduate students are compared and also related
    to another study in an industrial setting. The hypothesis is
    that graduate students perform similarly to industry personnel,
    while freshmen student's performance differ. A
    quantitative analysis compares the freshmen' and graduate
    students. The improvement trends are also compared to
    industry data, although limited data access does not allow a
    full comparison. It can be concluded that very much the
    same improvement trends can be identified for the three
    groups. However, the dispersion is larger in the freshmen
    group. The absolute levels of the measured characteristics
    are significantly different between the student groups primarily
    with respect to time, i.e. graduate students do the
    tasks in shorter time. The data does not give a sufficient
    answer to the hypothesis, but is a basis for further studies
    on the issue.",
}


@InProceedings{SalmanTMJ2015,
  author =    "Iflaah Salman and Ay{\c{s}}e {Tosun Misirli} and Natalia Juristo",
  authorASCII = "Iflaah Salman and Ayse Tosun Misirli and Natalia Juristo",
  title =     "Are Students Representatives of Professionals in Software Engineering Experiments?",
  crossref =     "ICSE2015",
  pages =     "666-676",
}



@Article{Kitchenham:2009:SLR:1465742.1466091,
  author =       "Kitchenham, Barbara and O. Pearl Brereton and Budgen, David and Turner, Mark and Bailey, John and Linkman, Stephen",
  title =        "Systematic literature reviews in software engineering -- A systematic literature review",
  journal =      "Inf. Softw. Technol.",
  year =         2009,
  volume =    51,
  number =    1,
  pages =     "7--15",
  month =     jan,
}


@article{Kitchenham:2010:SLR:1808352.1808650,
 author = {Kitchenham, Barbara and Pretorius, Rialette and Budgen, David and Pearl Brereton, O. and Turner, Mark and Niazi, Mahmood and Linkman, Stephen},
 title = {Systematic Literature Reviews in Software Engineering - A Tertiary Study},
 journal = {Inf. Softw. Technol.},
 issue_date = {August, 2010},
 volume = {52},
 number = {8},
 month = aug,
 year = {2010},
 issn = {0950-5849},
 pages = {792--805},
 numpages = {14},
 url = {http://dx.doi.org/10.1016/j.infsof.2010.03.006},
 doi = {10.1016/j.infsof.2010.03.006},
 acmid = {1808650},
 publisher = {Butterworth-Heinemann},
 address = {Newton, MA, USA},
 keywords = {Mapping study, Software engineering, Systematic literature review, Tertiary study},
}


@inproceedings{Devanbu:2016:BEE:2884781.2884812,
 author = {Devanbu, Prem and Zimmermann, Thomas and Bird, Christian},
 title = {Belief \& Evidence in Empirical Software Engineering},
 booktitle = {Proceedings of the 38th International Conference on Software Engineering},
 series = {ICSE '16},
 year = {2016},
 isbn = {978-1-4503-3900-1},
 address  = {Austin, Texas},
 pages = {108--119},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/2884781.2884812},
 doi = {10.1145/2884781.2884812},
 acmid = {2884812},
}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Defect prediction (fault prediction)
%%%










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fault localization
%%%


@InProceedings{JonesH2005,
  author = 	 "James A. Jones and Mary Jean Harrold",
  title = 	 "Empirical evaluation of the {Tarantula} automatic fault-localization technique",
  crossref =     "ASE2005",
  pages = 	 "273--282",
}



@InProceedings{ParninO2011,
  author = 	 "Parnin, Chris and Orso, Alessandro",
  title = 	 "Are automated debugging techniques actually helping programmers?",
  crossref =     "ISSTA2011",
  pages = 	 "199--209",
}


@InProceedings{RenierisR2003,
  author = 	 "Manos Renieris and Steven P. Reiss",
  title = 	 "Fault localization with nearest neighbor queries",
  crossref =     "ASE2003",
  pages = 	 "30--39",
}


@InProceedings{SteimannFA2013,
  author = 	 "Steimann, Friedrich and Frenkel, Marcus and Abreu, Rui",
  title = 	 "Threats to the validity and value of empirical assessments of the accuracy of coverage-based fault locators",
  crossref =     "ISSTA2013",
  pages = 	 "314--324",
}

@InProceedings{ZhangZK2013,
  author = 	 "Zhang, Lingming and Zhang, Lu and Khurshid, Sarfraz",
  title = 	 "Injecting mechanical faults to localize developer faults for evolving software",
  crossref =     "OOPSLA2013",
  pages = 	 "765--784",
}

@InProceedings{JonesHS2002,
  author = 	 "Jones, James A. and Harrold, Mary Jean and Stasko, John",
  title = 	 "Visualization of test information to assist fault localization",
  crossref =     "ICSE2002",
  pages = 	 "467--477",
}

@Unpublished{YooNH2011,
  author = 	 "Yoo, Shin and Nilsson, Robert and Harman, Mark",
  title = 	 "Faster fault finding at {Google} using multi objective regression test optimisation",
  note = 	 "Unpublished paper accompanying industrial track talk at ESEC/FSE 2011",
  month = 	 sep,
  year = 	 2011,
}





@Article{DiGiuseppeJ2015,
  author = 	 "DiGiuseppe, Nicholas and Jones, James A.",
  title = 	 "Fault Density, Fault Types, and Spectra-based Fault Localization",
  journal = 	 JEmpiricalSE,
  year = 	 2015,
  volume = 	 20,
  number = 	 4,
  pages = 	 "928--967",
  month = 	 aug,
}









@InProceedings{KochharXLL2016,
  author = 	 "Kochhar, Pavneet Singh and Xia, Xin and Lo, David and Li, Shanping",
  title = 	 "Practitioners' expectations on automated fault localization",
  crossref =  "ISSTA2016",
  pages = 	 "165--176",
}


@InProceedings{LongR2016:ICSE,
  author = 	 "Long, Fan and Rinard, Martin",
  title = 	 "An analysis of the search spaces for generate and validate patch generation systems",
  crossref =  "ICSE2016",
  pages = 	 "702--713",
}





@InProceedings{WongWQZ2008,
  author = 	 "Wong, Eric and Wei, Tingting and Qi, Yu and Zhao, Lei",
  title = 	 "A crosstab-based statistical method for effective fault localization",
  crossref =  "ICST2008",
  pages = 	 "42-51",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Automated program repair (APR)
%%%




@Article{LeGouesNFW2012,
  author =       {Le Goues, Claire and Nguyen, ThanhVu and Forrest, Stephanie and Weimer, Westley},
  title =        {{GenProg}: A Generic Method for Automatic Software Repair},
  journal =      IEEETSE,
  year =         2012,
  volume =    38,
  number =    1,
  pages =     {54-72},
  month =     jan,
  abstract={This paper describes GenProg, an automated method for repairing defects in off-the-shelf, legacy programs without formal specifications, program annotations, or special coding practices. GenProg uses an extended form of genetic programming to evolve a program variant that retains required functionality but is not susceptible to a given defect, using existing test suites to encode both the defect and required functionality. Structural differencing algorithms and delta debugging reduce the difference between this variant and the original program to a minimal repair. We describe the algorithm and report experimental results of its success on 16 programs totaling 1.25 M lines of C code and 120K lines of module code, spanning eight classes of defects, in 357 seconds, on average. We analyze the generated repairs qualitatively and quantitatively to demonstrate that the process efficiently produces evolved programs that repair the defect, are not fragile input memorizations, and do not lead to serious degradation in functionality.},
}


@InProceedings{LeGouesDVFW2012,
  author = 	 "Le Goues, Claire and Dewey-Vogt, Michael and Forrest, Stephanie and Weimer, Westley",
  title = 	 "A systematic study of automated program repair: fixing 55 out of 105 bugs for \$8 each",
  crossref =     "ICSE2012",
  pages = 	 "3--13",
  abstract =
   "There are more bugs in real-world programs than human programmers can
    realistically address. This paper evaluates two research questions: ``What
    fraction of bugs can be repaired automatically?'' and ``How much does it
    cost to repair a bug automatically?'' In previous work, we presented
    GenProg, which uses genetic programming to repair defects in off-the-shelf
    C programs. To answer these questions, we: (1) propose novel algorithmic
    improvements to GenProg that allow it to scale to large programs and find
    repairs 68\% more often, (2) exploit GenProg's inherent parallelism using
    cloud computing resources to provide grounded, human-competitive cost
    measurements, and (3) generate a large, indicative benchmark set to use for
    systematic evaluations. We evaluate GenProg on 105 defects from 8
    open-source programs totaling 5.1 million lines of code and involving
    10,193 test cases. GenProg automatically repairs 55 of those 105
    defects. To our knowledge, this evaluation is the largest available of its
    kind, and is often two orders of magnitude larger than previous work in
    terms of code or test suite size or defect count. Public cloud computing
    prices allow our 105 runs to be reproduced for \$403; a successful repair
    completes in 96 minutes and costs \$7.32, on average.",
}




@InProceedings{QiLAR2015,
  author =       "Qi, Zichao and Long, Fan and Achour, Sara and Rinard, Martin",
  title =        "An analysis of patch plausibility and correctness for generate-and-validate patch generation systems",
  crossref =     "ISSTA2015",
  pages =     "24--36",
  doi = {10.1145/2771783.2771791},
}











@InProceedings{TianR2017,
  author = 	 "Tian, Yuchi and Ray, Baishakhi",
  title = 	 "Automatically diagnosing and repairing error handling bugs in {C}",
  crossref =  "FSE2017",
  year = 	 2017,
  pages = 	 "752--762",
}


@Article{Motwani2017,
author="Motwani, Manish
and Sankaranarayanan, Sandhya
and Just, Ren{\'e}
and Brun, Yuriy",
title="Do automated program repair techniques repair hard and important bugs?",
journal=JEmpiricalSE,
year="2017",
month="Nov",
day="18",
abstract="Existing evaluations of automated repair techniques focus on the fraction of the defects for which the technique can produce a patch, the time needed to produce patches, and how well patches generalize to the intended specification. However, these evaluations have not focused on the applicability of repair techniques and the characteristics of the defects that these techniques can repair. Questions such as ``Can automated repair techniques repair defects that are hard for developers to repair?'' and ``Are automated repair techniques less likely to repair defects that involve loops?'' have not, as of yet, been answered. To address such questions, we annotate two large benchmarks totaling 409 C and Java defects in real-world software, ranging from 22K to 2.8M lines of code, with measures of the defect's importance, the developer-written patch's complexity, and the quality of the test suite. We then analyze relationships between these measures and the ability to produce patches for the defects of seven automated repair techniques ---AE, GenProg, Kali, Nopol, Prophet, SPR, and TrpAutoRepair. We find that automated repair techniques are less likely to produce patches for defects that required developers to write a lot of code or edit many files, or that have many tests relevant to the defect. Java techniques are more likely to produce patches for high-priority defects. Neither the time it took developers to fix a defect nor the test suite's coverage correlate with the automated repair techniques' ability to produce patches. Finally, automated repair techniques are less capable of fixing defects that require developers to add loops and new function calls, or to change method signatures. These findings identify strengths and shortcomings of the state-of-the-art of automated program repair along new dimensions. The presented methodology can drive research toward improving the applicability of automated repair techniques to hard and important bugs.",
issn="1573-7616",
doi="10.1007/s10664-017-9550-0",
url="https://doi.org/10.1007/s10664-017-9550-0"
}




@inproceedings{vanTonder:2018:SAP:3180155.3180250,
 author = {van Tonder, Rijnard and Goues, Claire Le},
 title = {Static Automated Program Repair for Heap Properties},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering},
 series = {ICSE '18},
 year = {2018},
 isbn = {978-1-4503-5638-1},
 location = {Gothenburg, Sweden},
 pages = {151--162},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/3180155.3180250},
 doi = {10.1145/3180155.3180250},
 acmid = {3180250},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated program repair, separation logic},
}




@Article{AletiM2021,
  author = 	 "Aleti, Aldeida and Martinez, Matias",
  title = 	 "{E-APR}: Mapping the effectiveness of automated program repair techniques",
  journal = 	 JEmpiricalSE,
  year = 	 2021,
  volume = 	 26,
  number = 	 99,
  NEEDpages = 	 "*",
  month = 	 jul,
  abstract =
   "Automated Program Repair (APR) is a fast growing area with numerous new
    techniques being developed to tackle one of the most challenging software
    engineering problems. APR techniques have shown promising results, giving
    us hope that one day it will be possible for software to repair itself. In
    this paper, we focus on the problem of objective performance evaluation of
    APR techniques. We introduce a new approach, Explaining Automated Program
    Repair (E-APR), which identifies features of buggy programs that explain
    why a particular instance is difficult for an APR technique. E-APR is used
    to examine the diversity and quality of the buggy programs used by most
    researchers, and analyse the strengths and weaknesses of existing APR
    techniques. E-APR visualises an instance space of buggy programs, with each
    buggy program represented as a point in the space. The instance space is
    constructed to reveal areas of hard and easy buggy programs, and enables
    the strengths and weaknesses of APR techniques to be identified.",
}




@INPROCEEDINGS{tan2015relifix,
  author={Tan, Shin Hwei and Roychoudhury, Abhik},
  booktitle={2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  title={relifix: Automated Repair of Software Regressions},
  year={2015},
  volume={1},
  number={},
  pages={471-482},
  doi={10.1109/ICSE.2015.65}}








@Article{KirbasWMKPSVWCBHHW2021,
  author = 	 "Kirbas, Serkan and Windels, Etienne and McBello, Olayori and Kells, Kevin and Pagano, Matthew and Szalanski, Rafal and Nowack, Vesna and Winter, Emily Rowan and Counsell, Steve and Bowes, David and Hall, Tracy and Haraldsson, Saemundur and Woodward, John",
  title = 	 "On the introduction of automatic program repair in {Bloomberg}",
  journal = 	 IEEESoftware,
  year = 	 2021,
  volume = 	 38,
  number = 	 4,
  pages = 	 "43-51",
  month = 	 jul # "-" # aug,
}


@InProceedings{EldawyLGB2023,
  author = 	 "Hadeel Eladawy and Claire {Le Goues} and Yuriy Brun",
  title = 	 "Automated program repair, what is it good for? Not absolutely nothing!",
  crossref =  "ICSE2024",
  NEEDpages = 	 "*",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Clone detection and code similarity
%%%

@InProceedings{BasitRJ2005,
  author = 	 "Hamid Abdul Basit and Damith C. Rajapakse and Stan Jarzabek",
  title = 	 "Beyond templates: A study of clones in the {STL} and some
                  general implications",
  crossref =     "ICSE2005",
  pages = 	 "451--459",
  abstract =
   "Templates (or generics) help us write compact, generic code, which aids
    both reuse and maintenance. The STL is a powerful example of how templates
    help achieve these goals. Still, our study of the STL revealed substantial,
    and in our opinion, counter-productive repetitions (so-called clones)
    across groups of similar class or function templates. Clones occurred, as
    variations across these similar program structures were irregular and could
    not be unified by suitable template parameters in a natural way. We
    encountered similar problems in other class libraries as well as in
    application programs, written in a range of programming languages. In the
    paper, we present quantitative and qualitative results from our study. We
    argue that the difficulties we encountered affect programs in general. We
    present a solution that can treat such template-unfriendly cases of
    redundancies at the meta-level, complementing and extending the power of
    language features, such as templates, in areas of generic programming.",
}



@InProceedings{BasitJ2005,
  author = 	 "Hamid Abdul Basit and Stan Jarzabek",
  title = 	 "Detecting higher-level similarity patterns in programs",
  crossref =     "FSE2005",
  pages =	 "156--165",
  abstract =
   "Cloning in software systems is known to create problems during software
    maintenance. Several techniques have been proposed to detect the same or
    similar code fragments in software, so-called simple clones. While the
    knowledge of simple clones is useful, detecting design-level similarities
    in software could ease maintenance even further, and also help us identify
    reuse opportunities. We observed that recurring patterns of simple clones -
    so-called structural clones - often indicate the presence of interesting
    design-level similarities. An example would be patterns of collaborating
    classes or components. Finding structural clones that signify potentially
    useful design information requires efficient techniques to analyze the bulk
    of simple clone data and making non-trivial inferences based on the
    abstracted information. In this paper, we describe a practical solution to
    the problem of detecting some basic, but useful, types of design-level
    similarities such as groups of highly similar classes or files. First, we
    detect simple clones by applying conventional token-based techniques. Then
    we find the patterns of co-occurring clones in different files using the
    Frequent Itemset Mining (FIM) technique. Finally, we perform file
    clustering to detect those clusters of highly similar files that are likely
    to contribute to a design-level similarity pattern. The novelty of our
    approach is application of data mining techniques to detect design level
    similarities. Experiments confirmed that our method finds many useful
    structural clones and scales up to big programs. The paper describes our
    method for structural clone detection, a prototype tool called Clone Miner
    that implements the method and experimental results."
}




@InProceedings{KimSNM2005,
  author = 	 "Miryung Kim and Vibha Sazawal and David Notkin
                  and Gail C. Murphy",
  title = 	 "An empirical study of code clone genealogies",
  crossref =     "FSE2005",
  pages =	 "187--196",
  abstract =
   "It has been broadly assumed that code clones are inherently bad and that
    eliminating clones by refactoring would solve the problems of code
    clones. To investigate the validity of this assumption, we developed a
    formal definition of clone evolution and built a clone genealogy tool that
    automatically extracts the history of code clones from a source code
    repository. Using our tool we extracted clone genealogy information for two
    Java open source projects and analyzed their evolution.
    \par
    Our study contradicts some conventional wisdom about clones. In particular,
    refactoring may not always improve software with respect to clones for two
    reasons. First, many code clones exist in the system for only a short time;
    extensive refactoring of such short-lived clones may not be worthwhile if
    they are likely diverge from one another very soon. Second, many clones,
    especially long-lived clones that have changed consistently with other
    elements in the same group, are not easily refactorable due to programming
    language limitations. These insights show that refactoring will not help in
    dealing with some types of clones and open up opportunities for
    complementary clone maintenance tools that target these other classes of
    clones.",
}


@inproceedings{JB10,
  Author = {Kevin Jalbert and Jeremy S. Bradbury},
  Title = {Using Clone Detection to Identify Bugs in Concurrent Software},
  Booktitle = {Proc. of 26th IEEE International Conference on Software Maintenance (ICSM 2010)},
  Month = {Sept.},
  Year = {2010}
}




@InProceedings{SainiFLYMSBL2019,
  author = 	 "Saini, Vaibhav and Farmahinifarahani, Farima and Lu, Yadong and Yang, Di and Martins, Pedro and Sajnani, Hitesh and Baldi, Pierre and Lopes, Cristina V.",
  title = 	 "Towards automating precision studies of clone detectors",
  crossref =  "ICSE2019",
  pages = 	 "49-59",
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Debugging
%%%

@inproceedings{10.1145/3586183.3606781,
author = {Alaboudi, Abdulaziz and Latoza, Thomas D.},
title = {Hypothesizer: A Hypothesis-Based Debugger to Find and Test Debugging Hypotheses},
year = {2023},
isbn = {9798400701320},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3586183.3606781},
doi = {10.1145/3586183.3606781},
abstract = {When software defects occur, developers begin the debugging process by formulating hypotheses to explain the cause. These hypotheses guide the investigation process, determining which evidence developers gather to accept or reject the hypothesis, such as parts of the code and program state developers examine. However, existing debugging techniques do not offer support in finding relevant hypotheses, leading to wasted time testing hypotheses and examining code that ultimately does not lead to a fix. To address this issue, we introduce a new type of debugging tool, the hypothesis-based debugger, and an implementation of this tool in Hypothesizer. Hypothesis-based debuggers support developers from the beginning of the debugging process by finding relevant hypotheses until the defect is fixed. To debug using Hypothesizer, developers first demonstrate the defect, generating a recording of the program behavior with code execution, user interface events, network communications, and user interface changes. Based on this information and the developer’s descriptions of the symptoms, Hypothesizer finds relevant hypotheses, analyzes the code to identify relevant evidence to test the hypothesis, and generates an investigation plan through a timeline view. This summarizes all evidence items related to the hypothesis, indicates whether the hypothesis is likely to be true by showing which evidence items were confirmed in the recording, and enables the developer to quickly check evidence in the recording by viewing code snippets for each evidence item. A randomized controlled experiment with 16 professional developers found that, compared to traditional debugging tools and techniques such as breakpoint debuggers and Stack Overflow, Hypothesizer dramatically improved the success rate of fixing defects by a factor of five and decreased the time to debug by a factor of three.},
booktitle = {Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology},
articleno = {73},
numpages = {14},
keywords = {debugging tools, debugging hypotheses, debugging},
location = {San Francisco, CA, USA},
series = {UIST '23}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Documentation
%%%

@article{PARNAS199541,
title = {Functional documents for computer systems},
journal = {Science of Computer Programming},
volume = {25},
number = {1},
pages = {41-61},
year = {1995},
issn = {0167-6423},
doi = {https://doi.org/10.1016/0167-6423(95)96871-J},
url = {https://www.sciencedirect.com/science/article/pii/016764239596871J},
author = {David Lorge Parnas and Jan Madey},
keywords = {Documentation, Formal Methods, Software Engineering},
abstract = {Although software documentation standards often go into great detail about the format of documents, describing such details as paragraph numbering and section headings, they fail to give precise descriptions of the information to be contained in the documents. This paper does the opposite; it defines the contents of documents without specifying their format or the notation to be used in them. We describe documents such as the “System Requirements Document”, the “System Design Document”, the “Software Requirements Document”, the “Software Behaviour Specification”, the “Module Interface Specification”, and the “Module Internal Design Document” as representations of one or more mathematical relations. By describing those relations, we specify what information should be contained in each document.}
}


@INPROCEEDINGS {RongYLTZSH2025,
author = { Rong, Guoping and Yu, Yongda and Liu, Song and Tan, Xin and Zhang, Tianyi and Shen, Haifeng and Hu, Jidong },
booktitle = { 2025 IEEE/ACM 47th International Conference on Software Engineering (ICSE) },
title = {Code Comment Inconsistency Detection and Rectification Using a Large Language Model},
year = {2025},
volume = {},
ISSN = {1558-1225},
pages = {432-443},
abstract = { Comments are widely used in source code. If a comment is consistent with the code snippet it intends to annotate, it would aid code comprehension. Otherwise, Code Comment Inconsistency (CCI) is not only detrimental to the understanding of code, but more importantly, it would negatively impact the development, testing, and maintenance of software. To tackle this issue, existing research has been primarily focused on detecting inconsistencies with varied performance. It is evident that detection alone does not solve the problem; it merely paves the way for solving it. A complete solution requires detecting inconsistencies and, more importantly, rectifying them by amending comments. However, this type of work is scarce. In this paper, we contribute C4RLLaMA, a fine-tuned large language model based on the open-source CodeLLaMA. It not only has the ability to rectify inconsistencies by correcting relevant comment content but also outperforms state-of-the-art approaches in detecting inconsistencies. Experiments with various datasets confirm that C4RLLaMA consistently surpasses both post hoc and just-in-time CCI detection approaches. More importantly, C4RLLaMA outperforms substantially the only known CCI rectification approach in terms of multiple performance metrics. To further examine C4RLLaMA's efficacy in rectifying inconsistencies, we conducted a manual evaluation, and the results showed that the percentage of correct comment updates by C4RLLaMA was 65.0% and 55.9% in just-in-time and post hoc, respectively, implying C4RLLaMA's real potential in practical use. },
keywords = {Code-Comment Inconsistencies;Detection;Rectification;Large Language Model},
doi = {10.1109/ICSE55347.2025.00035},
url = {https://doi.ieeecomputersociety.org/10.1109/ICSE55347.2025.00035},
publisher = {IEEE Computer Society},
address = {Los Alamitos, CA, USA},
month =May}
  This paper is about inconsistency between code and comments, not inconsistency
among comments.  Their C4RLLaMA technique only changes code -- it assumes that
any inconsistency is due to a bad comment.  (The paper mentions in passing that
the code might be right, but their training and evaluation only considers cases
where the comment did change, whether or not the code also did.)  The technique
works in two stages -- first, it uses the LLM to determine whether the comments
are inconsistent with the code, and then it uses the LLM to change the code.  I
think a really interesting research project would be, after determining that the
comments are inconsistent with the code, deciding whether to change the comments
or the code.
  Evaluation is done in two ways:  "just-in-time" is given a diff and asked if
the diff introduces inconsistency, and "post hoc" is given one version of code
and its comment.  "the percentage of correct comment updates by C4RLLaMA was
65.0\% and 55.9\% in just-in-time and post hoc, respectively".  That seems
really low!  If the other updates were wrong, then a programmer needs to read
every output of C4RLLaMA and fix over 1/3 of them.  That sounds like a lot of
human work, and the paper does not account for the cost of false positive edits.
Its use of the F1 measure implies that false negatives and false positives are
equally costly, which is not the case in this scenario.
  I suspect there were 2 models, one for each scenario, but not 4 (which would
be the case if there were separate models for the "detection task" and the
"revision task").  "We utilized the widely used dataset from previous work as
our training and testing dataset".  The paper does not say how the training set
and evaluation set were ensured not to overlap; did the authors do anything at
all about that?
  Table 1 shows three inconsistent comments. (1) "Read" in comment, "write" in
method name.  (2) wrong number of formal parameters, which running Javadoc would
have revealed. (3) The comment "If there is no line number known, -1 is
returned" for a getter that just returns a field.  Because the method is a
simple getter, the paper says "the code here is inconsistent with the comment",
which I disagree with.  If the field might be -1, then the comment is consistent
with the code.  The one concrete example of C4RLLaMA correcting a comment, in
Table 4, is fixing a typo from "Arry" to "Array".  Based on these weak examples,
I am skeptical about the technique and experiments.
  C4RLLaMA is a fine-tuned version of CodeLLaMA (7B).  Given the fine-tuning,
the prompt is zero-shot.  The prompt asks the LLM to do chain-of-thought
reasoning.  The dataset used for training and evaluation is ((method_before,
comment_before), (method_after, comment_after)).  This dataset shows the full
method body but no context.  I presume the data comes from a version control
system.  Regarding the dataset, I did not understand this:  "Based on an
underlying assumption that all consistency issues will be rectified promptly, a
code change does not cause a consistency problem, C_before = C_after;
conversely, if the change raises a consistency problem, C_before != C_after."
Does "raises" mean "fixes"?
  For the detection task:  Numerically, their tool outperforms the best previous
one by just a 1-4\% percent on precision and recall for post hoc detection, and
it underperformed by 3\% on just-in-time detection; but for the latter
presenting diffs in a standard format gave their tool an additional boost to be
7\% better than previous work.  The revision
  For the revision task:  The revision evaluation omits some LLMs that were
evaluated for the detection task, such as GPT 3.5 and GPT 4.0; section 6 says
that's because they perform poorly on the detection task, but that argument does
not hold water for me.  It is unclear to me whether revision was done everywhere
that detection indicated an inconsistency, or only where there is truly an
inconsistency; if the latter, then one needs to multiply the success rates to
learn the end-to-end success rate.  I suspect that the original, unchanged
comments would do very well on metrics like BLEU that the paper uses.  The paper
admits this ("They are not the best for evaluating the efficacy of rectifying
CCI issues ... [even if wrong], the text similarity metrics may still be very
high."), but didn't provide any numeric evaluation.  The human evaluation of
correctness was done by undergraduates.  There is no mention of cross-validation
or inter-rater reliability testing.  The metric is:  "_successfully fixed_
requires that the resulting new comment is semantically related to the
corresponding code and does not contain explicit errors."  In other words, a
model can get full credit for a new comment that is no different than the
original.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Scientific programming and end-user programming
%%%

@InProceedings{LeeDM2006,
  author =       "Lee, Charlotte P. and Dourish, Paul and Mark, Gloria",
  title =        "The human infrastructure of cyberinfrastructure",
  crossref =  "CSCW2006",
  pages =     "483-492",
  abstract =
   "Despite their rapid proliferation, there has been little examination of the
    coordination and social practices of cyberinfrastructure projects. We use
    the notion of ``human infrastructure'' to explore how human and
    organizational arrangements share properties with technological
    infrastructures. We conducted an 18-month ethnographic study of a
    large-scale distributed biomedical cyberinfrastructure project and
    discovered that human infrastructure is shaped by a combination of both new
    and traditional team and organizational structures. Our data calls into
    question a focus on distributed teams as the means for accomplishing
    distributed work and we argue for using human infrastructure as an
    alternative perspective for understanding how distributed collaboration is
    accomplished in big science."
}



@Article{RibesL2010,
  author =       "Ribes, David and Lee, Charlotte P.",
  title =        "Sociotechnical Studies of Cyberinfrastructure and e-Research: Current Themes and Future Trajectories",
  journal =      JCSCW,
  year =         2010,
  volume =    19,
  pages =     "231-244",
  month =     sep,
  doi =       "https://doi.org/10.1007/s10606-010-9120-0",
}



@InProceedings{NguyenHoanFS2010,
  author =       "Nguyen-Hoan, Luke and Flint, Shayne and Sankaranarayana, Ramesh",
  title =        "A survey of scientific software development",
  crossref =  "ESEM2010",
  articleno = 12,
  numpages = 10,
}




@InProceedings{PrabhuJRZHKJLGBOZWA2011,
  author =       "Prabhu, Prakash and Jablin, Thomas B. and Raman, Arun and Zhang, Yun and Huang, Jialu and Kim, Hanjun and Johnson, Nick P. and Liu, Feng and Ghosh, Soumyadeep and Beard, Stephen and Oh, Taewook and Zoufaly, Matthew and Walker, David and August, David I.",
  title =        "A survey of the practice of computational science",
  crossref =  "SC2011",
  articleno = 19,
  numpages = 12,
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Software configuration
%%%

@InProceedings{XiongHSC2012,
  author =       "Xiong, Yingfei and Hubaux, Arnaud and She, Steven and Czarnecki, Krzysztof",
  title =        "Generating range fixes for software configuration",
  crossref =     "ICSE2012",
  pages =     "58--68",
}

@InProceedings{WhitakerCG2004,
  author =       "Whitaker, Andrew and Cox, Richard S. and Gribble, Steven D.",
  title =        "Configuration debugging as search: finding the needle in the haystack",
  crossref =     "OSDI2004",
  pages =     "77-90",
}


@InProceedings{WangPCZW2004,
  author =       "Wang, Helen J. and Platt, John C. and Chen, Yu and Zhang, Ruyun and Wang, Yi-Min",
  title =        "Automatic misconfiguration troubleshooting with {PeerPressure}",
  crossref =     "OSDI2004",
  pages =     "245-257",
}


@InProceedings{RabkinK2011:ICSE,
  author =       "Rabkin, Ariel and Katz, Randy",
  title =        "Static extraction of program configuration options",
  crossref =     "ICSE2011",
  pages =     "131--140",
}


@InProceedings{RabkinK2011:ASE,
  author =       "Rabkin, Ariel and Katz, Randy",
  title =        "Precomputing possible configuration error diagnoses",
  crossref =     "ASE2011",
  pages =     "193--202",
}


@InProceedings{KellerUC2008,
  author =       "Keller, Lorenzo and Upadhyaya, Prasang and Candea, George",
  title =        "{ConfErr}: A tool for assessing resilience to human configuration errors",
  crossref =     "DSN2008",
  pages =     "157--166",
}


@Article{XiongZHSWC2014,
  author =       "Yingfei Xiong and Hansheng Zhang and Arnaud Hubaux and Steven She and Jie Wang and Krzysztof Czarnecki",
  title =        "Range fixes: Interactive error resolution for software configuration",
  journal =      TSE,
  year =         2014,
  volume =    41,
  number =    6,
  pages =     "603-619",
  month =     jun,
}

@InProceedings{HubauxXC2012,
  author =       "Hubaux, Arnaud and Xiong, Yingfei and Czarnecki, Krzysztof",
  title =        "A user survey of configuration challenges in {Linux} and {eCos}",
  crossref =     "VaMoS2012",
  pages =     "149--155",
}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Evaluation of software development practices
%%%

@Book{Glass2002,
  author =    {Robert Glass},
  title =        {Facts and Fallacies of Software Engineering},
  publisher =    {Addison-Wesley Professional},
  year =         2002,
}

@Book{Bossavit2013,
  author =    {Laurent Bossavit},
  title =        {The Leprechauns of Software Engineering: How folklore turns into fact and what to do about it},
  publisher =    {Leanpub},
  year =         2013,
  edition =   {G15},
}

@InProceedings{DunsmoreRW2002,
  author = 	 "Alastair Dunsmore and Marc Roper and Murray Wood",
  title = 	 "Further investigations into the development and
                  evaluation of reading techniques for object-oriented code
                  inspection",
  crossref =     "ICSE2002",
  pages =	 "47--57",
}

@Book{Brooks1975,
  author = 	 "Brooks, Jr., Frederick P.",
  title = 	 "The Mythical Man-Month: Essays on Software Engineering",
  publisher = 	 "Addison-Wesley",
  year = 	 1975,
  address = {Boston, MA, USA},
  isbn = {0201006502},
}



%%% Rapid releases

@inproceedings{10.1109/ICSM.2013.13,
author = {M\"{a}ntyl\"{a}, Mika V. and Khomh, Foutse and Adams, Bram and Engstr\"{o}m, Emelie and Petersen, Kai},
title = {On Rapid Releases and Software Testing},
year = {2013},
isbn = {9780769549811},
publisher = {IEEE Computer Society},
address = {USA},
url = {https://doi.org/10.1109/ICSM.2013.13},
doi = {10.1109/ICSM.2013.13},
abstract = {Large open and closed source organizations like Google, Facebook and Mozilla are migrating their products towards rapid releases. While this allows faster time-to-market and user feedback, it also implies less time for testing and bug fixing. Since initial research results indeed show that rapid releases fix proportionally less reported bugs than traditional releases, this paper investigates the changes in software testing effort after moving to rapid releases. We analyze the results of 312,502 execution runs of the 1,547 mostly manual system level test cases of Mozilla Fire fox from 2006 to 2012 (5 major traditional and 9 major rapid releases), and triangulated our findings with a Mozilla QA engineer. In rapid releases, testing has a narrower scope that enables deeper investigation of the features and regressions with the highest risk, while traditional releases run the whole test suite. Furthermore, rapid releases make it more difficult to build a large testing community, forcing Mozilla to increase contractor resources in order to sustain testing for rapid releases.},
booktitle = {Proceedings of the 2013 IEEE International Conference on Software Maintenance},
pages = {20–29},
numpages = {10},
keywords = {Mozilla, Software testing, agile releases, bugs, builds, opensource, release model},
series = {ICSM '13}
}


@InProceedings{BaysalDG2011,
  author =       {Olga Baysal and Ian Davis and Michael W Godfrey},
  title =        {A tale of two browsers},
  crossref =  {MSR2011},
  pages =     {238-241},
  abstract =
   {We explore the space of open source systems and their user communities by
    examining the development artifact histories of two popular web browsers --
    Firefox and Chrome -- as well as usage data. By examining the data and
    addressing a number of research questions, two very different profiles
    emerge: Firefox, as the older and established system, with long product
    version cycles but short bug fix cycles, and a user base that is slow to
    adopt newer versions; and Chrome, as the new and fast evolving system, with
    short version cycles, longer bug fix cycles, and a user base that very
    quickly adopts new versions as they become available (due largely to
    Chrome's mandatory automatic updates).},
}


@inproceedings{Khomh:2012:FRI:2664446.2664475,
 author = {Khomh, Foutse and Dhaliwal, Tejinder and Zou, Ying and Adams, Bram},
 title = {Do Faster Releases Improve Software Quality?: An Empirical Case Study of Mozilla Firefox},
 booktitle = {Proceedings of the 9th IEEE Working Conference on Mining Software Repositories},
 series = {MSR '12},
 year = {2012},
 isbn = {978-1-4673-1761-0},
 address  = {Zurich, Switzerland},
 pages = {179--188},
 numpages = {10},
 url = {http://dl.acm.org/citation.cfm?id=2664446.2664475},
 acmid = {2664475},
 keywords = {bugs, release cycle, software quality, software release, testing},
}


%%% Program reading and readability


@inproceedings{Siegmund:2014:UUS:2568225.2568252,
 author = {Siegmund, Janet and K\"{a}stner, Christian and Apel, Sven and Parnin, Chris and Bethmann, Anja and Leich, Thomas and Saake, Gunter and Brechmann, Andr{\'e}},
 title = {Understanding Understanding Source Code with Functional Magnetic Resonance Imaging},
 booktitle = {Proceedings of the 36th International Conference on Software Engineering},
 series = {ICSE 2014},
 year = {2014},
 isbn = {978-1-4503-2756-5},
 address  = {Hyderabad, India},
 pages = {378--389},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/2568225.2568252},
 doi = {10.1145/2568225.2568252},
 acmid = {2568252},
 keywords = {Functional magnetic resonance imaging, program comprehension},
}


@InProceedings{BuseW2008,
  author = 	 "Buse, Raymond P.L. and Weimer, Westley R.",
  title = 	 "A metric for software readability",
  crossref =  "ISSTA2008",
  pages = 	 "121--130",
}

@Article{BuseW2010,
  author = 	 "Buse, Raymond P. L. and Weimer, Westley R.",
  title = 	 "Learning a Metric for Code Readability",
  journal = 	 TSE,
  year = 	 2010,
  volume = 	 36,
  number = 	 4,
  pages = 	 "546--558",
  month = 	 jul,
  abstract =
   "In this paper, we explore the concept of code readability and investigate
    its relation to software quality. With data collected from 120 human
    annotators, we derive associations between a simple set of local code
    features and human notions of readability. Using those features, we
    construct an automated readability measure and show that it can be 80
    percent effective and better than a human, on average, at predicting
    readability judgments. Furthermore, we show that this metric correlates
    strongly with three measures of software quality: code changes, automated
    defect reports, and defect log messages. We measure these correlations on
    over 2.2 million lines of code, as well as longitudinally, over many
    releases of selected projects. Finally, we discuss the implications of this
    study on programming language design and engineering practice. For example,
    our data suggest that comments, in and of themselves, are less important
    than simple blank lines to local judgments of readability.",
}


%%% Object-oriented programming


@article{https://doi.org/10.1002/(SICI)1097-024X(199908)29:10<833::AID-SPE258>3.0.CO;2-P,
author = {Potok, Thomas E. and Vouk, Mladen and Rindos, Andy},
title = {Productivity analysis of object-oriented software developed in a commercial environment},
journal = {Software: Practice and Experience},
volume = {29},
number = {10},
pages = {833-847},
keywords = {object-oriented, software development productivity},
doi = {https://doi.org/10.1002/(SICI)1097-024X(199908)29:10<833::AID-SPE258>3.0.CO;2-P},
url = {https://onlinelibrary.wiley.com/doi/abs/10.1002/%28SICI%291097-024X%28199908%2929%3A10%3C833%3A%3AAID-SPE258%3E3.0.CO%3B2-P},
eprint = {https://onlinelibrary.wiley.com/doi/pdf/10.1002/%28SICI%291097-024X%28199908%2929%3A10%3C833%3A%3AAID-SPE258%3E3.0.CO%3B2-P},
abstract = {Abstract The introduction of object-oriented technology does not appear to hinder overall productivity on new large commercial projects, but nor does it seem to improve it in the first two product generations. In practice, the governing influence may be the business workflow, and not the methodology.},
year = {1999}
}



@article{WIEDENBECK1999255,
title = {A comparison of the comprehension of object-oriented and procedural programs by novice programmers},
journal = {Interacting with Computers},
volume = {11},
number = {3},
pages = {255-282},
year = {1999},
issn = {0953-5438},
doi = {https://doi.org/10.1016/S0953-5438(98)00029-0},
url = {https://www.sciencedirect.com/science/article/pii/S0953543898000290},
author = {Susan Wiedenbeck and Vennila Ramalingam and Suseela Sarasamma and CynthiaL Corritore},
keywords = {Object-oriented programming, Empirical studies of programming, Novice programmers, Learning to program},
abstract = {This paper reports on two experiments comparing mental representations and program comprehension by novices in the object-oriented and procedural styles. The subjects were novice programmers enrolled in a second course in programming which taught either the object-oriented or the procedural paradigm. The first experiment compared the mental representations and comprehension of short programs written in the procedural and object-oriented styles. The second experiment extended the study to a larger program incorporating more advanced language features. For the short programs there was no significant difference between the two groups with respect to the total number of questions answered correctly, but the object-oriented subjects were superior to the procedural subjects at answering questions about program function. This suggests that function information was more readily available in their mental representations of the programs and supports an argument that the object-oriented notation highlights function at the level of the individual class. For the long program a corresponding effect was not found. The comprehension of procedural subjects was superior to object-oriented subjects on all types of question. The difficulties experienced by the object-oriented subjects in answering questions in a larger program suggest that they faced problems in marshaling information and drawing inferences from it. We suggest that this result may be related to a longer learning curve for novices of the object-oriented style, as well as to features of the OO style and the particular OO language notation.}
}

@article{detienne1997assessing,
  title={Assessing the cognitive consequences of the object-oriented approach: A survey of empirical research on object-oriented design by individuals and teams},
  author={D{\'e}tienne, Fran{\c{c}}oise},
  journal={Interacting with computers},
  volume={9},
  number={1},
  pages={47--72},
  year={1997},
  publisher={Elsevier}
}

@article{LIM2005131,
title = {An empirical investigation of the impact of the object-oriented paradigm on the maintainability of real-world mission-critical software},
journal = {Journal of Systems and Software},
volume = {77},
number = {2},
pages = {131-138},
year = {2005},
issn = {0164-1212},
doi = {https://doi.org/10.1016/j.jss.2004.11.004},
url = {https://www.sciencedirect.com/science/article/pii/S0164121204002237},
author = {Joa Sang Lim and Seung Ryul Jeong and Stephen R. Schach},
abstract = {Empirical evidence for the maintainability of object-oriented systems is far from conclusive, partly due to the lack of representativeness of the subjects and systems used in earlier studies. We empirically examined this issue for mission-critical software that was currently operational and maintained by software professionals. Two functionally equivalent versions of a credit approval system were maintained, one object oriented (OO) and the other non-object oriented (NOO). We found that the OO group took less time to maintain a greater number of software artifacts than its NOO counterpart. This difference held for all phases of the software development life cycle. This result was due to the usefulness of UML for impact analysis of the OO version, which contributed to effective comprehension and communication. Insufficient design specifications for the NOO version led to ambiguity and costly defects in transferring design solutions to development. Also, the encapsulation of the OO version appeared to reduce mental loads for maintenance tasks and resulted in code reuse. On the other hand, the number of files to be managed increased and, thus, dependency management was required for the OO version. Furthermore, despite much tuning, the OO version ran slower than its NOO counterpart. More field studies on software professionals are needed to compare contextual factors such as methods, processes, and maintenance tools.}
}


@Article{WhiteS2005,
  author =       {White, Garry and Sivitanides, Marcos},
  title =        {Cognitive Differences Between Procedural Programming and Object Oriented Programming},
  journal =      {Information Technology and Management},
  year =         2005,
  volume =    6,
  number =    4,
  pages =     {333-350},
  abstract =  {Software development is moving from procedural programming towards object-oriented programming (OOP). Past studies in cognitive aspects of programming have focused primarily on procedural programming languages. Object-oriented programming is a new paradigm for computing. Industry is finding that programmers are having difficulty shifting to this new programming paradigm.},
}

@techreport{10.5555/903321,
author = {Henry, Sallie M. and Humphrey, Matthew C.},
title = {Comparison of an Object-Oriented Programming Language to a Procedural Programming Language for Effectiveness in Program Maintenance},
year = {1988},
publisher = {Virginia Polytechnic Institute \& State University},
address = {USA},
abstract = {New software tools and methodologies make claims that managers often believe intuitively, without evidence. Many unsupported claims have been made about object-oriented programming. However, without scientific evidence, it is impossible to accept these claims as valid. Although experimentation has been done in the past, most of the research is very recent and the most relevant research has serious drawbacks. This paper describes an experiment which compares the maintainability of two functionally equivalent systems in order to explore the claim that systems developed with object-oriented languages are more easily maintained than those programmed with procedural languages. We found supporting evidence that programmers produce more maintainable code with an object oriented language than a standard procedural language.}
}

@InProceedings{10.1007/978-1-4471-1525-0_2,
author="Whiddett, Richard J. Dick
and Bailey, Michael A.",
editor="Orlowska, Maria E.
and Zicari, Roberto",
title="Complexity and Maintenance: A Comparative Study of Object-Oriented and Structured Methodologies",
booktitle="OOIS'97",
year="1998",
publisher="Springer London",
address="London",
pages="7--17",
abstract="It has been suggested that using Object-Oriented methods instead of traditional Structured Methods may reduce the cost of maintenance of an information system. This study evaluates the relative increase in complexity of systems designs when they are subjected to a change in specifications. It was found that overall, the object-oriented system underwent a smaller increase in complexity, and it may therefore be easier to maintain than the structured system.",
isbn="978-1-4471-1525-0"
}



%%% Offshoring/Outsourcing


@inproceedings{10.1109/ICGSE.2017.12,
author = {\v{S}mite, Darja and Britto, Ricardo and van Solingen, Rini},
title = {Calculating the extra costs and the bottom-line hourly cost of offshoring},
year = {2017},
isbn = {9781538615874},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ICGSE.2017.12},
doi = {10.1109/ICGSE.2017.12},
abstract = {Offshoring software development activities to a remote site in another country continues to be one of the key strategies to save development cost. However, the assumed economic benefits of offshoring are often questionable, due to a large number of hidden costs and too simple cost calculations. This study is a continuation of our work on calculating the true hourly cost that includes the extra direct and indirect costs on top of the salary-based hourly rates. We collected data from an empirical case study conducted in a large international corporation. This corporation develops software-intensive systems and has offshored its ongoing product development from Sweden to a recently on-boarded captive company site in India. In this paper, we report a number of extra costs and their impact on the resulting hourly cost as well as the bottom-line cost per work unit. Our analysis includes quantitative data from corporate archives, and expert-based estimates gathered through focus groups and workshops with company representatives from both the onshore and the offshore sites. Our findings show that there is additional cost that can be directly or at least strongly attributed to the transfer of work, working on a distance, and immaturity of the offshore site. Consideration of extra costs increases the hourly cost several times, while the performance gaps between the mature sites and the immature site leads to an even higher difference. As a result, two years after on-boarding of the offshore teams, the mature teams in high-cost locations continue to be "cheaper" despite the big salary differences; and the most positive hypothetical scenario, in which the company could break even, is unrealistic. The implications of our findings are twofold. First, offshoring of complex ongoing products does not seem to lead to short-term bottom-line economic gains, and may not even reach breakeven within five years. Second, offshoring in the studied case can be justified but merely when initiated for other reasons than cost.},
booktitle = {Proceedings of the 12th International Conference on Global Software Engineering},
pages = {96–105},
numpages = {10},
keywords = {case study, empirical, extra cost, global software development, hidden cost, large-scale software development, offshore cost, offshoring, software transfer},
location = {Buenos Aires, Argentina},
series = {ICGSE '17}
}

@inproceedings{10.1109/ICGSE.2019.000-8,
author = {Smite, Darja and Moe, Nils Brede and Krekling, Thomas and Stray, Viktoria},
title = {Offshore outsourcing costs: known or still hidden?},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ICGSE.2019.000-8},
doi = {10.1109/ICGSE.2019.000-8},
abstract = {Offshore outsourcing of software development has been both famous for the promises of great cost reductions, and infamous for the hidden costs associated with the challenges of organizing software work over distance. Experience shows that many of these costs do not receive the deserved attention and are often excluded when making offshoring decisions. As a result, there is often a significant deviation between the expected and the realized costs of offshoring. In this paper, we investigate the awareness of the extra costs when making an offshoring decision, and the significance of the actual cost deviations. We conducted a single case study of a company that carried out an offshore outsourcing pilot project. We collected qualitative data from interviews, observations and a retrospective, and quantitative data on the costs and effort associated with the project. We conclude that the company was aware of the hidden cost factors, but largely underestimated their significance. The costs that surfaced in the studied project accounted for a total deviation of 181\% and several individual cost categories with more than 400\% overrun. The two main cost drivers in our study were the distance and poor process fit, which escalated the investments needed to make the collaboration work. Our results suggest that pilots are useful to understand the key problem areas in an offshoring collaboration, but too limited to shed light on all potential problems (e.g. turnover) due to the short timeframe. We also conclude that results of pilot projects shall not be the only data source when calculating the true costs of offshoring, since the start-up phase of an offshoring relationship carries large investments. Finally, we provide recommendations for companies in a similar situation on how to run and learn from offshore outsourcing pilot projects.},
booktitle = {Proceedings of the 14th International Conference on Global Software Engineering},
pages = {40–47},
numpages = {8},
keywords = {cost-savings, extra costs, global software engineering, hidden costs, offshore outsourcing, offshoring},
location = {Montreal, Quebec, Canada},
series = {ICGSE '19}
}


@article{10.1145/1113034.1113063,
author = {Patterson, David A.},
title = {Offshoring: finally facts vs. folklore},
year = {2006},
issue_date = {February 2006},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {2},
issn = {0001-0782},
url = {https://doi.org/10.1145/1113034.1113063},
doi = {10.1145/1113034.1113063},
abstract = {The ACM Job Migration study was released last month, and it includes many recommendations for current and future computing professionals and educators.},
journal = {Commun. ACM},
month = feb,
pages = {41–42},
numpages = {2}
}


@article{10.1145/1400181.1400212,
author = {Tiwana, Amrit and Bush, Ashley A. and Tsuji, Hiroshi and Yoshida, Kenichi and Sakurai, Akito},
title = {Myths and paradoxes in Japanese IT offshoring},
year = {2008},
issue_date = {October 2008},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {51},
number = {10},
issn = {0001-0782},
url = {https://doi.org/10.1145/1400181.1400212},
doi = {10.1145/1400181.1400212},
journal = {Commun. ACM},
month = oct,
pages = {141–145},
numpages = {5}
}


@inproceedings{10.1145/3439961.3439978,
author = {Sim\~{o}es, Carlos and Santos, Gleison},
title = {IT Workforce Outsourcing Benefits, Challenges and Success Factors in the Customer and Supplier Perspectives},
year = {2021},
isbn = {9781450389235},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3439961.3439978},
doi = {10.1145/3439961.3439978},
abstract = {Software organizations need IT workforce members with knowledge and skills to perform their activities properly. The IT workforce may be employed by the organization or made available by an external supplier. Several benefits, challenges, and success factors are associated with workforce outsourcing. They must be addressed properly as they influence directly or indirectly the performance and quality of services provided in the development and maintenance of information systems. We present a qualitative study on the benefits, challenges and success factors associated with outsourcing the IT workforce. We interviewed 38 participants involved in the IT workforce outsourcing business as contract managers, consultants, and team and workforce managers. As a result, we present 18 benefits, 67 challenges, and 31 success factors from the perspective of organizations that hire or provide outsourced workers. This study can be used to increase knowledge in the IT workforce outsourcing business, helping to identify best practices, minimize risks and support the definition and improvement processes related to IT workforce outsourcing.},
booktitle = {Proceedings of the XIX Brazilian Symposium on Software Quality},
articleno = {17},
numpages = {9},
keywords = {Benefits, Challenges, IT Services, IT Workforce Outsourcing, Qualitative Study, Success factors},
location = {S\~{a}o Lu\'{\i}s, Brazil},
series = {SBQS '20}
}

@article{10.1145/3727635,
author = {Corpus, Isabel and Giannella, Eric and Koenecke, Allison and Moynihan, Don},
title = {As Government Outsources More IT, Highly Skilled In-House Technologists Are More Essential},
year = {2025},
issue_date = {July 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {68},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/3727635},
doi = {10.1145/3727635},
abstract = {We need more, not fewer technologists at all levels of government to ensure high-quality, cost-effective programs.},
journal = {Commun. ACM},
month = jun,
pages = {37–40},
numpages = {4}
}


%%% Other


@Misc{MoselyM2006,
  author =    {Ben Moseley and Peter Marks},
  title =     {Out of the Tar Pit},
  month =     feb,
  year =      2006,
  abstract =
   {Complexity is the single major difficulty in the successful development
    of large-scale software systems. Following Brooks we distinguish
    accidental from essential difficulty, but disagree with his premise that
    most complexity remaining in contemporary systems is essential. We
    identify common causes of complexity and discuss general approaches
    which can be taken to eliminate them where they are accidental in
    nature. To make things more concrete we then give an outline for
    a potential complexity-minimizing approach based on functional
    programming and Codd’s relational model of data.},
}



@InProceedings{JohnsonSMHB2013,
  author = 	 "Johnson, Brittany and Song, Yoonki and Murphy-Hill, Emerson and Bowdidge, Robert",
  title = 	 "Why don't software developers use static analysis tools to find bugs?",
  crossref =     "ICSE2013",
  pages = 	 "672--681",
  abstract =
   "Using static analysis tools for automating code inspections can be
    beneficial for software engineers. Such tools can make finding bugs, or
    software defects, faster and cheaper than manual inspections. Despite the
    benefits of using static analysis tools to find bugs, research suggests
    that these tools are underused. In this paper, we investigate why
    developers are not widely using static analysis tools and how current tools
    could potentially be improved. We conducted interviews with 20 developers
    and found that although all of our participants felt that use is
    beneficial, false positives and the way in which the warnings are
    presented, among other things, are barriers to use. We discuss several
    implications of these results, such as the need for an interactive
    mechanism to help developers fix defects.",
}

@InProceedings{Przybylek2011,
  author = 	 "Adam Przyby{\l}ek",
  authorASCII =  "Adam Przybyłek, Adam Przybylek",
  title = 	 "Where the truth lies: {AOP} and its impact on software modularity",
  crossref =     "FASE2011",
  NEEDpages = 	 "*",
  abstract =
   "Modularity is the single attribute of software that allows a program to be
    intellectually manageable [29]. The recipe for modularizing is to define a
    narrow interface, hide an implementation detail, keep low coupling and high
    cohesion. Over a decade ago, aspect-oriented programming (AOP) was proposed
    in the literature to ``modularize the un-modularizable'' [24]. Since then,
    aspect-oriented languages have been providing new abstraction and
    composition mechanisms to deal with concerns that could not be modularized
    because of the limited abstractions of the underlying programming
    language. This paper is a continuation of our earlier work [32] and further
    investigates AO software with regard to coupling and cohesion. We compare
    two versions (Java and AspectJ) of ten applications to review AOP within
    the context of software modularity. It turns out that the claim that ``the
    software built in AOP is more modular than the software built in OOP'' is a
    myth.",
}


@InProceedings{LoNZ2015,
  author = 	 "David Lo and Nachiappan Nagappan and Thomas Zimmermann",
  title = 	 "How practitioners perceive the relevance of software engineering research",
  crossref =     "FSE2015",
  pages = 	 "415-425",
}

@InProceedings{MatichukMAJKS2015,
  author =       "Daniel Matichuk and Toby Murray and June Andronick and Ross Jeffery and Gerwin Klein and Mark Staples",
  title =        "Empirical study towards a leading indicator for cost of formal software verification",
  crossref =     "ICSE2015",
  NEEDpages =     "*",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous
%%%


@Misc{Borland2004,
  author =	 "Borland",
  title =	 "Making Development A Team Sport",
  howpublished = "demo at JavaOne",
  month =	 jun # "~29,",
  year =	 2004
}

@InProceedings{ChowN96,
  author = 	 "Kingsum Chow and David Notkin",
  title = 	 "Semi-automatic update of applications in response to
                  library changes",
  crossref =     "ICSM96",
  pages =	 "259--368",
}



@InProceedings{MandelinXBK2005,
  author = 	 "David Mandelin and Lin Xu and Rastislav Bod{\'\i}k and
                  Doug Kimmelman",
  authorSEARCHABLE = "Rastislav Bodik",
  title = 	 "Jungloid mining: Helping to navigate the {API} jungle",
  crossref =     "PLDI2005",
  pages = 	 "48--61",
  abstract =
   "Reuse of existing code from class libraries and frameworks is often
    difficult because APIs are complex and the client code required to use the
    APIs can be hard to write. We observed that a common scenario is that the
    programmer knows what type of object he needs, but does not know how to
    write the code to get the object.
    \par
    In order to help programmers write API client code more easily, we
    developed techniques for synthesizing jungloid code fragments automatically
    given a simple query that describes that desired code in terms of input and
    output types. A jungloid is simply a unary expression; jungloids are
    simple, enabling synthesis, but are also versatile, covering many coding
    problems, and composable, combining to form more complex code fragments. We
    synthesize jungloids using both API method signatures and jungloids mined
    from a corpus of sample client programs.
    \par
    We implemented a tool, Prospector, based on these techniques. Prospector is
    integrated with the Eclipse IDE code assistance feature, and it infers
    queries from context so there is no need for the programmer to write
    queries. We tested Prospector on a set of real programming problems
    involving APIs; Prospector found the desired solution for 18 of 20
    problems.We also evaluated Prospector in a user study, finding that
    programmers solved programming problems more quickly and with more reuse
    when using Prospector than without Prospector."
}



@Article{SanthiarPK2014,
  author = 	 "Santhiar, Anirudh and Pandita, Omesh and Kanade, Aditya",
  title = 	 "Mining Unit Tests for Discovery and Migration of Math {APIs}",
  journal = 	 TOSEM,
  year = 	 2014,
  volume = 	 24,
  number = 	 1,
  pages = 	 "4:1--4:33",
  month = 	 oct,
}



@InProceedings{GhafariGMT2014,
  author = 	 "Mohammad Ghafari and Carlo Ghezzi and Andrea Mocci and Giordano Tamburrelli",
  title = 	 "Mining unit tests for code recommendation",
  crossref =     "ICPC2014",
  pages = 	 "142--145",
}



@InProceedings{RutarAF2004,
  author = 	 "Nick Rutar and Christian B. Almazan and Jeffrey S. Foster",
  title = 	 "A comparison of bug finding tools for {Java}",
  crossref =     "ISSRE2004",
  pages =	 "245--256",
  abstract =
   "Bugs in software are costly and difficult to find and fix. In recent years,
    many tools and techniques have been developed for automatically finding
    bugs by analyzing source code or intermediate code statically (at compile
    time). Different tools and techniques have different tradeoffs, but the
    practical impact of these tradeoffs is not well understood. In this paper,
    we apply five bug finding tools, specifically Bandera, ESC/Java 2,
    FindBugs, JLint, and PMD, to a variety of Java programs. By using a variety
    of tools, we are able to cross-check their bug reports and warnings. Our
    experimental results show that none of the tools strictly subsumes another,
    and indeed the tools often find non-overlapping bugs. We discuss the
    techniques each of the tools is based on, and we suggest how particular
    techniques affect the output of the tools. Finally, we propose a meta-tool
    that combines the output of the tools together, looking for particular
    lines of code, methods, and classes that many tools warn about.",
}





@Book{GhezziJM91,
  author =       "Carlo Ghezzi and Mehdi Jazayeri and Dino Mandrioli",
  title =        "Fundamentals of Software Engineering",
  edition =      "1",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year =         "1991",
  ISBN =         "0-13-818204-3",
}


@Book{Lamb88,
  author =	 "David Alex Lamb",
  title = 	 "Software Engineering:  Planning for Change",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year = 	 1988
}

@Book{Sommerville:1996a,
  author =       "Ian Sommerville",
  title =        "Software Engineering",
  publisher =    "Addison-Wesley",
  year =         "1996",
  address =      "Wokingham, England",
  edition =      "Fifth",
}

@Book{Pressman92,
  author =	 "Roger S. Pressman",
  title = 	 "Software Engineering:  A Practitioner's Approach",
  publisher = 	 "McGraw-Hill",
  year = 	 1992,
  address =	 "New York",
  edition =	 "Third"
}




@InProceedings{VandevoordeG94,
  author =       "Mark T. Vandevoorde and John V. Guttag",
  title =        "Using specialized procedures and specification-based analysis
                  to reduce the runtime costs of modularity",
  booktitle =    "Symposium on the Foundations of Software Engineering",
  year =         1994,
  month =        dec
}

@InProceedings{KremenekAYE2004,
  author = 	 "Ted Kremenek and Ken Ashcraft and Junfeng Yang and Dawson Engler",
  title = 	 "Correlation exploitation in error ranking",
  crossref =     "FSE2004",
  pages = 	 "83--93",
}






@InProceedings{LivshitsZ2005,
  author = 	 "Benjamin Livshits and Thomas Zimmermann",
  title = 	 "{DynaMine}: Finding common error patterns by mining
                  software revision histories",
  crossref =     "FSE2005",
  pages =	 "296--305",
  abstract =
   "A great deal of attention has lately been given to addressing software
    bugs such as errors in operating system drivers or security bugs. However,
    there are many other lesser known errors specific to individual
    applications or APIs and these violations of application-specific coding
    rules are responsible for a multitude of errors. In this paper we propose
    DynaMine, a tool that analyzes source code check-ins to find highly
    correlated method calls as well as common bug fixes in order to
    automatically discover application-specific coding patterns. Potential
    patterns discovered through mining are passed to a dynamic analysis tool
    for validation; finally, the results of dynamic analysis are presented to
    the user.
    \par
    The combination of revision history mining and dynamic analysis techniques
    leveraged in DynaMine proves effective for both discovering new
    application-specific patterns and for finding errors when applied to very
    large applications with many man-years of development and debugging effort
    behind them. We have analyzed Eclipse and jEdit, two widely-used, mature,
    highly extensible applications consisting of more than 3,600,000 lines of
    code combined. By mining revision histories, we have discovered 56
    previously unknown, highly application-specific patterns. Out of these, 21
    were dynamically confirmed as very likely valid patterns and a total of 263
    pattern violations were found.",
}



@InProceedings{SullivanGSCSTR2005,
  author = 	 "Kevin Sullivan and William G. Griswold and Yuanyuan Song
                  and Yuanfang Cai and Macneil Shonle and Nishit Tewari and
                  Hridesh Rajan",
  title = 	 "Information hiding interfaces for aspect-oriented design",
  crossref =     "FSE2005",
  pages =	 "166--175",
}

@article{10.1016/j.infsof.2010.05.003,
author = {Ali, Muhammad Sarmad and Ali Babar, Muhammad and Chen, Lianping and Stol, Klaas-Jan},
title = {A systematic review of comparative evidence of aspect-oriented programming},
year = {2010},
issue_date = {September, 2010},
publisher = {Butterworth-Heinemann},
address = {USA},
volume = {52},
number = {9},
issn = {0950-5849},
url = {https://doi.org/10.1016/j.infsof.2010.05.003},
doi = {10.1016/j.infsof.2010.05.003},
abstract = {Context: Aspect-oriented programming (AOP) promises to improve many facets of software quality by providing better modularization and separation of concerns, which may have system wide affect. There have been numerous claims in favor and against AOP compared with traditional programming languages such as Objective Oriented and Structured Programming Languages. However, there has been no attempt to systematically review and report the available evidence in the literature to support the claims made in favor or against AOP compared with non-AOP approaches. Objective: This research aimed to systematically identify, analyze, and report the evidence published in the literature to support the claims made in favor or against AOP compared with non-AOP approaches. Method: We performed a systematic literature review of empirical studies of AOP based development, published in major software engineering journals and conference proceedings. Results: Our search strategy identified 3307 papers, of which 22 were identified as reporting empirical studies comparing AOP with non-AOP approaches. Based on the analysis of the data extracted from those 22 papers, our findings show that for performance, code size, modularity, and evolution related characteristics, a majority of the studies reported positive effects, a few studies reported insignificant effects, and no study reported negative effects; however, for cognition and language mechanism, negative effects were reported. Conclusion: AOP is likely to have positive effect on performance, code size, modularity, and evolution. However its effect on cognition and language mechanism is less likely to be positive. Care should be taken using AOP outside the context in which it has been validated.},
journal = {Inf. Softw. Technol.},
month = sep,
pages = {871–887},
numpages = {17},
keywords = {Aspect-oriented programming, Evidence-based software engineering, Systematic literature review}
}






@InProceedings{LiZ2005,
  author = 	 "Zhenmin Li and Yuanyuan Zhou",
  title = 	 "PR-Miner: automatically extracting implicit programming
                  rules and detecting violations in large software code",
  crossref =     "FSE2005",
  pages =	 "306--315",
  abstract =
   "Programs usually follow many \emph{implicit} programming rules, most of
    which are too tedious to be documented by programmers. When these rules are
    violated by programmers who are unaware of or forget about them, defects
    can be easily introduced. Therefore, it is highly desirable to have tools
    to automatically extract such rules and also to automatically detect
    violations. Previous work in this direction focuses on simple function-pair
    based programming rules and additionally requires programmers to provide
    rule templates.
    \par
    This paper proposes a \emph{general} method called PR-Miner that uses a
    data mining technique called frequent itemset mining to efficiently extract
    implicit programming rules from large software code written in an
    industrial programming language such as C, \emph{requiring little effort
    from programmers and no prior knowledge of the software}. Benefiting from
    frequent itemset mining, PR-Miner can extract programming rules in general
    forms (without being constrained by any fixed rule templates) that can
    contain multiple program elements of various types such as functions,
    variables and data types. In addition, we also propose an efficient
    algorithm to automatically detect violations to the extracted programming
    rules, which are strong indications of bugs.
    \par
    Our evaluation with large software code, including Linux, PostgreSQL Server
    and the Apache HTTP Server, with 84K--3M lines of code each, shows that
    PR-Miner can efficiently extract thousands of general programming rules and
    detect violations within 2 minutes. Moreover, PR-Miner has detected many
    violations to the extracted rules. Among the top 60 violations reported by
    PR-Miner, 16 have been confirmed as bugs in the \emph{latest version} of
    Linux, 6 in PostgreSQL and 1 in Apache. Most of them violate complex
    programming rules that contain more than 2 elements and are thereby
    difficult for previous tools to detect. We reported these bugs and they are
    currently being fixed by developers.",
}



@Book{Simon96,
  author = 	 "Herbert A. Simon",
  title = 	 "The Sciences of the Artificial",
  publisher = 	 "MIT Press",
  year = 	 1996,
  edition = 	 "Third",
}

@Book{Braude2003,
  author = 	 "Eric J. Braude",
  title = 	 "Software Design: From Programming to Architecture",
  publisher = 	 "Wiley",
  year = 	 2003,
}


@Book{Budgen2003,
  author = 	 "David Budgen",
  title = 	 "Software Design",
  publisher = 	 "Addison-Wesley",
  year = 	 2003,
}

@Book{Winograd1996,
  author = 	 "Terry Winograd",
  title = 	 "Bringing Design to Software",
  publisher = 	 "Addison-Wesley",
  year = 	 1996
}

@Book{CoplienS1995,
  author = 	 "James O. Coplien and Douglas C. Schmidt",
  title = 	 "Pattern Languages of Program Design",
  publisher = 	 "Addison-Wesley",
  year = 	 1995,
}

@Book{FelleisenFFK2001,
  author = 	 "Matthias Felleisen and Robert Bruce Findler and Matthew
                  Flatt and Shriram Krishnamurthi",
  title = 	 "How to Design Programs: An Introduction to Programming and Computing",
  publisher = 	 "MIT Press",
  year = 	 2001
}

@Book{CohoonD2005,
  author = 	 "James P. Cohoon and Jack W. Davidson ",
  title = 	 "Java 5.0 Program Design",
  publisher = 	 "McGraw-Hill",
  year = 	 2005,
}



@InProceedings{KuhnGG2005,
  author = 	 "Adrian Kuhn and Orla Greevy and Tudor G{\^\i}rba",
  title = 	 "Applying semantic analysis to feature execution traces",
  crossref =     "PCODA2005",
  pages = 	 "48--53",
  abstract =
   "Recently there has been a revival of interest in feature
    analysis of software systems. Approaches to feature location
    have used a wide range of techniques such as dynamic
    analysis, static analysis, information retrieval and formal
    concept analysis. In this paper we introduce a novel approach
    to analyze the execution traces of features using Latent
    Semantic Indexing (LSI). Our goal is twofold. On the
    one hand we detect similarities between features based on
    the content of their traces, and on the other hand we categorize
    classes based on the frequency of the outgoing invocations
    involved in the traces. We apply our approach on
    two case studies and we discuss its benefits and drawbacks.",
}



@Article{EisenbarthKS2003,
  author = 	 "T. Eisenbarth and R. Koschke and D. Simon",
  title = 	 "Locating Features in Source Code",
  journal = 	 computer,
  year = 	 2003,
  volume = 	 29,
  number = 	 3,
  pages = 	 "210--224",
  month = 	 mar,
}


@InProceedings{GreevyD2005,
  author = 	 "O. Greevy and St{\'e}phane Ducasse",
  title = 	 "Correlating features and code using a compact two-sided
                  trace analysis approach",
  crossref =     "CMSR2005",
  pages = 	 "314--323",
}


@InProceedings{GreevyDG2005,
  author = 	 "Orla Greevy and St{\'e}phane Ducasse and Tudor G{\^\i}rba",
  title = 	 "Analyzing feature traces to incorporate the semantics of
		  change in software evolution analysis",
  crossref =     "ICSM2005",
  pages = 	 "347--356",
}


@Article{WongGH2000,
  author = 	 "W. E. Wong and S. S. Gokhale and J. R. Horgan",
  title = 	 "Quantifying the closeness between program components and features",
  journal = 	 j-systems-and-software,
  year = 	 2000,
  volume = 	 54,
  number = 	 2,
  pages = 	 "87--98",
  month = 	 oct,
}


@InProceedings{ZaidmanCDP2005,
  author = 	 "Andy Zaidman and Toon Calders and Serge Demeyer and Jan Paredaens",
  title = 	 "Applying Webmining Techniques to Execution Traces to
                  Support the Program Comprehension Process",
  crossref =     "CMSR2005",
  pages = 	 "134--142",
  abstract =
   "Well-designed object-oriented programs typically consist
    of a few key classes that work tightly together to provide
    the bulk of the functionality. As such, these key classes are
    excellent starting points for the program comprehension
    process. We propose a technique that uses webmining
    principles on execution traces to discover these important
    and tightly interacting classes. Based on two medium-scale
    case studies --- Apache Ant and Jakarta JMeter --- and
    detailed architectural information from its developers, we
    show that our heuristic does in fact find a sizable number
    of the classes deemed important by the developers.",
}


@InProceedings{HaRDRCRW2007,
  author = 	 "Jungwoo Ha and Christopher J. Rossbach and Jason V. Davis and Indrajit Roy and David L. Chen and Hany E. Ramadan and Emmett Witchel",
  title = 	 "Improved error reporting for software that uses black-box components",
  crossref =     "PLDI2007",
  pages = 	 "101--111",
}



@InProceedings{XuRTQ2007,
  author = 	 "Guoqing Xu and Atanas Rountev and Yan Tang and Feng Qin",
  title = 	 "Efficient checkpointing of {Java} software using context-sensitive capture and replay",
  crossref =     "FSE2007",
  pages = 	 "85--94",
}



@InProceedings{DwyerKE2007,
  author = 	 "Matthew B. Dwyer and Alex Kinneer and Sebastian Elbaum",
  title = 	 "Adaptive Online Program Analysis",
  crossref =     "ICSE2007",
  pages = 	 "220--229",
}







@InProceedings{KoM2008,
  author = 	 "Andrew J. Ko and Brad A. Myers",
  title = 	 "Debugging reinvented: Asking and answering why and why not questions about program behavior",
  crossref =     "ICSE2008",
  pages = 	 "301--310",
}







@Book{IEEE-610.12-1990,
  editor = 	 "Jane Radatz",
  title = 	 "IEEE Std 610.12-1990 IEEE Standard Glossary of Software Engineering Terminology",
  publisher = 	 "IEEE Computer Society",
  year = 	 1990,
  month = 	 sep # "~28,",
  abstract =
   "Describes the IEEE Std 610.12-1990, IEEE standard glossary of software
   engineering terminology, which identifies terms currently in use in the
   field of software engineering. Standard definitions for those terms are
   established.",
}


@InProceedings{Cook2009,
  author = 	 "Cook, William R.",
  title = 	 "On understanding data abstraction, revisited",
  crossref =     "OOPSLACompanion2009",
  pages = 	 "557--572",
}





@InProceedings{JeongKZ2009,
  author = 	 "Jeong, Gaeul and Kim, Sunghun and Zimmermann, Thomas",
  title = 	 "Improving bug triage with bug tossing graphs",
  crossref =     "FSE2009",
  pages = 	 "111--120",
}


@Article{WalradS2002,
  author = 	 "Walrad, Chuck and Strom, Darrel",
  title = 	 "The Importance of Branching Models in {SCM}",
  journal = 	 "Computer",
  year = 	 2002,
  volume = 	 35,
  number = 	 9,
  pages = 	 "31--38",
  month = 	 sep,
}

@InProceedings{NagappanBZ2006,
  author = 	 "Nagappan, Nachiappan and Ball, Thomas and Zeller, Andreas",
  title = 	 "Mining metrics to predict component failures",
  crossref =     "ICSE2006",
  pages = 	 "452--461",
}




@InProceedings{BaconCPR2009,
  author = 	 "Bacon, David F. and Chen, Yiling and Parkes, David and Rao, Malvika",
  title = 	 "A market-based approach to software evolution",
  crossref =     "OOPSLACompanion2009",
  pages = 	 "973--980",
  doi = {https://doi.acm.org/10.1145/1639950.1640066},
}


@Article{Sakthivel2007,
  author = 	 "Sakthivel, S.",
  title = 	 "Managing risk in offshore systems development",
  journal = 	 CACM,
  year = 	 2007,
  volume = 	 50,
  number = 	 4,
  pages = 	 "69--75",
  month = 	 apr,
  doi = {https://doi.acm.org/10.1145/1232743.1232750},
}


@InProceedings{FritzM2010,
  author = 	 "Fritz, Thomas and Murphy, Gail C.",
  title = 	 "Using information fragments to answer the questions developers ask",
  crossref =     "ICSE2010",
  pages = 	 "175--184",
}






@Article{Norman90,
  author = 	 "Donald A. Norman",
  title = 	 "The ``Problem'' with automation: Inappropriate feedback and interaction, not ``over-automation''",
  journal = 	 PTRSLB,
  year = 	 1990,
  volume = 	 327,
  number = 	 1241,
  pages = 	 "585--593",
}









@InProceedings{ChangYM2010,
  author = 	 "Chang, Tsung-Hsiang and Yeh, Tom and Miller, Robert C.",
  title = 	 "{GUI} Testing Using Computer Vision",
  crossref =     "CHI2010",
  pages = 	 "1535--1544",
}















































@InProceedings{MusluBM2015,
  author = 	 "K{\i}van\c{c} Mu{\c{s}}lu and Yuriy Brun and Alexandra Meliou",
  authorASCII =	 "Kivanc Muslu and Yuriy Brun and Alexandra Meliou",
  title = 	 "Preventing data errors with continuous testing",
  crossref =     "ISSTA2015",
  pages = 	 "373--384",
}

@InProceedings{MusluBM2013,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu and Yuriy Brun and Alexandra Meliou",
  authorASCII =	 "Kivanc Muslu and Yuriy Brun and Alexandra Meliou",
  title = 	 "Data debugging with continuous testing",
  crossref =     "FSE2013",
  pages = 	 "631--634",
  supersededby = "MusluBM2015",
}



@InProceedings{Muslu2013,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu",
  authorASCII =  "Kivanc Muslu",
  title = 	 "Integrating systematic exploration, analysis, and maintenance in software development",
  crossref =     "ICSE2013",
  pages = 	 "1389--1392",
}






@Article{Hoare1981,
  author = 	 "Charles Antony Richard Hoare",
  title = 	 "The emperor's old clothes",
  journal = 	 CACM,
  year = 	 1981,
  volume = 	 24,
  number = 	 2,
  pages = 	 "75--83",
  month = 	 feb,
}


@InProceedings{CaliskanIslamHLNVYG2015,
  author = 	 "Aylin Caliskan-Islam and Richard Harang and Andrew Liu and Arvind Narayanan and Clare Voss and Fabian Yamaguchi and Rachel Greenstadt",
  title = 	 "De-anonymizing programmers via code stylometry",
  crossref =     "USENIXSec2015",
  pages = 	 "255--270",
  abstract =
   "Source code authorship attribution is a significant privacy threat to
    anonymous code contributors. However, it may also enable attribution of
    successful attacks from code left behind on an infected system, or aid in
    resolving copyright, copyleft, and plagiarism issues in the programming
    fields. In this work, we investigate machine learning methods to
    de-anonymize source code authors of C/C++ using coding style. Our Code
    Stylometry Feature Set is a novel representation of coding style found in
    source code that reflects coding style from properties derived from
    abstract syntax trees.
    \par
    Our random forest and abstract syntax tree-based approach attributes more
    authors (1,600 and 250) with significantly higher accuracy (94\% and 98\%) on
    a larger data set (Google Code Jam) than has been previously
    achieved. Furthermore, these novel features are robust, difficult to
    obfuscate, and can be used in other programming languages, such as
    Python. We also find that (i) the code resulting from difficult programming
    tasks is easier to attribute than easier tasks and (ii) skilled programmers
    (who can complete the more difficult tasks) are easier to attribute than
    less skilled programmers.",
}











@InProceedings{MurphyHillZN2014,
  author = 	 "Emerson Murphy-Hill and Thomas Zimmermann and Nachiappan Nagappan",
  title = 	 "Cowboys, ankle sprains, and keepers of quality: How is video game development different from software development?",
  crossref =     "ICSE2014",
  pages = 	 "1--11",
}





@InProceedings{SeoSEAB2014,
  author =       "Hyunmin Seo and Caitlin Sadowski and Sebastian Elbaum and Edward Aftandilian and Robert Bowdidge",
  title =        "Programmers' build errors: A case study (at {Google})",
  crossref =     "ICSE2014",
  pages =     "724--734",
  abstract =
   "Building is an integral part of the software development
    process. However, little is known about the errors occurring in this
    process. In this paper, we present an empirical study of 26.6 million
    builds produced during a period of nine months by thousands of
    developers. We describe the workflow through which those builds are
    generated, and we analyze failure frequency, error types, and resolution
    efforts to fix those errors. The results provide insights on how a large
    organization build process works, and pinpoints errors for which further
    developer support would be most effective.",
}


@InProceedings{NarayananR2015,
  author =       "Krishna Narasimhan and Christoph Reichenbach",
  title =        "Copy and paste redeemed",
  crossref =     "ASE2015",
  pages =     "630-640",
}



@InProceedings{ChristakisMW2016,
  author =       "Maria Christakis and Peter M{\"u}ller and Valentin W{\"u}stholz",
  authorASCII =  "Maria Christakis and Peter Muller and Valentin Wustholz",
  authorASCII =  "Maria Christakis and Peter Mueller and Valentin Wuestholz",
  title =        "Guiding dynamic symbolic execution toward unverified program executions",
  crossref =     "ICSE2016",
  NEEDpages =     "*",
}


@inproceedings{Pham14,
 author = {Pham, Raphael and Kiesling, Stephan and Liskin, Olga and Singer, Leif and Schneider, Kurt},
 title = {Enablers, Inhibitors, and Perceptions of Testing in Novice Software Teams},
 booktitle = {ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE)},
 year = {2014},
 isbn = {978-1-4503-3056-5},
 address = {Hong Kong, China},
 pages = {30--40},
 doi = {10.1145/2635868.2635925},
}


@inproceedings{Kery:2016:EPP:2901739.2903497,
 author = {Kery, Mary Beth and Le Goues, Claire and Myers, Brad A.},
 title = {Examining Programmer Practices for Locally Handling Exceptions},
 booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories},
 series = {MSR '16},
 year = {2016},
 isbn = {978-1-4503-4186-8},
 address  = {Austin, Texas},
 pages = {484--487},
 numpages = {4},
 url = {https://doi.acm.org/10.1145/2901739.2903497},
 doi = {10.1145/2901739.2903497},
 acmid = {2903497},
 keywords = {Boa, GitHub, Java exceptions, error handlers},
}

@inproceedings{Nakshatri:2016:AEH:2901739.2903499,
 author = {Nakshatri, Suman and Hegde, Maithri and Thandra, Sahithi},
 title = {Analysis of Exception Handling Patterns in Java Projects: An Empirical Study},
 booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories},
 series = {MSR '16},
 year = {2016},
 isbn = {978-1-4503-4186-8},
 address  = {Austin, Texas},
 pages = {500--503},
 numpages = {4},
 url = {https://doi.acm.org/10.1145/2901739.2903499},
 doi = {10.1145/2901739.2903499},
 acmid = {2903499},
 keywords = {Boa, GitHub, Java exception handling, best practices},
}



@InProceedings{GousiosSB2016,
  author =       "Gousios, Georgios and Storey, Margaret-Anne and Bacchelli, Alberto",
  title =        "Work practices and challenges in pull-based development:  the contributor's perspective",
  crossref =     "ICSE2016",
  pages =     "285--296",
}









@InProceedings{DeweyNH2015,
  author =       "Dewey, Kyle and Nichols, Lawton and Hardekopf, Ben",
  title =        "Automated data structure generation: Refuting common wisdom",
  crossref =     "ICSE2015",
  pages =     "32--43",
}


@InProceedings{YangXLCML2014,
  author =       "Yang, Wenhua and Xu, Chang and Liu, Yepang and Cao, Chun and Ma, Xiaoxing and Lu, Jian",
  title =        "Verifying Self-adaptive Applications Suffering Uncertainty",
  crossref =     "ASE2014",
  pages =     "199--210",
}


@InProceedings{MadsenTASM2016,
  author =       "Madsen, Magnus and Tip, Frank and Andreasen, Esben and Sen, Koushik and M{\o}ller, Anders",
  authorASCII =       "Madsen, Magnus and Tip, Frank and Andreasen, Esben and Sen, Koushik and Moller, Anders",
  title =        "Feedback-directed instrumentation for deployed {JavaScript} applications",
  crossref =     "ICSE2016",
  pages =     "899--910",
}


@article{Apel:2013:FDB:2508267.2508296,
 author = {Apel, Sven and Von Rhein, Alexander and Th\"{u}m, Thomas and K\"{a}stner, Christian},
 authorASCII = {Apel, Sven and Von Rhein, Alexander and Thum, Thomas and Kastner, Christian},
 title = {Feature-interaction detection based on feature-based specifications},
 journal = {Comput. Netw.},
 issue_date = {August, 2013},
 volume = {57},
 number = {12},
 month = aug,
 year = {2013},
 issn = {1389-1286},
 pages = {2399--2409},
 numpages = {11},
 url = {http://dx.doi.org/10.1016/j.comnet.2013.02.025},
 doi = {10.1016/j.comnet.2013.02.025},
 acmid = {2508296},
 publisher = {Elsevier North-Holland, Inc.},
 address = {New York, NY, USA},
 keywords = {Feature interaction, Feature orientation, Feature-based specification, Modularity, Software product lines},
}


@inproceedings{Johnson:2016:CCS:2950290.2950304,
 author = {Johnson, Brittany and Pandita, Rahul and Smith, Justin and Ford, Denae and Elder, Sarah and Murphy-Hill, Emerson and Heckman, Sarah and Sadowski, Caitlin},
 title = {A Cross-tool Communication Study on Program Analysis Tool Notifications},
 booktitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
 series = {FSE 2016},
 year = {2016},
 isbn = {978-1-4503-4218-6},
 address  = {Seattle, WA, USA},
 pages = {73--84},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/2950290.2950304},
 doi = {10.1145/2950290.2950304},
 acmid = {2950304},
 keywords = {communication, human factors, program analysis tools},
}



@InProceedings{BarrettKMHTP2004,
  author =       "Barrett, Rob and Kandogan, Eser and Maglio, Paul P. and Haber, Eben M. and Takayama, Leila A. and Prabaker, Madhu",
  title =        "Field studies of computer system administrators: Analysis of system management tools and practices",
  crossref =     "CSCW2004",
  pages =     "388--395",
}

@InProceedings{HentschelHB2016,
  author = 	 "Hentschel, Martin and H{\"a}hnle, Reiner and Bubel, Richard",
  authorASCII =  "Hentschel, Martin and Hahnle, Reiner and Bubel, Richard",
  title = 	 "An empirical evaluation of two user interfaces of an interactive program verifier",
  crossref =  "ASE2016",
  pages = 	 "403--413",
}








@InProceedings{GoffiGMPT2014,
  author = 	 "Goffi, Alberto and Gorla, Alessandra and Mattavelli, Andrea and Pezz{\`e}, Mauro and Tonella, Paolo",
  title = 	 "Search-based synthesis of equivalent method sequences",
  crossref =  "FSE2014",
  pages = 	 "366--376",
}


@inproceedings{Gopstein:2017:UMS:3106237.3106264,
 author = {Gopstein, Dan and Iannacone, Jake and Yan, Yu and DeLong, Lois and Zhuang, Yanyan and Yeh, Martin K.-C. and Cappos, Justin},
 title = {Understanding Misunderstandings in Source Code},
 booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
 series = {ESEC/FSE 2017},
 year = {2017},
 isbn = {978-1-4503-5105-8},
 location = {Paderborn, Germany},
 pages = {129--139},
 numpages = {11},
 url = {https://doi.acm.org/10.1145/3106237.3106264},
 doi = {10.1145/3106237.3106264},
 acmid = {3106264},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Program Understanding, Programming Languages},
}


@InProceedings{DiFranceGRG2017,
  author = 	 "Di Franco, Anthony and Guo, Hui and Rubio-Gonz\'{a}lez, Cindy",
  authorASCII = 	 "Di Franco, Anthony and Guo, Hui and Rubio-Gonzalez, Cindy",
  title = 	 "A comprehensive study of real-world numerical bug characteristics",
  crossref =  "ASE2017",
  pages = 	 "509-519",
}






@InProceedings{ArcuriB2011,
  author = 	 "Arcuri, Andrea and Briand, Lionel",
  title = 	 "A practical guide for using statistical tests to assess randomized algorithms in software engineering",
  crossref =  "ICSE2011",
  pages = 	 "1--10",
}


@InProceedings{ReyesDFJ2018,
  author = 	 "Reyes, Rolando P. and Dieste, Oscar and Fonseca, Efra\'{\i}n R. and Juristo, Natalia",
  title = 	 "Statistical errors in software engineering experiments: A preliminary literature review",
  crossref =  "ICSE2018",
  pages = 	 "1195--1206",
}









@InProceedings{GilR2019,
  author = 	 "Yossi Gil and Ori Roth",
  title = 	 "Fling --- A fluent {API} generator",
  crossref =  "ECOOP2019",
  pages = 	 "13:1--13:25",
}


@Book{McConnell:1993:CCP,
  author =       "Steve McConnell",
  title =        "Code complete:  A practical handbook of software
                 construction",
  publisher =    "Microsoft Press",
  address =      "Redmond, WA, USA",
  year =         1993,
  ISBN =         "1-55615-484-4",
  LCCN =         "QA76.76.D47 M39 1993",
  bibdate =      "Sat Aug 31 09:15:22 MDT 1996",
  price =        "US\$35.00, CDN\$47.95",
  keywords =     "computer software -- development -- handbooks,
                 manuals, etc",
}

@Book{McConnell2004,
  author =       "Steve McConnell",
  title =        "Code complete:  A practical handbook of software
                 construction",
  publisher =    "Microsoft Press",
  address =      "Redmond, WA, USA",
  year =         2004,
  ISBN =         "0-7356-1967-0",
  edition = 	 "2nd",
}


@Article{Iverson1980,
  author = 	 "Iverson, Kenneth E.",
  title = 	 "Notation as a tool of thought",
  journal = 	 CACM,
  year = 	 1930,
  volume = 	 23,
  number = 	 8,
  pages = 	 "444-465",
  month = 	 aug,
}




@Article{SadowskiAEMCJ2018,
  author = 	 "Sadowski, Caitlin and Aftandilian, Edward and Eagle, Alex and Miller-Cushon, Liam and Jaspan, Ciera",
  title = 	 "Lessons from building static analysis tools at {Google}",
  journal = 	 CACM,
  year = 	 2018,
  volume = 	 61,
  number = 	 4,
  pages = 	 "58-66",
  month = 	 mar,
}


@inproceedings{10.1109/ICSE.2019.00067,
author = {Ghorbani, Negar and Garcia, Joshua and Malek, Sam},
title = {Detection and Repair of Architectural Inconsistencies in Java},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ICSE.2019.00067},
doi = {10.1109/ICSE.2019.00067},
booktitle = {Proceedings of the 41st International Conference on Software Engineering},
pages = {560-571},
numpages = {12},
location = {Montreal, Quebec, Canada},
series = {ICSE ’19}
}




@InProceedings{QiuNBSV2019,
  author = 	 "Qiu, Huilian Sophie and Nolte, Alexander and Brown, Anita and Serebrenik, Alexander and Vasilescu, Bogdan",
  title = 	 "Going farther together: The impact of social capital on sustained participation in open source",
  crossref =  "ICSE2019",
  pages = 	 "688-699",
}







@Book{Booch1991,
  author = 	 "Booch, Grady",
  title = 	 "Object Oriented Design with Applications",
  publisher = 	 "Benjamin/Cummings",
  year = 	 "1991",
}


























@InProceedings{LoreyRF2022,
  author = 	 "Lorey, Tobias and Ralph, Paul and Felderer, Michael",
  title = 	 "Social science theories in software engineering research",
  crossref =  "ICSE2022",
  pages = 	 "1994–2005",
}




@InProceedings{SrinivasanR2014,
  author = 	 "Srinivasan, Venkatesh and Reps, Thomas",
  title = 	 "Recovery of class hierarchies and composition relationships from machine code",
  crossref =  "CC2014",
  pages = 	 "61--84",
  abstract =
   "We present a reverse-engineering tool, called Lego, which
    recovers class hierarchies and composition relationships from
    stripped binaries. Lego takes a stripped binary as input, and uses
    information obtained from dynamic analysis to (i) group the
    functions in the binary into classes, and (ii) identify
    inheritance and composition relationships between the inferred
    classes. The software artifacts recovered by Lego can be
    subsequently used to understand the object-oriented design of
    software systems that lack documentation and source code, e.g., to
    enable interoperability. Our experiments show that the class
    hierarchies recovered by Lego have a high degree of
    agreement---measured in terms of precision and recall---with the
    hierarchy defined in the source code.",
}











@InProceedings{Weimer2006,
  author = 	 "Weimer, Westley",
  title = 	 "Patches as Better Bug Reports",
  crossref =  "GPCE2006",
  pages = 	 "181-190",
}




@Misc{ErrorProneTool,
  author = 	 "Google",
  title = 	 "Error Prone",
  howpublished = "\url{https://errorprone.info/}",
  month = 	 jan,
  year = 	 2018,
}






@InProceedings{ZhangXZLXZ2024,
  author = 	 "Zejun Zhang and Zhenchang Xing and Dehai Zhao and Qinghua Lu and Xiwei Xu and Liming Zhu",
  title = 	 "Hard to Read and Understand {Pythonic} Idioms? {DeIdiom} and Explain Them in Non-Idiomatic Equivalent Code",
  crossref =  "ICSE2024",
  pages = 	 "1011-1011",
  abstract =
   "The Python community strives to design pythonic idioms so that Python users
    can achieve their intent in a more concise and efficient way. According to
    our analysis of 154 questions about challenges of understanding pythonic
    idioms on Stack Overflow, we find that Python users face various challenges
    in comprehending pythonic idioms. And the usage of pythonic idioms in 7,577
    GitHub projects reveals the prevalence of pythonic idioms. By using a
    statistical sampling method, we find pythonic idioms result in not only
    lexical conciseness but also the creation of variables and functions, which
    indicates it is not straightforward to map back to non-idiomatic code. And
    usage of pythonic idioms may even cause potential negative effects such as
    code redundancy, bugs and performance degradation. To alleviate such
    readability issues and negative effects, we develop a transforming tool,
    DeIdiom, to automatically transform idiomatic code into equivalent
    non-idiomatic code. We test and review over 7,572 idiomatic code instances
    of nine pythonic idioms (list/set/dict-comprehension, chain-comparison,
    truth-value-test, loop-else, assign-multi-targets, for-multi-targets, star),
    the result shows the high accuracy of DeIdiom. Our user study with 20
    participants demonstrates that explanatory non-idiomatic code generated by
    DeIdiom is useful for Python users to understand pythonic idioms correctly
    and efficiently, and leads to a more positive appreciation of pythonic
    idioms.",
}


@InProceedings{AsthanaSVAH2023,
  author = 	 "Asthana, Sumit and Sajnani, Hitesh and Voyloshnikova, Elena and Acharya, Birendra and Herzig, Kim",
  title = 	 "A case study of developer bots: motivations, perceptions, and challenges",
  crossref =  "FSE2023",
  pages = 	 "1268-1280",
}



@InProceedings{PertsevaCZC2024,
  author = 	 "Pertseva, Elizaveta and Chang, Melinda and Zaman, Ulia and Coblenz, Michael",
  title = 	 "A theory of scientific programming efficacy",
  crossref =  "ICSE2024",
  NEEDpages = 	 "*",
}


@INPROCEEDINGS{1046334,
  author={Blackwell, A.F.},
  booktitle={Proceedings IEEE 2002 Symposia on Human Centric Computing Languages and Environments},
  title={First steps in programming: a rationale for attention investment models},
  year={2002},
  volume={},
  number={},
  pages={2-10},
  keywords={Investments;Programming profession;Mathematical programming;Psychology;Books;Humans;Laboratories;Microcomputers;Microprocessors;Electronic switching systems},
  doi={10.1109/HCC.2002.1046334}}
  I disagree with the paper's claim that "most [computer] programming deals with
problems that we would not now consider to be mathematical.", because there is
always a mathematical model that the program deals with.  The paper gives no
examples.
  The paper asks 3 questions.  I think the questions are in the wrong answer,
and thus lead to definitions that are not very useful.
 1. Who is a programmer?  "all computer users ought to be regarded as potential
programmers, whose tools differ only in their usability for that purpose".
 2. What is a programming language?  "almost all major software
applications could now be recognized as including programming languages".
 3. What is a programming activity? The paper answers that it's anything anyone
uses the term "programming" for, including programming a VCR, programming a
microwave, programming a car radio, or writing HTML.  This ignores the obvious
fact that "programming" is a homonym in English.
  That bit of wordplay about "programming" renders the paper useless for
thinking about computer programming in specific.  However, the paper is still
useful insofar as it applies to many or all intellectual tasks that humans
perform.  The paper could have given a useful definition such as "a program is
something that runs multiple times on different inputs", and then an editor
macro and a spreadsheet would count but HTML and the buttons pressed on a
microwave would not.
  The key idea of the paper is in paragraph 6:  "This paper asks instead what is
distinctive about the cognitive tasks involved in programming," The paper states
that the cognitive features of "programming" (i.e., any intellectual activity)
are "(a) loss of the benefits of direct manipulation and (b) introduction of
notational elements to represent abstraction", and (c) abstraction, or factoring
out repeated parts of a complex activity.  Even gestures, button presses, and
"linguistic and representational strategies" count as "notational elements".
  "The Attention Investment model is a decision-theoretic account of programming
behavior. It offers a cost/benefit analysis of abstraction use that allows us to
predict the circumstances in which users will choose to engage in programming
activities, as well as helping tool designers to facilitate users’ investment
decisions and reduce the risks associated with those decisions. As with any
decision theoretic account, this depends on the availability of some currency -
a measure according to which cost, risk, pay-off etc can be calculated and
compared."  The paper cites "earlier papers on attention investment", but I
guess those are not (capitalized) Attention Investment.  This model seems
high-level and glaringly obvious:  people do a risk-benefit analysis before
choosing their course of action, such as which financial instruments to invest
in, or whether to go to the hardware store to purchase a new tool or make do
with the tools in their toolbox.  Was this novel at the time?  Or novel as
applied to programming?
  They built a "model" of many agents doing a spell-correction task, with each
agent working at a different location.  (Two different actions are to do a
single edit, or to pop up a search-and-replace box to correct all instances of
the misspelling.)  I don't see what information this model conveys, except that
they achieved, via a multi-agent process, a result that they say reflects
unconscious decisions that human would take.  I don't see that the model enables
prediction or yields insight.
  The paper is twice as long as it needs to be, due to waffling generalities.

@article{doi:10.1080/13639080020028747,
author = {Yrjö Engeström},
title = {Expansive Learning at Work: Toward an activity theoretical reconceptualization},
journal = {Journal of Education and Work},
volume = {14},
number = {1},
pages = {133--156},
year = {2001},
publisher = {Routledge},
doi = {10.1080/13639080020028747},
URL = {https://www.tandfonline.com/doi/abs/10.1080/13639080020028747},
eprint = {https://www.tandfonline.com/doi/pdf/10.1080/13639080020028747}
}






@Article{Perlow1999,
  author =       {Leslie A. Perlow},
  title =        {The Time Famine: Toward a Sociology of Work Time},
  journal =      {Administrative Science Quarterly},
  year =         1999,
  volume =    44,
  number =    1,
  pages =     {57-81},
  abstract =
  {This paper describes a qualitative study of how people use their time at
    work, why they use it this way, and whether their way of using time is
    optimal for them or their work groups. Results of a nine-month field study
    of the work practices of a software engineering team revealed that the
    group's collective use of time perpetuated its members' ``time famine,'' a
    feeling of having too much to do and not enough time to do it. Engineers had
    difficulty getting their individual work done because they were constantly
    interrupted by others. A crisis mentality and a reward system based on
    individual heroics perpetuated this disruptive way of interacting. Altering
    the way software engineers used their time at work, however, enhanced their
    collective productivity. This research points toward a “sociology of work
    time,” a framework integrating individuals' interdependent work patterns and
    the larger social and temporal contexts. The theoretical and practical
    implications of a sociology of work time are explored.},
}


@article{10.1145/3720421,
author = {Cohen, Sam and Chugh, Ravi},
title = {Code Style Sheets: CSS for Code},
year = {2025},
issue_date = {April 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3720421},
doi = {10.1145/3720421},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {87},
numpages = {29},
keywords = {CSS, Code Style Sheets, Haskell, Structure Editors, Text Layout}
}



@Article{Knuth74,
  author =       {Knuth, Donald E.},
  title =        {Computer programming as an art},
  journal =      cacm,
  year =         {1974},
  OPTkey =       {},
  OPTvolume =    {17},
  OPTnumber =    {12},
  OPTpages =     {667-673},
  OPTmonth =     dec,
  OPTnote =      {},
  OPTannote =    {},
  OPTdoi =       {},
  OPTabstract =  {When Communications of the ACM began publication in 1959, the members of ACM's Editorial Board made the following remark as they described the purposes of ACM's periodicals [2]: “If computer programming is to become an important part of computer research and development, a transition of programming from an art to a disciplined science must be effected.” Such a goal has been a continually recurring theme during the ensuing years; for example, we read in 1970 of the “first steps toward transforming the art of programming into a science” [26]. Meanwhile we have actually succeeded in making our discipline a science, and in a remarkably simple way: merely by deciding to call it “computer science.”},
  OPTusesDaikon = {},
  OPTusesDaikonAsTestSubject = {},
  OPTomitfromcv = {},
  OPTunderreview = {},
  OPTbasefilename = {},
  OPTdownloads = {},
  OPTdownloadsnonlocal = {},
  OPTsupersededby = {},
  OPTcategory =  {},
  OPTsummary =   {},
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LocalWords Dictionary
%%%

% LocalWords: GhezziJM Ghezzi Mehdi Jazayeri Mandrioli NJ ISBN Belady BasitRJ Xu
% LocalWords: Sommerville Wokingham InProceedings VandevoordeG Guttag Hamid STL
% LocalWords: Vandevoorde booktitle dec StreckenbachS Mirko Gregor al Basit XVCL
% LocalWords: Streckenbach Snelting KABA addr Kataoka ICSM KataokaEGN Damith TSE
% LocalWords: Kataoka's Kremenek Ashcraft Junfeng Engler FSE KremenekAYE ErnstBN
% LocalWords: Rajapakse Jarzabek NEEDpages CCFinder HenkelD Henkel Bod Balzer
% LocalWords: Amer Diwan CatchUp BCELMethod MandelinXBK Mandelin Bodik Cheatham
% LocalWords: Rastislav Kimmelman authorSEARCHABLE Jungloid jungloid SW Boehm
% LocalWords: jungloids composable int TRW's jul BalzerCG nov sep Walkthroughs
% LocalWords: TechReport UWCSE OPTkey UWCSEaddr aug Opdyke CC MensT XP BasitJ
% LocalWords: Tourw feb Tourwe Misc Borland howpublished JavaOne jun Robillard
% LocalWords: ChowN Kingsum ObjectWindows widenings datapoints RutarAF Livshits
% LocalWords: Rutar Almazan JLint PMD KimSNM Miryung dnsjava higo ist LivshitsZ
% LocalWords: Vibha Sazawal osaka ac jp ISSRE Bandera ESC overclaim co DynaMine
% LocalWords: asitJ Itemset FIM IDs MayrandLM tokenization java Zimmermann baz
% LocalWords: OpenMBeanAttributeInfoSpport ObjectFactory jEdit checkins itemset
% LocalWords: OpenMBeanParameterInfoSpport Apriori checkin SullivanGSCSTR Cai
% LocalWords: Yuanyuan Yuanfang Macneil Shonle Nishit Tewari Hridesh LiZ Zhou
% LocalWords: Rajan un AspectJ Zhenmin PR PostgreSQL HTTP Engler's FireWire rba
% LocalWords: FindBugs Braude Budgen CoplienS Coplien FelleisenFFK Orla IEEE UI
% LocalWords: Felleisen Findler CohoonD Cohoon KuhnGG Greevy PCODA LSI Urbana
% LocalWords: Taghi Khoshgoftaar Ruqun Shan Faundez Sekirkin Boland MMR Mens QA
% LocalWords: EisenbarthKS Eisenbarth Koschke GreevyD phane Ducasse oct APIs Ko
% LocalWords: CMSR GreevyDG WongGH Gokhale Horgan ZaidmanCDP Zaidman Champaign
% LocalWords: Toon Calders Demeyer Paredaens Webmining webmining JMeter Parnin
% LocalWords: Kleinberg's HaRDRCRW Jungwoo Rossbach Indrajit Hany Inlining DOI
% LocalWords: Witchel Borland's authorASCII MurphyHillPB toolsmiths downcasting
% LocalWords:  refactorable Englewood McGraw subsequences getters checkable Yan
% LocalWords:  Winograd ApiwattanapongOH Taweesup Apiwattanapong supersededby
% LocalWords:  ASEjournal JDiff usesDaikonAsTestSubject JABA XuRTQ Guoqing Feng
% LocalWords:  Atanas Rountev Qin checkpointed DwyerKE Dwyer Kinneer Elbaum KoM
% LocalWords:  optimizine FSAs Emre AjaxScope Kiciman SOSP redeployabiliy Manos
% LocalWords:  Whyline timeline JFrame prefast JonesH totalpassed totalfailed
% LocalWords:  RenierisR Renieris Reiss iComment Gopal Radatz issn doi ADT isbn
% LocalWords:  JeongKZ Jeong Gaeul Sunghun WalradS Walrad Strom SCM BallKPS Siy
% LocalWords:  NagappanBZ Nagappan Nachiappan Rochkind IEEETSE SCCS BaconCPR LD
% LocalWords:  Yiling Parkes Rao Malvika Sakthivel CACM apr FritzM subtable csv
% LocalWords:  DSketch Cossette ApelLBLK2011 Apel Jorg Liebig Brandl Lengauer
% LocalWords:  Putnam78 BalzerCG83 Kastner Semistructured FSE2011 FSE2011addr
% LocalWords:  FSE2011date semistructured FSTGENERATOR FSTMERGE Boehm87 Su NPEs
% LocalWords:  top10 Griswold91 Opdyke92 Fowler2000 Parr94 CC94 CC94addr ICSM96
% LocalWords:  CC94date MensT2004 StreckenbachS2004 OOPSLA2004 OOPSLA2004addr
% LocalWords:  OOPSLA2004date KataokaEGN01 HenkelD2005 ICSE2005 ICSE2005addr ek
% LocalWords:  ICSE2005date Perkins2005 MurphyHillPB2009 ICSE2009 ICSE2009addr
% LocalWords:  ICSE2009date researchers' Borland2004 ChowN96 ICSM96addr FSE2005
% LocalWords:  ICSM96date MandelinXBK2005 PLDI2005 PLDI2005addr PLDI2005date AO
% LocalWords:  RutarAF2004 ISSRE2004 ISSRE2004addr ISSRE2004date tradeoffs NPE
% LocalWords:  KimSNM2005 FSE2005addr FSE2005date GhezziJM91 Lamb88 Erlikh SNK
% LocalWords:  Pressman92 VandevoordeG94 runtime KremenekAYE2004 FSE2004 Przyby
% LocalWords:  FSE2004addr FSE2004date BasitRJ2005 parameterization ErnstBN2002
% LocalWords:  BasitJ2005 Baker95 MayrandLM96 dependences LivshitsZ2005 AOP OOP
% LocalWords:  SullivanGSCSTR2005 Przybylek2011 Przybylek FASE2011 FASE2011addr
% LocalWords:  FASE2011date modularizing modularizable modularized refactored
% LocalWords:  LOC LCOM OO LiZ2005 Simon96 Braude2003 Budgen2003 KuhnGG2005 SRC
% LocalWords:  Winograd1996 CoplienS1995 FelleisenFFK2001 CohoonD2005 PCODA2005
% LocalWords:  PCODA2005addr PCODA2005date dimensionality ISSRE'00 GreevyD2005
% LocalWords:  EisenbarthKS2003 CMSR2005 CMSR2005addr CMSR2005date GreevyDG2005
% LocalWords:  ICSM2005 ICSM2005addr ICSM2005date WongGH2000 ZaidmanCDP2005 ASE
% LocalWords:  HaRDRCRW2007 PLDI2007 PLDI2007addr PLDI2007date backtrace Orso
% LocalWords:  unscalable LaTeX's ApiwattanapongOH2004 Alessandro Harrold Kamei
% LocalWords:  differencing ASE2004 ASE2004addr ASE2004date XuRTQ2007 FSE2007
% LocalWords:  ApiwattanapongOH2007 checkpointing FSE2007addr FSE2007date Ko Ko
% LocalWords:  DwyerKE2007 ICSE2007 ICSE2007addr ICSE2007date KoM2008 ICSE2008
% LocalWords:  ICSE2008addr ICSE2008date Weise's JonesH2005 ASE2005 ASE2005addr
% LocalWords:  ASE2005date RenierisR2003 unexamined NLP OOPSLA2009 Ko Ko Yutaro
% LocalWords:  OOPSLA2009companion OOPSLA2009date Downcasts equational AWT INIT
% LocalWords:  downcasts Cook2009 OOPSLA2009addr Brooks1975 JeongKZ2009 FSE2009
% LocalWords:  FSE2009addr FSE2009date WalradS2002 BallKPS97 ICSE97addr Zeller
% LocalWords:  ICSE97date NagappanBZ2006 Andreas ICSE2006 ICSE2006addr ICSE2010
% LocalWords:  ICSE2006date Rochkind75 BaconCPR2009 Sakthivel2007 FritzM2010 Ko
% LocalWords:  ICSE2010addr ICSE2010date panopticon Norman90 PTRSLB Khaled El
% LocalWords:  Emam Saida Benlarbi Nishith Goel Shesh Rai rg stner ost Bj orn
% LocalWords:  Regnell Claes Wohlin Runeson PSP Pankratius Scala Goues Vogt Yeh
% LocalWords:  LeGouesDVFW2012 Weimer Westley ICSE2012 ICSE2012addr Tsung Roehm
% LocalWords:  ICSE2012date Hsiang Sikuli filenames Tobias Tiarks Rainer Walid
% LocalWords:  Maalej I2 Erlikh2000 Eastwood1993 Moad1990 Moad AFIPS Abreu ś18
% LocalWords:  LientzS1981 Lientz Bennet ZelkowitzSG1979 Zelkowitz COCOMO Cok
% LocalWords:  Seacord Plakosh McConnell2006 Jones2011 Su2006 ParninO2011 RAC
% LocalWords:  ISSTA2011 ISSTA2011date ISSTA2011addr Tetris NanoXML Rui Kazuki
% LocalWords:  ASE2003 ASE2003date ASE2003addr SteimannFA2013 Steimann T1 Kang
% LocalWords:  Frenkel locators ISSTA2013 ISSTA2013date ISSTA2013addr Yoo Choi
% LocalWords:  ZhangZK2013 Lingming Khurshid Sarfraz OOPSLA2013 Stasko P' BAPP
% LocalWords:  OOPSLA2013date OOPSLA2013addr JonesHS2002 ICSE2002 DBLP T2 kPAR
% LocalWords:  ICSE2002date ICSE2002addr YooNH2011 optimisation Dstar n11 TBar
% LocalWords:  n10 n01 DiGiuseppeJ2015 DiGiuseppe JEmpiricalSE Foo Omesh Aleti
% LocalWords:  SanthiarPK2014 Santhiar Anirudh Pandita Kanade Aditya tmp Karri
% LocalWords:  normf DoubleMatrix norm2 inv SimpleMatrix T3 mult Ghafari Dolan
% LocalWords:  GhafariGMT2014 Mocci Tamburrelli ICPC2014 ICPC2014date Pmd Luan
% LocalWords:  ICPC2014addr Rahman Khatri Devanbu Jlint foo Przybyłek Vo SeAPR
% LocalWords:  Jlint TanYKZ2007 SOSP2007 SOSP2007date SOSP2007addr JB10 Matias
% LocalWords:  Garretón GenProg Schulte DiLorenzo ASPLOS'13 ClearView Vu Kells
% LocalWords:  segfault underperforms ChangYM2010 CHI2010 CHI2010date Jne conf
% LocalWords:  CHI2010addr inproceedings Jalbert Proc Zhendong POPL'13 QP UIST
% LocalWords:  bessel asympx GSL Arjun Guha ReitBlatt OpenFlow NetCore lu json
% LocalWords:  ICSE'05 LaToza learnability JohnsonSMHB2013 Yoonki PREfix Rafal
% LocalWords:  Bowdidge ICSE2013 ICSE2013date ICSE2013addr BushPS2000 Zou Eval
% LocalWords:  Gorla Corapi Magee Katsumi Inoue NoMPRoL D'Ippolito Khomh Vesna
% LocalWords:  Braberman Foutse Dhaliwal Tejinder Ying numpages url acmid Theo
% LocalWords:  Piscataway Mika antyl Emelie Engstr RRs TRs Jiaping GMA de Ko Ko
% LocalWords:  Mcilroy dex2jar ASM regexes recharg batt ery RQ1 radaee af Ko
% LocalWords:  pdf Sonal Mahajan ICST PID mockups Fogarty's Huyen OLED rn Lorge
% LocalWords:  Smartphones smartphones Nyx Julien IoT cloudlets cloudlet Bowes
% LocalWords:  PDS multihop metadata Nirmalya Archan Misra Sajal Das Jit Fixie
% LocalWords:  Biswas PerCom QoINF QoINFs MusluBM2015 Meliou ISSTA2015 Ay Madey
% LocalWords:  ISSTA2015date ISSTA2015addr MusluBM2013 FSE2013 Nachi Liu Saini
% LocalWords:  FSE2013date FSE2013addr MusluBNC2014 Jacek Czerwonka Hoare
% LocalWords:  ICSE2014 ICSE2014date ICSE2014addr Muslu2013 LoNZ2015 Voss
% LocalWords:  FSE2015 FSE2015date FSE2015addr Hoare1981 Aylin Caliskan Pearce
% LocalWords:  CaliskanIslamHLNVYG2015 Harang Narayanan Yamaguchi Palyart
% LocalWords:  Greenstadt anonymizing stylometry USENIXSec2015 copyleft Ramesh
% LocalWords:  USENIXSec2015date USENIXSec2015addr anonymize NIER UMass Gavitt
% LocalWords:  anonymization Einar Høst Bjarte Østvold containsField Jin Baldi
% LocalWords:  findField getField Tianyin Xuepeng Shankar Pasupathy Rukma
% LocalWords:  Talwadker FlexJava Jongse Hadi Esmaeilzadeh Xin Mayur Naik
% LocalWords:  EnerJ Bornholt Stolee MurphyHillZN2014 Bixie Philipp ummer
% LocalWords:  Schaf Ruemmer Schaef Joa Shuvendu Lahiri ClusterChanges Qi
% LocalWords:  Estler Nordio Furia Wenhua Yepang Chun Cao Xioxing Jian AE
% LocalWords:  LDA ESEM HostRW2000 Runeson2003 Keele SalmanTMJ2015 Iflaah
% LocalWords:  Salman Tosun Misirli Juristo Ayse ICSE2015 ICSE2015date E1
% LocalWords:  ICSE2015addr TLD TDD1 TDD2 Kitchenham Brereton judgement Kirbas
% LocalWords:  Spearman Linkman EBSE ICSE04 RQ2 RQ3 RQ4 Magne Jørgensen Serkan
% LocalWords:  Pretorius Rialette Niazi Softw Technol Butterworth Prem E2
% LocalWords:  Heinemann Zheng Rahmanet RenieresR2003 Tien Duy Grunske S1
% LocalWords:  SBFL Ochiai BrunE2004 jan Nath Domingos AAAI TFLMs Zichao NIfTI
% LocalWords:  QiLAR2015 Achour RSRepair SPR Hwei Hiroaki Yoshida Mukul Pagano
% LocalWords:  Prasad Abhik Roychoudhury CoREBench Ferdian Thung Chu libm
% LocalWords:  overfit TrpAutoRepair IntroClass overfits Jlint Daming Seo
% LocalWords:  Xinrui Yingfei Xiong glibc predictiveness SeoSEAB2014 Pex Latoza
% LocalWords:  Hyunmin NarayananR2015 Narasimhan Reichenbach ASE2015 DSE Parnas
% LocalWords:  ASE2015date ASE2015addr forego Clousot DSE's Christakis js
% LocalWords:  ChristakisMW2016 ller stholz undertested Jlint Wustholz ie
% LocalWords:  Wuestholz ICSE2016 ICSE2016date ICSE2016addr Matichuk Pham
% LocalWords:  MatichukMAJKS2015 Andronick Gerwin Pham14 Kiesling Liskin Perlow
% LocalWords:  Kery Nakshatri Suman Hegde Maithri Thandra Sahithi JDK's Nowack
% LocalWords:  InterruptedException GousiosSB2016 Gousios Georgios Storey
% LocalWords:  Bacchelli PRs Magnus Esben Andreasen Koushik Møller Ciera
% LocalWords:  Tricorder Jaspan Söderberg Xie SFL Kuo SBSE SSBSE Taehoon
% LocalWords:  Byeongcheol Kwak Yiru Jeon Bongsuk Yunho Moonzoo Hardekopf
% LocalWords:  DeweyNH2015 CLP rotateLeft AElem CElem Korat UDITA ASE2014
% LocalWords:  YangXLCML2014 Xiaoxing ASE2014date ASE2014addr Moller P5 blue''
% LocalWords:  MadsenTASM2016 CROWDIE Rosso untracking Gitless async von
% LocalWords:  Gitless's Rhein astner Aniruddh Lawrance behaviour favour
% LocalWords:  idealised localisation webserver Thum Comput Netw Elsevier
% LocalWords:  Rahul Denae Heckman EclEmma Bethmann Anja Leich Saake Andr
% LocalWords:  Brechmann Brodmann MIS LientzS ZelkowitzSG Gannon Yourdon
% LocalWords:  Papaccio crossref Productivities HostRW Bjorn SalmanTMJ RQ
% LocalWords:  Siegmund Tarvo Mockus Amritanshu Agrawal datapoint ParninO
% LocalWords:  hyperparameters SMOTUNED RenieresR SteimannFA Friedrich TF
% LocalWords:  ZhangZK JonesHS YooNH Nilsson Harman DiGiuseppeJ BrunE Xia
% LocalWords:  KochharXLL Kochhar Pavneet Shanping LongR Ren Jiang Xuan Hadeel
% LocalWords:  diffoscope wrt IDF RepLoc Guix LeGouesDVFW ASPLOS QiLAR JB
% LocalWords:  Overfitting overfitting TianR Tian Yuchi Baishakhi ErrDoc
% LocalWords:  ErroDoc Motwani Manish Sankaranarayanan Nopol SanthiarPK SimFix
% LocalWords:  GhafariGMT Giordano ICPC FASE OOPSLACompanion PMESSE CBCD
% LocalWords:  ApelLBLK ChangYM JohnsonSMHB BushPS Domenico Alessandra Yu
% LocalWords:  Uchitel Bram Kai Gui Mei Halfond dex wifi Payton Proximal
% LocalWords:  middleware datums MusluBM MusluBNC LoNZ USENIXSec Blanc Yi
% LocalWords:  CaliskanIslamHLNVYG Sadowski Likert MurphyHillZN SeoSEAB Farima
% LocalWords:  changesets Aftandilian NarayananR Christoph Kellogg's Hong
% LocalWords:  ChristakisMW MatichukMAJKS IOException SQLException Madsen
% LocalWords:  GousiosSB Anders Gogh Springer DeweyNH Lawton dequeue Shimizu
% LocalWords:  YangXLCML MadsenTASM Gunter BarrettKMHTP IEEESoftware Yasutaka
% LocalWords:  Kandogan Eser Maglio Takayama Prabaker Madhu CSCW XiongHSC
% LocalWords:  Hubaux Arnaud Czarnecki Krzysztof WhitakerCG OSDI WangPCZW
% LocalWords:  Platt Ruyun misconfiguration PeerPressure RabkinK Rabkin Yadong
% LocalWords:  Katz KellerUC Upadhyaya Prasang Candea ConfErr DSN Jie KeY
% LocalWords:  XiongZHSWC Hansheng HubauxXC eCos VaMoS HentschelHB hnle Hitesh
% LocalWords:  Hentschel Reiner Bubel Hahnle SED BuseW Buse Sainyam enums
% LocalWords:  Galhotra Themis GoffiGMPT Goffi Mattavelli Pezz Tonella Naoyasu
% LocalWords:  Paolo Gopstein Iannacone DeLong Zhuang Yanyan Cappos qwert
% LocalWords:  Paderborn Weimer's linter formatter DiFranceGRG Guo Rubio
% LocalWords:  Gonz lez Fiorella Zampetti Gabriele Bavota Massimiliano MyBatis
% LocalWords:  Penta Lanza Oliveto CoreNLP dev nd KochharXLL2016 sw Ubayashi
% LocalWords:  ISSTA2016 LongR2016 unreproducible TianR2017 FSE2017 ICSME2021
% LocalWords:  Motwani2017 Sandhya CodeCarbonCopy Stelios Sidiroglou linenumber
% LocalWords:  Douskos Lahtinen typeclass boolean PFInfo Property1 Kashiwa
% LocalWords:  Property2 SCST jfreechart jOcular Smalltalk evidence'' Aldeida
% LocalWords:  Tonder Rijnard FootPatch Infer's FootPatch's Amanj Hua analyse
% LocalWords:  Sherwany Nosheen Zaza Nystrom WongWQZ2008 Tingting Xue Durieux
% LocalWords:  Zhao crosstab ICST2008 Gothenburg FootPrint VFix Yulei Fernanda
% LocalWords:  Xuezheng LoreyRF2022 Lorey Felderer ICSE2022 Dwivedi AletiM2021
% LocalWords:  P16 P20 P17 P18 P19 KashiwaSLBLKU2021 Rachatasumrit predominator
% LocalWords:  RefactoringMiner visualises Madeiral tan2015relifix relifix
% LocalWords:  Baleegh Alamitos Amirfarhad Nilizadeh Sungmin Wonkeun unexecuted
% LocalWords:  KirbasWMKPSVWCBHHW2021 Windels Etienne McBello Olayori Szalanski
% LocalWords:  Counsell Haraldsson Saemundur Divide'' EldawyLGB2023 Eladawy
% LocalWords:  ICSE2024 Recoder SainiFLYMSBL2019 Vaibhav Farmahinifarahani
% LocalWords:  Sajnani ICSE2019 InspectorClone SimCad Alaboudi Abdulaziz Latoza
% LocalWords:  Hypothesizer articleno Latoza Hypothesizer's hypothesizer Latoza
% LocalWords:  onClick setState HelpMeOut LeeDM2006 Dourish CSCM2006 Berman2001
% LocalWords:  sensical Neuroimaging Noguera Kellens Deridder D'Hondt Flor
% LocalWords:  OOPSLACompanion2009 automation'' implementors verbalizations
% LocalWords:  GenProg's RibesL2010 Ribes Sociotechnical JCSCW Tolsum STS Ko
% LocalWords:  emph Ko Ko faturization PARNAS199541 NguyenHoanFS2010 Perlow1999
% LocalWords:  PEARL's
% LocalWords:  C4RLLaMA F1 Arry CodeLLaMA underperformed BLEU CCI
