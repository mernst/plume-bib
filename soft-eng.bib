% Software engineering bibliography






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Maintenance
%%%



@Article{Putnam78,
  author = 	 "Lawrence H. Putnam",
  title = 	 "A general empirical solution to the macro software sizing
                  and estimating problem",
  journal = 	 TSE,
  year = 	 1978,
  volume =	 4,
  number =	 4,
  pages =	 "345--361",
  month =	 jul
}

@Article{BalzerCG83,
  author = 	 "R. Balzer and T. E. Cheatham, Jr. and C. Green",
  title = 	 "Software technology in the 1990's: Using a new paradigm",
  journal = 	 "Computer",
  year = 	 1983,
  volume =	 16,
  number =	 11,
  pages =	 "39--45",
  month =	 nov
}

@Article{Boehm87:top10,
  author = 	 "Barry W. Boehm",
  title = 	 "Industrial software metrics top 10 list",
  journal = 	 IEEESoftware,
  year = 	 1987,
  volume =	 4,
  number =	 5,
  pages =	 "84--85",
  month =	 sep
}





@Article{Erlikh2000,
  author = 	 "Erlikh, Len",
  title = 	 "Leveraging legacy system dollars for e-business",
  journal = 	 "IT Professional",
  year = 	 2000,
  volume = 	 2,
  number = 	 3,
  pages = 	 "17--23",
  month = 	 may,
}



@Article{Eastwood1993,
  author = 	 "A. Eastwood",
  title = 	 "Firm fires shots at legacy systems",
  journal = 	 "Computing Canada",
  year = 	 1993,
  volume = 	 19,
  number = 	 2,
  pages = 	 17,
}


@Article{Moad1990,
  author = 	 "J. Moad",
  title = 	 "Maintaining the competitive edge",
  journal = 	 "DATAMATION",
  year = 	 1990,
  pages = 	 "61--66",
  month = 	 feb,
}






@Article{LientzS1981,
  author = 	 "Lientz, Bennet P. and Swanson, E. Burton",
  title = 	 "Problems in application software maintenance",
  journal = 	 CACM,
  year = 	 1981,
  volume = 	 24,
  number = 	 11,
  pages = 	 "763--769",
  month = 	 nov,
}


@Book{ZelkowitzSG1979,
  author = 	 "Zelkowitz, Marvin V. and Shaw, Alan C. and Gannon, John D.",
  title = 	 "Principles of Software Engineering and Design",
  publisher = 	 "Prentice Hall Professional Technical Reference",
  year = 	 1979,
}












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Refactoring
%%%

@TechReport{Griswold91,
  author = 	 "William G. Griswold",
  title = 	 "Program Restructuring To Aid Software Maintenance",
  institution =  UWCSE,
  year = 	 1991,
  number =	 "91-08-04",
  address =	 UWCSEaddr,
  month =	 aug,
  note =	 "PhD dissertation"
}

@TechReport{Opdyke92,
  author = 	 "W. F. Opdyke",
  title = 	 "Refactoring: A Program Restructuring Aid in Designing
                  Object-Oriented Applications Frameworks",
  institution =  "University of Illinois at Urbana-Champaign, Dept. of Computer Science",
  year = 	 1992,
  number =	 1759,
  note =	 "PhD dissertation"
}



@book{Fowler2000,
 title = {Refactoring: Improving the Design of Existing Code},
 author = {Martin Fowler},
 publisher = {Addison-Wesley},
 year = {2000}
}



@InProceedings{Parr94,
  author = 	 "Terence J. Parr",
  title = 	 "An overview of {SORCERER}: A simple tree-parser generator",
  crossref =     "CC94",
  NEEDpages = 	 "",
}


@Article{MensT2004,
  author = 	 "Tom Mens and Tom Tourw{\'e}",
  authorASCII =  "Tom Mens and Tom Tourwe",
  title = 	 "A survey of software refactoring",
  journal = 	 TSE,
  year = 	 2004,
  volume =	 30,
  number =	 2,
  pages =	 "126--139",
  month =	 feb
}



@InProceedings{StreckenbachS2004,
  author = 	 "Mirko Streckenbach and Gregor Snelting",
  title = 	 "Refactoring class hierarchies with {KABA}",
  crossref =     "OOPSLA2004",
  pages = 	 "315--330",
}


@InProceedings{HenkelD2005,
  author = 	 "Johannes Henkel and Amer Diwan",
  title = 	 "CatchUp!  Capturing and replaying refactorings to support
                  {API} evolution",
  crossref =     "ICSE2005",
  pages = 	 "274--283",
  abstract =
   "Library developers who have to evolve a library to accommodate changing
    requirements often face a dilemma: Either they implement a clean, efficient
    solution but risk breaking client code, or they maintain compatibility with
    client code, but pay with increased design complexity and thus higher
    maintenance costs over time.
    \par
    We address this dilemma by presenting a lightweight approach for evolving
    application programming interfaces (APIs), which does not depend on version
    control or configuration management systems. Instead, we capture API
    actions as a developer evolves an API. Users of the API can then replay the
    refactorings to bring their client software components up to date.
    \par
    We present CatchUp!, an implementation of our approach that captures and
    replays refactoring actions within an integrated development environment
    semi-automatically. Our experiments suggest that our approach could be
    valuable in practice.",
}



@InProceedings{MurphyHillPB2009,
  author = 	 "Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.",
  title = 	 "How we refactor, and how we know it",
  crossref =     "ICSE2009",
  pages = 	 "287--297",
  abstract =
   "Much of what we know about how programmers refactor in the wild is
    based on studies that examine just a few software projects. Researchers
    have rarely taken the time to replicate these studies in other contexts
    or to examine the assumptions on which they are based. To help put
    refactoring research on a sound scientific basis, we draw conclusions
    using four data sets spanning more than 13 000 developers, 240 000
    tool-assisted refactorings, 2500 developer hours, and 3400 version
    control commits. Using these data, we cast doubt on several previously
    stated assumptions about how programmers refactor, while validating
    others. For example, we find that programmers frequently do not indicate
    refactoring activity in commit logs, which contradicts assumptions made
    by several previous researchers. In contrast, we were able to confirm
    the assumption that programmers do frequently intersperse refactoring
    with other program changes. By confirming assumptions and replicating
    studies made by other researchers, we can have greater confidence that
    those researchers' conclusions are generalizable.",
}






@InProceedings{KashiwaSLBLKU2021,
  author = 	 "Kashiwa, Yutaro and Shimizu, Kazuki and Lin, Bin and Bavota, Gabriele and Lanza, Michele and Kamei, Yasutaka and Ubayashi, Naoyasu",
  title = 	 "Does Refactoring Break Tests and to What Extent?",
  crossref =  "ICSME2021",
  pages = 	 "171-182",
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Programmer productivity: lines of code per day
%%%





@Book{McConnell2006,
  author = 	 "Steve McConnell",
  title = 	 "Software Estimation: Demystifying the Black Art",
  publisher = 	 "Microsoft Press",
  year = 	 2006,
}


@Book{Jones2011,
  author = 	 "Capers Jones",
  title = 	 "The Economics of Software Quality",
  publisher = 	 "Addison-Wesley",
  year = 	 2011,
}



@Misc{Su2006,
  author = 	 "Philip Su",
  title = 	 "Broken {Windows} Theory",
  howpublished = "\url{http://blogs.msdn.com/b/philipsu/archive/2006/06/14/631438.aspx}",
  month = 	 jun,
  year = 	 2006,
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Experimental methodology
%%%




@Article{HostRW2000,
  author =       "H{\"o}st, Martin and Regnell, Bj{\"o}rn and Wohlin, Claes",
  authorASCII =  "Host, Martin and Regnell, Bjorn and Wohlin, Claes",
  title =        "Using Students As Subjects---A Comparative Study of Students and Professionals in Lead-Time Impact Assessment",
  journal =      JEmpiricalSE,
  year =         2000,
  volume =    5,
  number =    3,
  pages =     "201--214",
  month =     nov,
  abstract =
   "In many studies in software engineering students are used instead of
    professional software developers, although the objective is to draw
    conclusions valid for professional software developers. This paper presents
    a study where the difference between the two groups is evaluated. People
    from the two groups have individually carried out a non-trivial software
    engineering judgement task involving the assessment of how ten different
    factors affect the lead-time of software development projects. It is found
    that the differences are only minor, and it is concluded that software
    engineering students may be used instead of professional software
    developers under certain conditions. These conditions are identified and
    described based on generally accepted criteria for validity evaluation of
    empirical studies.",
}





@InProceedings{Runeson2003,
  author =       "Runeson, Per",
  title =        "Using students as experiment subjects -- An analysis on graduate and freshmen student data",
  booktitle = "Proceedings of the 7th International Conference on Empirical Assessment in Software Engineering",
  year =      2003,
  pages =     "95-102",
  month =     apr # "~8--10,",
  address =   "Keele, UK",
  abstract =
   "The question whether students can be used as subjects in
    software engineering experiments is debated. In order to
    investigate the feasibility of using students as subjects, a
    study is conducted in the context of the Personal Software
    Process (PSP) in which the performance of freshmen students
    and graduate students are compared and also related
    to another study in an industrial setting. The hypothesis is
    that graduate students perform similarly to industry personnel,
    while freshmen student's performance differ. A
    quantitative analysis compares the freshmen' and graduate
    students. The improvement trends are also compared to
    industry data, although limited data access does not allow a
    full comparison. It can be concluded that very much the
    same improvement trends can be identified for the three
    groups. However, the dispersion is larger in the freshmen
    group. The absolute levels of the measured characteristics
    are significantly different between the student groups primarily
    with respect to time, i.e. graduate students do the
    tasks in shorter time. The data does not give a sufficient
    answer to the hypothesis, but is a basis for further studies
    on the issue.",
}


@InProceedings{SalmanTMJ2015,
  author =    "Iflaah Salman and Ay{\c{s}}e {Tosun Misirli} and Natalia Juristo",
  authorASCII = "Iflaah Salman and Ayse Tosun Misirli and Natalia Juristo",
  title =     "Are Students Representatives of Professionals in Software Engineering Experiments?",
  crossref =     "ICSE2015",
  pages =     "666-676",
}



@Article{Kitchenham:2009:SLR:1465742.1466091,
  author =       "Kitchenham, Barbara and O. Pearl Brereton and Budgen, David and Turner, Mark and Bailey, John and Linkman, Stephen",
  title =        "Systematic literature reviews in software engineering -- A systematic literature review",
  journal =      "Inf. Softw. Technol.",
  year =         2009,
  volume =    51,
  number =    1,
  pages =     "7--15",
  month =     jan,
}


@article{Kitchenham:2010:SLR:1808352.1808650,
 author = {Kitchenham, Barbara and Pretorius, Rialette and Budgen, David and Pearl Brereton, O. and Turner, Mark and Niazi, Mahmood and Linkman, Stephen},
 title = {Systematic Literature Reviews in Software Engineering - A Tertiary Study},
 journal = {Inf. Softw. Technol.},
 issue_date = {August, 2010},
 volume = {52},
 number = {8},
 month = aug,
 year = {2010},
 issn = {0950-5849},
 pages = {792--805},
 numpages = {14},
 url = {http://dx.doi.org/10.1016/j.infsof.2010.03.006},
 doi = {10.1016/j.infsof.2010.03.006},
 acmid = {1808650},
 publisher = {Butterworth-Heinemann},
 address = {Newton, MA, USA},
 keywords = {Mapping study, Software engineering, Systematic literature review, Tertiary study},
}


@inproceedings{Devanbu:2016:BEE:2884781.2884812,
 author = {Devanbu, Prem and Zimmermann, Thomas and Bird, Christian},
 title = {Belief \& Evidence in Empirical Software Engineering},
 booktitle = {Proceedings of the 38th International Conference on Software Engineering},
 series = {ICSE '16},
 year = {2016},
 isbn = {978-1-4503-3900-1},
 address  = {Austin, Texas},
 pages = {108--119},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/2884781.2884812},
 doi = {10.1145/2884781.2884812},
 acmid = {2884812},
}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Defect prediction (fault prediction)
%%%










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fault localization
%%%


@InProceedings{JonesH2005,
  author = 	 "James A. Jones and Mary Jean Harrold",
  title = 	 "Empirical evaluation of the {Tarantula} automatic fault-localization technique",
  crossref =     "ASE2005",
  pages = 	 "273--282",
}



@InProceedings{ParninO2011,
  author = 	 "Parnin, Chris and Orso, Alessandro",
  title = 	 "Are automated debugging techniques actually helping programmers?",
  crossref =     "ISSTA2011",
  pages = 	 "199--209",
}


@InProceedings{RenierisR2003,
  author = 	 "Manos Renieris and Steven P. Reiss",
  title = 	 "Fault localization with nearest neighbor queries",
  crossref =     "ASE2003",
  pages = 	 "30--39",
}


@InProceedings{SteimannFA2013,
  author = 	 "Steimann, Friedrich and Frenkel, Marcus and Abreu, Rui",
  title = 	 "Threats to the validity and value of empirical assessments of the accuracy of coverage-based fault locators",
  crossref =     "ISSTA2013",
  pages = 	 "314--324",
}

@InProceedings{ZhangZK2013,
  author = 	 "Zhang, Lingming and Zhang, Lu and Khurshid, Sarfraz",
  title = 	 "Injecting mechanical faults to localize developer faults for evolving software",
  crossref =     "OOPSLA2013",
  pages = 	 "765--784",
}

@InProceedings{JonesHS2002,
  author = 	 "Jones, James A. and Harrold, Mary Jean and Stasko, John",
  title = 	 "Visualization of test information to assist fault localization",
  crossref =     "ICSE2002",
  pages = 	 "467--477",
}

@Unpublished{YooNH2011,
  author = 	 "Yoo, Shin and Nilsson, Robert and Harman, Mark",
  title = 	 "Faster fault finding at {Google} using multi objective regression test optimisation",
  note = 	 "Unpublished paper accompanying industrial track talk at ESEC/FSE 2011",
  month = 	 sep,
  year = 	 2011,
}





@Article{DiGiuseppeJ2015,
  author = 	 "DiGiuseppe, Nicholas and Jones, James A.",
  title = 	 "Fault Density, Fault Types, and Spectra-based Fault Localization",
  journal = 	 JEmpiricalSE,
  year = 	 2015,
  volume = 	 20,
  number = 	 4,
  pages = 	 "928--967",
  month = 	 aug,
}









@InProceedings{KochharXLL2016,
  author = 	 "Kochhar, Pavneet Singh and Xia, Xin and Lo, David and Li, Shanping",
  title = 	 "Practitioners' expectations on automated fault localization",
  crossref =  "ISSTA2016",
  pages = 	 "165--176",
}


@InProceedings{LongR2016:ICSE,
  author = 	 "Long, Fan and Rinard, Martin",
  title = 	 "An analysis of the search spaces for generate and validate patch generation systems",
  crossref =  "ICSE2016",
  pages = 	 "702--713",
}





@InProceedings{WongWQZ2008,
  author = 	 "Wong, Eric and Wei, Tingting and Qi, Yu and Zhao, Lei",
  title = 	 "A crosstab-based statistical method for effective fault localization",
  crossref =  "ICST2008",
  pages = 	 "42-51",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Automated program repair (APR)
%%%

@InProceedings{LeGouesDVFW2012,
  author = 	 "Le Goues, Claire and Dewey-Vogt, Michael and Forrest, Stephanie and Weimer, Westley",
  title = 	 "A systematic study of automated program repair: fixing 55 out of 105 bugs for \$8 each",
  crossref =     "ICSE2012",
  pages = 	 "3--13",
  abstract =
   "There are more bugs in real-world programs than human programmers can
    realistically address. This paper evaluates two research questions: ``What
    fraction of bugs can be repaired automatically?'' and ``How much does it
    cost to repair a bug automatically?'' In previous work, we presented
    GenProg, which uses genetic programming to repair defects in off-the-shelf
    C programs. To answer these questions, we: (1) propose novel algorithmic
    improvements to GenProg that allow it to scale to large programs and find
    repairs 68\% more often, (2) exploit GenProg's inherent parallelism using
    cloud computing resources to provide grounded, human-competitive cost
    measurements, and (3) generate a large, indicative benchmark set to use for
    systematic evaluations. We evaluate GenProg on 105 defects from 8
    open-source programs totaling 5.1 million lines of code and involving
    10,193 test cases. GenProg automatically repairs 55 of those 105
    defects. To our knowledge, this evaluation is the largest available of its
    kind, and is often two orders of magnitude larger than previous work in
    terms of code or test suite size or defect count. Public cloud computing
    prices allow our 105 runs to be reproduced for \$403; a successful repair
    completes in 96 minutes and costs \$7.32, on average.",
}




@InProceedings{QiLAR2015,
  author =       "Qi, Zichao and Long, Fan and Achour, Sara and Rinard, Martin",
  title =        "An analysis of patch plausibility and correctness for generate-and-validate patch generation systems",
  crossref =     "ISSTA2015",
  pages =     "24--36",
  doi = {10.1145/2771783.2771791},
}











@InProceedings{TianR2017,
  author = 	 "Tian, Yuchi and Ray, Baishakhi",
  title = 	 "Automatically diagnosing and repairing error handling bugs in {C}",
  crossref =  "FSE2017",
  year = 	 2017,
  pages = 	 "752--762",
}


@Article{Motwani2017,
author="Motwani, Manish
and Sankaranarayanan, Sandhya
and Just, Ren{\'e}
and Brun, Yuriy",
title="Do automated program repair techniques repair hard and important bugs?",
journal=JEmpiricalSE,
year="2017",
month="Nov",
day="18",
abstract="Existing evaluations of automated repair techniques focus on the fraction of the defects for which the technique can produce a patch, the time needed to produce patches, and how well patches generalize to the intended specification. However, these evaluations have not focused on the applicability of repair techniques and the characteristics of the defects that these techniques can repair. Questions such as ``Can automated repair techniques repair defects that are hard for developers to repair?'' and ``Are automated repair techniques less likely to repair defects that involve loops?'' have not, as of yet, been answered. To address such questions, we annotate two large benchmarks totaling 409 C and Java defects in real-world software, ranging from 22K to 2.8M lines of code, with measures of the defect's importance, the developer-written patch's complexity, and the quality of the test suite. We then analyze relationships between these measures and the ability to produce patches for the defects of seven automated repair techniques ---AE, GenProg, Kali, Nopol, Prophet, SPR, and TrpAutoRepair. We find that automated repair techniques are less likely to produce patches for defects that required developers to write a lot of code or edit many files, or that have many tests relevant to the defect. Java techniques are more likely to produce patches for high-priority defects. Neither the time it took developers to fix a defect nor the test suite's coverage correlate with the automated repair techniques' ability to produce patches. Finally, automated repair techniques are less capable of fixing defects that require developers to add loops and new function calls, or to change method signatures. These findings identify strengths and shortcomings of the state-of-the-art of automated program repair along new dimensions. The presented methodology can drive research toward improving the applicability of automated repair techniques to hard and important bugs.",
issn="1573-7616",
doi="10.1007/s10664-017-9550-0",
url="https://doi.org/10.1007/s10664-017-9550-0"
}




@inproceedings{vanTonder:2018:SAP:3180155.3180250,
 author = {van Tonder, Rijnard and Goues, Claire Le},
 title = {Static Automated Program Repair for Heap Properties},
 booktitle = {Proceedings of the 40th International Conference on Software Engineering},
 series = {ICSE '18},
 year = {2018},
 isbn = {978-1-4503-5638-1},
 location = {Gothenburg, Sweden},
 pages = {151--162},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/3180155.3180250},
 doi = {10.1145/3180155.3180250},
 acmid = {3180250},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {automated program repair, separation logic},
}




@Article{AletiM2021,
  author = 	 "Aleti, Aldeida and Martinez, Matias",
  title = 	 "{E-APR}: Mapping the effectiveness of automated program repair techniques",
  journal = 	 JEmpiricalSE,
  year = 	 2021,
  volume = 	 26,
  number = 	 99,
  NEEDpages = 	 "*",
  month = 	 jul,
  abstract =
   "Automated Program Repair (APR) is a fast growing area with numerous new
    techniques being developed to tackle one of the most challenging software
    engineering problems. APR techniques have shown promising results, giving
    us hope that one day it will be possible for software to repair itself. In
    this paper, we focus on the problem of objective performance evaluation of
    APR techniques. We introduce a new approach, Explaining Automated Program
    Repair (E-APR), which identifies features of buggy programs that explain
    why a particular instance is difficult for an APR technique. E-APR is used
    to examine the diversity and quality of the buggy programs used by most
    researchers, and analyse the strengths and weaknesses of existing APR
    techniques. E-APR visualises an instance space of buggy programs, with each
    buggy program represented as a point in the space. The instance space is
    constructed to reveal areas of hard and easy buggy programs, and enables
    the strengths and weaknesses of APR techniques to be identified.",
}




@INPROCEEDINGS{tan2015relifix,
  author={Tan, Shin Hwei and Roychoudhury, Abhik},
  booktitle={2015 IEEE/ACM 37th IEEE International Conference on Software Engineering},
  title={relifix: Automated Repair of Software Regressions},
  year={2015},
  volume={1},
  number={},
  pages={471-482},
  doi={10.1109/ICSE.2015.65}}








@Article{KirbasWMKPSVWCBHHW2021,
  author = 	 "Kirbas, Serkan and Windels, Etienne and McBello, Olayori and Kells, Kevin and Pagano, Matthew and Szalanski, Rafal and Nowack, Vesna and Winter, Emily Rowan and Counsell, Steve and Bowes, David and Hall, Tracy and Haraldsson, Saemundur and Woodward, John",
  title = 	 "On the introduction of automatic program repair in {Bloomberg}",
  journal = 	 IEEESoftware,
  year = 	 2021,
  volume = 	 38,
  number = 	 4,
  pages = 	 "43-51",
  month = 	 jul # "-" # aug,
}


@InProceedings{EldawyLGB2023,
  author = 	 "Hadeel Eladawy and Claire {Le Goues} and Yuriy Brun",
  title = 	 "Automated program repair, what is it good for? Not absolutely nothing!",
  crossref =  "ICSE2024",
  NEEDpages = 	 "*",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Clone detection and code similarity
%%%

@InProceedings{BasitRJ2005,
  author = 	 "Hamid Abdul Basit and Damith C. Rajapakse and Stan Jarzabek",
  title = 	 "Beyond templates: A study of clones in the {STL} and some
                  general implications",
  crossref =     "ICSE2005",
  pages = 	 "451--459",
  abstract =
   "Templates (or generics) help us write compact, generic code, which aids
    both reuse and maintenance. The STL is a powerful example of how templates
    help achieve these goals. Still, our study of the STL revealed substantial,
    and in our opinion, counter-productive repetitions (so-called clones)
    across groups of similar class or function templates. Clones occurred, as
    variations across these similar program structures were irregular and could
    not be unified by suitable template parameters in a natural way. We
    encountered similar problems in other class libraries as well as in
    application programs, written in a range of programming languages. In the
    paper, we present quantitative and qualitative results from our study. We
    argue that the difficulties we encountered affect programs in general. We
    present a solution that can treat such template-unfriendly cases of
    redundancies at the meta-level, complementing and extending the power of
    language features, such as templates, in areas of generic programming.",
}



@InProceedings{BasitJ2005,
  author = 	 "Hamid Abdul Basit and Stan Jarzabek",
  title = 	 "Detecting higher-level similarity patterns in programs",
  crossref =     "FSE2005",
  pages =	 "156--165",
  abstract =
   "Cloning in software systems is known to create problems during software
    maintenance. Several techniques have been proposed to detect the same or
    similar code fragments in software, so-called simple clones. While the
    knowledge of simple clones is useful, detecting design-level similarities
    in software could ease maintenance even further, and also help us identify
    reuse opportunities. We observed that recurring patterns of simple clones -
    so-called structural clones - often indicate the presence of interesting
    design-level similarities. An example would be patterns of collaborating
    classes or components. Finding structural clones that signify potentially
    useful design information requires efficient techniques to analyze the bulk
    of simple clone data and making non-trivial inferences based on the
    abstracted information. In this paper, we describe a practical solution to
    the problem of detecting some basic, but useful, types of design-level
    similarities such as groups of highly similar classes or files. First, we
    detect simple clones by applying conventional token-based techniques. Then
    we find the patterns of co-occurring clones in different files using the
    Frequent Itemset Mining (FIM) technique. Finally, we perform file
    clustering to detect those clusters of highly similar files that are likely
    to contribute to a design-level similarity pattern. The novelty of our
    approach is application of data mining techniques to detect design level
    similarities. Experiments confirmed that our method finds many useful
    structural clones and scales up to big programs. The paper describes our
    method for structural clone detection, a prototype tool called Clone Miner
    that implements the method and experimental results."
}




@InProceedings{KimSNM2005,
  author = 	 "Miryung Kim and Vibha Sazawal and David Notkin
                  and Gail C. Murphy",
  title = 	 "An empirical study of code clone genealogies",
  crossref =     "FSE2005",
  pages =	 "187--196",
  abstract =
   "It has been broadly assumed that code clones are inherently bad and that
    eliminating clones by refactoring would solve the problems of code
    clones. To investigate the validity of this assumption, we developed a
    formal definition of clone evolution and built a clone genealogy tool that
    automatically extracts the history of code clones from a source code
    repository. Using our tool we extracted clone genealogy information for two
    Java open source projects and analyzed their evolution.
    \par
    Our study contradicts some conventional wisdom about clones. In particular,
    refactoring may not always improve software with respect to clones for two
    reasons. First, many code clones exist in the system for only a short time;
    extensive refactoring of such short-lived clones may not be worthwhile if
    they are likely diverge from one another very soon. Second, many clones,
    especially long-lived clones that have changed consistently with other
    elements in the same group, are not easily refactorable due to programming
    language limitations. These insights show that refactoring will not help in
    dealing with some types of clones and open up opportunities for
    complementary clone maintenance tools that target these other classes of
    clones.",
}


@inproceedings{JB10,
  Author = {Kevin Jalbert and Jeremy S. Bradbury},
  Title = {Using Clone Detection to Identify Bugs in Concurrent Software},
  Booktitle = {Proc. of 26th IEEE International Conference on Software Maintenance (ICSM 2010)},
  Month = {Sept.},
  Year = {2010}
}




@InProceedings{SainiFLYMSBL2019,
  author = 	 "Saini, Vaibhav and Farmahinifarahani, Farima and Lu, Yadong and Yang, Di and Martins, Pedro and Sajnani, Hitesh and Baldi, Pierre and Lopes, Cristina V.",
  title = 	 "Towards automating precision studies of clone detectors",
  crossref =  "ICSE2019",
  pages = 	 "49-59",
}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Debugging
%%%

@inproceedings{10.1145/3586183.3606781,
author = {Alaboudi, Abdulaziz and Latoza, Thomas D.},
title = {Hypothesizer: A Hypothesis-Based Debugger to Find and Test Debugging Hypotheses},
year = {2023},
isbn = {9798400701320},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3586183.3606781},
doi = {10.1145/3586183.3606781},
abstract = {When software defects occur, developers begin the debugging process by formulating hypotheses to explain the cause. These hypotheses guide the investigation process, determining which evidence developers gather to accept or reject the hypothesis, such as parts of the code and program state developers examine. However, existing debugging techniques do not offer support in finding relevant hypotheses, leading to wasted time testing hypotheses and examining code that ultimately does not lead to a fix. To address this issue, we introduce a new type of debugging tool, the hypothesis-based debugger, and an implementation of this tool in Hypothesizer. Hypothesis-based debuggers support developers from the beginning of the debugging process by finding relevant hypotheses until the defect is fixed. To debug using Hypothesizer, developers first demonstrate the defect, generating a recording of the program behavior with code execution, user interface events, network communications, and user interface changes. Based on this information and the developer’s descriptions of the symptoms, Hypothesizer finds relevant hypotheses, analyzes the code to identify relevant evidence to test the hypothesis, and generates an investigation plan through a timeline view. This summarizes all evidence items related to the hypothesis, indicates whether the hypothesis is likely to be true by showing which evidence items were confirmed in the recording, and enables the developer to quickly check evidence in the recording by viewing code snippets for each evidence item. A randomized controlled experiment with 16 professional developers found that, compared to traditional debugging tools and techniques such as breakpoint debuggers and Stack Overflow, Hypothesizer dramatically improved the success rate of fixing defects by a factor of five and decreased the time to debug by a factor of three.},
booktitle = {Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology},
articleno = {73},
numpages = {14},
keywords = {debugging tools, debugging hypotheses, debugging},
location = {San Francisco, CA, USA},
series = {UIST '23}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Documentation
%%%

@article{PARNAS199541,
title = {Functional documents for computer systems},
journal = {Science of Computer Programming},
volume = {25},
number = {1},
pages = {41-61},
year = {1995},
issn = {0167-6423},
doi = {https://doi.org/10.1016/0167-6423(95)96871-J},
url = {https://www.sciencedirect.com/science/article/pii/016764239596871J},
author = {David Lorge Parnas and Jan Madey},
keywords = {Documentation, Formal Methods, Software Engineering},
abstract = {Although software documentation standards often go into great detail about the format of documents, describing such details as paragraph numbering and section headings, they fail to give precise descriptions of the information to be contained in the documents. This paper does the opposite; it defines the contents of documents without specifying their format or the notation to be used in them. We describe documents such as the “System Requirements Document”, the “System Design Document”, the “Software Requirements Document”, the “Software Behaviour Specification”, the “Module Interface Specification”, and the “Module Internal Design Document” as representations of one or more mathematical relations. By describing those relations, we specify what information should be contained in each document.}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Scientific programming and end-user programming
%%%

@InProceedings{LeeDM2006,
  author =       "Lee, Charlotte P. and Dourish, Paul and Mark, Gloria",
  title =        "The human infrastructure of cyberinfrastructure",
  crossref =  "CSCW2006",
  pages =     "483-492",
  abstract =
   "Despite their rapid proliferation, there has been little examination of the
    coordination and social practices of cyberinfrastructure projects. We use
    the notion of ``human infrastructure'' to explore how human and
    organizational arrangements share properties with technological
    infrastructures. We conducted an 18-month ethnographic study of a
    large-scale distributed biomedical cyberinfrastructure project and
    discovered that human infrastructure is shaped by a combination of both new
    and traditional team and organizational structures. Our data calls into
    question a focus on distributed teams as the means for accomplishing
    distributed work and we argue for using human infrastructure as an
    alternative perspective for understanding how distributed collaboration is
    accomplished in big science."
}



@Article{RibesL2010,
  author =       "Ribes, David and Lee, Charlotte P.",
  title =        "Sociotechnical Studies of Cyberinfrastructure and e-Research: Current Themes and Future Trajectories",
  journal =      JCSCW,
  year =         2010,
  volume =    19,
  pages =     "231-244",
  month =     sep,
  doi =       "https://doi.org/10.1007/s10606-010-9120-0",
}



@InProceedings{NguyenHoanFS2010,
  author =       "Nguyen-Hoan, Luke and Flint, Shayne and Sankaranarayana, Ramesh",
  title =        "A survey of scientific software development",
  crossref =  "ESEM2010",
  articleno = 12,
  numpages = 10,
}




@InProceedings{PrabhuJRZHKJLGBOZWA2011,
  author =       "Prabhu, Prakash and Jablin, Thomas B. and Raman, Arun and Zhang, Yun and Huang, Jialu and Kim, Hanjun and Johnson, Nick P. and Liu, Feng and Ghosh, Soumyadeep and Beard, Stephen and Oh, Taewook and Zoufaly, Matthew and Walker, David and August, David I.",
  title =        "A survey of the practice of computational science",
  crossref =  "SC2011",
  articleno = 19,
  numpages = 12,
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous
%%%


@Misc{Borland2004,
  author =	 "Borland",
  title =	 "Making Development A Team Sport",
  howpublished = "demo at JavaOne",
  month =	 jun # "~29,",
  year =	 2004
}



@InProceedings{ChowN96,
  author = 	 "Kingsum Chow and David Notkin",
  title = 	 "Semi-automatic update of applications in response to
                  library changes",
  crossref =     "ICSM96",
  pages =	 "259--368",
}



@InProceedings{MandelinXBK2005,
  author = 	 "David Mandelin and Lin Xu and Rastislav Bod{\'\i}k and
                  Doug Kimmelman",
  authorSEARCHABLE = "Rastislav Bodik",
  title = 	 "Jungloid mining: Helping to navigate the {API} jungle",
  crossref =     "PLDI2005",
  pages = 	 "48--61",
  abstract =
   "Reuse of existing code from class libraries and frameworks is often
    difficult because APIs are complex and the client code required to use the
    APIs can be hard to write. We observed that a common scenario is that the
    programmer knows what type of object he needs, but does not know how to
    write the code to get the object.
    \par
    In order to help programmers write API client code more easily, we
    developed techniques for synthesizing jungloid code fragments automatically
    given a simple query that describes that desired code in terms of input and
    output types. A jungloid is simply a unary expression; jungloids are
    simple, enabling synthesis, but are also versatile, covering many coding
    problems, and composable, combining to form more complex code fragments. We
    synthesize jungloids using both API method signatures and jungloids mined
    from a corpus of sample client programs.
    \par
    We implemented a tool, Prospector, based on these techniques. Prospector is
    integrated with the Eclipse IDE code assistance feature, and it infers
    queries from context so there is no need for the programmer to write
    queries. We tested Prospector on a set of real programming problems
    involving APIs; Prospector found the desired solution for 18 of 20
    problems.We also evaluated Prospector in a user study, finding that
    programmers solved programming problems more quickly and with more reuse
    when using Prospector than without Prospector."
}



@Article{SanthiarPK2014,
  author = 	 "Santhiar, Anirudh and Pandita, Omesh and Kanade, Aditya",
  title = 	 "Mining Unit Tests for Discovery and Migration of Math {APIs}",
  journal = 	 TOSEM,
  year = 	 2014,
  volume = 	 24,
  number = 	 1,
  pages = 	 "4:1--4:33",
  month = 	 oct,
}



@InProceedings{GhafariGMT2014,
  author = 	 "Mohammad Ghafari and Carlo Ghezzi and Andrea Mocci and Giordano Tamburrelli",
  title = 	 "Mining unit tests for code recommendation",
  crossref =     "ICPC2014",
  pages = 	 "142--145",
}



@InProceedings{RutarAF2004,
  author = 	 "Nick Rutar and Christian B. Almazan and Jeffrey S. Foster",
  title = 	 "A comparison of bug finding tools for {Java}",
  crossref =     "ISSRE2004",
  pages =	 "245--256",
  abstract =
   "Bugs in software are costly and difficult to find and fix. In recent years,
    many tools and techniques have been developed for automatically finding
    bugs by analyzing source code or intermediate code statically (at compile
    time). Different tools and techniques have different tradeoffs, but the
    practical impact of these tradeoffs is not well understood. In this paper,
    we apply five bug finding tools, specifically Bandera, ESC/Java 2,
    FindBugs, JLint, and PMD, to a variety of Java programs. By using a variety
    of tools, we are able to cross-check their bug reports and warnings. Our
    experimental results show that none of the tools strictly subsumes another,
    and indeed the tools often find non-overlapping bugs. We discuss the
    techniques each of the tools is based on, and we suggest how particular
    techniques affect the output of the tools. Finally, we propose a meta-tool
    that combines the output of the tools together, looking for particular
    lines of code, methods, and classes that many tools warn about.",
}





@Book{GhezziJM91,
  author =       "Carlo Ghezzi and Mehdi Jazayeri and Dino Mandrioli",
  title =        "Fundamentals of Software Engineering",
  edition =      "1",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year =         "1991",
  ISBN =         "0-13-818204-3",
}


@Book{Lamb88,
  author =	 "David Alex Lamb",
  title = 	 "Software Engineering:  Planning for Change",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year = 	 1988
}

@Book{Sommerville:1996a,
  author =       "Ian Sommerville",
  title =        "Software Engineering",
  publisher =    "Addison-Wesley",
  year =         "1996",
  address =      "Wokingham, England",
  edition =      "Fifth",
}

@Book{Pressman92,
  author =	 "Roger S. Pressman",
  title = 	 "Software Engineering:  A Practitioner's Approach",
  publisher = 	 "McGraw-Hill",
  year = 	 1992,
  address =	 "New York",
  edition =	 "Third"
}




@InProceedings{VandevoordeG94,
  author =       "Mark T. Vandevoorde and John V. Guttag",
  title =        "Using specialized procedures and specification-based analysis
                  to reduce the runtime costs of modularity",
  booktitle =    "Symposium on the Foundations of Software Engineering",
  year =         1994,
  month =        dec
}

@InProceedings{KremenekAYE2004,
  author = 	 "Ted Kremenek and Ken Ashcraft and Junfeng Yang and Dawson Engler",
  title = 	 "Correlation exploitation in error ranking",
  crossref =     "FSE2004",
  pages = 	 "83--93",
}






@InProceedings{LivshitsZ2005,
  author = 	 "Benjamin Livshits and Thomas Zimmermann",
  title = 	 "{DynaMine}: Finding common error patterns by mining
                  software revision histories",
  crossref =     "FSE2005",
  pages =	 "296--305",
  abstract =
   "A great deal of attention has lately been given to addressing software
    bugs such as errors in operating system drivers or security bugs. However,
    there are many other lesser known errors specific to individual
    applications or APIs and these violations of application-specific coding
    rules are responsible for a multitude of errors. In this paper we propose
    DynaMine, a tool that analyzes source code check-ins to find highly
    correlated method calls as well as common bug fixes in order to
    automatically discover application-specific coding patterns. Potential
    patterns discovered through mining are passed to a dynamic analysis tool
    for validation; finally, the results of dynamic analysis are presented to
    the user.
    \par
    The combination of revision history mining and dynamic analysis techniques
    leveraged in DynaMine proves effective for both discovering new
    application-specific patterns and for finding errors when applied to very
    large applications with many man-years of development and debugging effort
    behind them. We have analyzed Eclipse and jEdit, two widely-used, mature,
    highly extensible applications consisting of more than 3,600,000 lines of
    code combined. By mining revision histories, we have discovered 56
    previously unknown, highly application-specific patterns. Out of these, 21
    were dynamically confirmed as very likely valid patterns and a total of 263
    pattern violations were found.",
}



@InProceedings{SullivanGSCSTR2005,
  author = 	 "Kevin Sullivan and William G. Griswold and Yuanyuan Song
                  and Yuanfang Cai and Macneil Shonle and Nishit Tewari and
                  Hridesh Rajan",
  title = 	 "Information hiding interfaces for aspect-oriented design",
  crossref =     "FSE2005",
  pages =	 "166--175",
}




@InProceedings{Przybylek2011,
  author = 	 "Adam Przyby{\l}ek",
  authorASCII =  "Adam Przybyłek, Adam Przybylek",
  title = 	 "Where the truth lies: {AOP} and its impact on software modularity",
  crossref =     "FASE2011",
  NEEDpages = 	 "*",
  abstract =
   "Modularity is the single attribute of software that allows a program to be
    intellectually manageable [29]. The recipe for modularizing is to define a
    narrow interface, hide an implementation detail, keep low coupling and high
    cohesion. Over a decade ago, aspect-oriented programming (AOP) was proposed
    in the literature to ``modularize the un-modularizable'' [24]. Since then,
    aspect-oriented languages have been providing new abstraction and
    composition mechanisms to deal with concerns that could not be modularized
    because of the limited abstractions of the underlying programming
    language. This paper is a continuation of our earlier work [32] and further
    investigates AO software with regard to coupling and cohesion. We compare
    two versions (Java and AspectJ) of ten applications to review AOP within
    the context of software modularity. It turns out that the claim that ``the
    software built in AOP is more modular than the software built in OOP'' is a
    myth.",
}







@InProceedings{LiZ2005,
  author = 	 "Zhenmin Li and Yuanyuan Zhou",
  title = 	 "PR-Miner: automatically extracting implicit programming
                  rules and detecting violations in large software code",
  crossref =     "FSE2005",
  pages =	 "306--315",
  abstract =
   "Programs usually follow many \emph{implicit} programming rules, most of
    which are too tedious to be documented by programmers. When these rules are
    violated by programmers who are unaware of or forget about them, defects
    can be easily introduced. Therefore, it is highly desirable to have tools
    to automatically extract such rules and also to automatically detect
    violations. Previous work in this direction focuses on simple function-pair
    based programming rules and additionally requires programmers to provide
    rule templates.
    \par
    This paper proposes a \emph{general} method called PR-Miner that uses a
    data mining technique called frequent itemset mining to efficiently extract
    implicit programming rules from large software code written in an
    industrial programming language such as C, \emph{requiring little effort
    from programmers and no prior knowledge of the software}. Benefiting from
    frequent itemset mining, PR-Miner can extract programming rules in general
    forms (without being constrained by any fixed rule templates) that can
    contain multiple program elements of various types such as functions,
    variables and data types. In addition, we also propose an efficient
    algorithm to automatically detect violations to the extracted programming
    rules, which are strong indications of bugs.
    \par
    Our evaluation with large software code, including Linux, PostgreSQL Server
    and the Apache HTTP Server, with 84K--3M lines of code each, shows that
    PR-Miner can efficiently extract thousands of general programming rules and
    detect violations within 2 minutes. Moreover, PR-Miner has detected many
    violations to the extracted rules. Among the top 60 violations reported by
    PR-Miner, 16 have been confirmed as bugs in the \emph{latest version} of
    Linux, 6 in PostgreSQL and 1 in Apache. Most of them violate complex
    programming rules that contain more than 2 elements and are thereby
    difficult for previous tools to detect. We reported these bugs and they are
    currently being fixed by developers.",
}



@Book{Simon96,
  author = 	 "Herbert A. Simon",
  title = 	 "The Sciences of the Artificial",
  publisher = 	 "MIT Press",
  year = 	 1996,
  edition = 	 "Third",
}

@Book{Braude2003,
  author = 	 "Eric J. Braude",
  title = 	 "Software Design: From Programming to Architecture",
  publisher = 	 "Wiley",
  year = 	 2003,
}


@Book{Budgen2003,
  author = 	 "Software Design",
  title = 	 "David Budgen",
  publisher = 	 "Addison-Wesley",
  year = 	 2003,
}

@Book{Winograd1996,
  author = 	 "Terry Winograd",
  title = 	 "Bringing Design to Software",
  publisher = 	 "Addison-Wesley",
  year = 	 1996
}

@Book{CoplienS1995,
  author = 	 "James O. Coplien and Douglas C. Schmidt",
  title = 	 "Pattern Languages of Program Design",
  publisher = 	 "Addison-Wesley",
  year = 	 1995,
}

@Book{FelleisenFFK2001,
  author = 	 "Matthias Felleisen and Robert Bruce Findler and Matthew
                  Flatt and Shriram Krishnamurthi",
  title = 	 "How to Design Programs: An Introduction to Programming and Computing",
  publisher = 	 "MIT Press",
  year = 	 2001
}

@Book{CohoonD2005,
  author = 	 "James P. Cohoon and Jack W. Davidson ",
  title = 	 "Java 5.0 Program Design",
  publisher = 	 "McGraw-Hill",
  year = 	 2005,
}



@InProceedings{KuhnGG2005,
  author = 	 "Adrian Kuhn and Orla Greevy and Tudor G{\^\i}rba",
  title = 	 "Applying semantic analysis to feature execution traces",
  crossref =     "PCODA2005",
  pages = 	 "48--53",
  abstract =
   "Recently there has been a revival of interest in feature
    analysis of software systems. Approaches to feature location
    have used a wide range of techniques such as dynamic
    analysis, static analysis, information retrieval and formal
    concept analysis. In this paper we introduce a novel approach
    to analyze the execution traces of features using Latent
    Semantic Indexing (LSI). Our goal is twofold. On the
    one hand we detect similarities between features based on
    the content of their traces, and on the other hand we categorize
    classes based on the frequency of the outgoing invocations
    involved in the traces. We apply our approach on
    two case studies and we discuss its benefits and drawbacks.",
}



@Article{EisenbarthKS2003,
  author = 	 "T. Eisenbarth and R. Koschke and D. Simon",
  title = 	 "Locating Features in Source Code",
  journal = 	 computer,
  year = 	 2003,
  volume = 	 29,
  number = 	 3,
  pages = 	 "210--224",
  month = 	 mar,
}


@InProceedings{GreevyD2005,
  author = 	 "O. Greevy and St{\'e}phane Ducasse",
  title = 	 "Correlating features and code using a compact two-sided
                  trace analysis approach",
  crossref =     "CMSR2005",
  pages = 	 "314--323",
}


@InProceedings{GreevyDG2005,
  author = 	 "Orla Greevy and St{\'e}phane Ducasse and Tudor G{\^\i}rba",
  title = 	 "Analyzing feature traces to incorporate the semantics of
		  change in software evolution analysis",
  crossref =     "ICSM2005",
  pages = 	 "347--356",
}


@Article{WongGH2000,
  author = 	 "W. E. Wong and S. S. Gokhale and J. R. Horgan",
  title = 	 "Quantifying the closeness between program components and features",
  journal = 	 j-systems-and-software,
  year = 	 2000,
  volume = 	 54,
  number = 	 2,
  pages = 	 "87--98",
  month = 	 oct,
}


@InProceedings{ZaidmanCDP2005,
  author = 	 "Andy Zaidman and Toon Calders and Serge Demeyer and Jan Paredaens",
  title = 	 "Applying Webmining Techniques to Execution Traces to
                  Support the Program Comprehension Process",
  crossref =     "CMSR2005",
  pages = 	 "134--142",
  abstract =
   "Well-designed object-oriented programs typically consist
    of a few key classes that work tightly together to provide
    the bulk of the functionality. As such, these key classes are
    excellent starting points for the program comprehension
    process. We propose a technique that uses webmining
    principles on execution traces to discover these important
    and tightly interacting classes. Based on two medium-scale
    case studies --- Apache Ant and Jakarta JMeter --- and
    detailed architectural information from its developers, we
    show that our heuristic does in fact find a sizable number
    of the classes deemed important by the developers.",
}


@InProceedings{HaRDRCRW2007,
  author = 	 "Jungwoo Ha and Christopher J. Rossbach and Jason V. Davis and Indrajit Roy and David L. Chen and Hany E. Ramadan and Emmett Witchel",
  title = 	 "Improved error reporting for software that uses black-box components",
  crossref =     "PLDI2007",
  pages = 	 "101--111",
}



@InProceedings{XuRTQ2007,
  author = 	 "Guoqing Xu and Atanas Rountev and Yan Tang and Feng Qin",
  title = 	 "Efficient checkpointing of {Java} software using context-sensitive capture and replay",
  crossref =     "FSE2007",
  pages = 	 "85--94",
}



@InProceedings{DwyerKE2007,
  author = 	 "Matthew B. Dwyer and Alex Kinneer and Sebastian Elbaum",
  title = 	 "Adaptive Online Program Analysis",
  crossref =     "ICSE2007",
  pages = 	 "220--229",
}







@InProceedings{KoM2008,
  author = 	 "Andrew J. Ko and Brad A. Myers",
  title = 	 "Debugging reinvented: Asking and answering why and why not questions about program behavior",
  crossref =     "ICSE2008",
  pages = 	 "301--310",
}







@Book{IEEE-610.12-1990,
  editor = 	 "Jane Radatz",
  title = 	 "IEEE Std 610.12-1990 IEEE Standard Glossary of Software Engineering Terminology",
  publisher = 	 "IEEE Computer Society",
  year = 	 1990,
  month = 	 sep # "~28,",
  abstract =
   "Describes the IEEE Std 610.12-1990, IEEE standard glossary of software
   engineering terminology, which identifies terms currently in use in the
   field of software engineering. Standard definitions for those terms are
   established.",
}


@InProceedings{Cook2009,
  author = 	 "Cook, William R.",
  title = 	 "On understanding data abstraction, revisited",
  crossref =     "OOPSLACompanion2009",
  pages = 	 "557--572",
}



@Book{Brooks1975,
  author = 	 "Brooks, Jr., Frederick P.",
  title = 	 "The Mythical Man-Month: Essays on Software Engineering",
  publisher = 	 "Addison-Wesley",
  year = 	 1975,
  address = {Boston, MA, USA},
  isbn = {0201006502},
}



@InProceedings{JeongKZ2009,
  author = 	 "Jeong, Gaeul and Kim, Sunghun and Zimmermann, Thomas",
  title = 	 "Improving bug triage with bug tossing graphs",
  crossref =     "FSE2009",
  pages = 	 "111--120",
}


@Article{WalradS2002,
  author = 	 "Walrad, Chuck and Strom, Darrel",
  title = 	 "The Importance of Branching Models in {SCM}",
  journal = 	 "Computer",
  year = 	 2002,
  volume = 	 35,
  number = 	 9,
  pages = 	 "31--38",
  month = 	 sep,
}

@InProceedings{NagappanBZ2006,
  author = 	 "Nagappan, Nachiappan and Ball, Thomas and Zeller, Andreas",
  title = 	 "Mining metrics to predict component failures",
  crossref =     "ICSE2006",
  pages = 	 "452--461",
}




@InProceedings{BaconCPR2009,
  author = 	 "Bacon, David F. and Chen, Yiling and Parkes, David and Rao, Malvika",
  title = 	 "A market-based approach to software evolution",
  crossref =     "OOPSLACompanion2009",
  pages = 	 "973--980",
  doi = {https://doi.acm.org/10.1145/1639950.1640066},
}


@Article{Sakthivel2007,
  author = 	 "Sakthivel, S.",
  title = 	 "Managing risk in offshore systems development",
  journal = 	 CACM,
  year = 	 2007,
  volume = 	 50,
  number = 	 4,
  pages = 	 "69--75",
  month = 	 apr,
  doi = {https://doi.acm.org/10.1145/1232743.1232750},
}


@InProceedings{FritzM2010,
  author = 	 "Fritz, Thomas and Murphy, Gail C.",
  title = 	 "Using information fragments to answer the questions developers ask",
  crossref =     "ICSE2010",
  pages = 	 "175--184",
}






@Article{Norman90,
  author = 	 "Donald A. Norman",
  title = 	 "The ``Problem'' with automation: Inappropriate feedback and interaction, not ``over-automation''",
  journal = 	 PTRSLB,
  year = 	 1990,
  volume = 	 327,
  number = 	 1241,
  pages = 	 "585--593",
}









@InProceedings{ChangYM2010,
  author = 	 "Chang, Tsung-Hsiang and Yeh, Tom and Miller, Robert C.",
  title = 	 "{GUI} Testing Using Computer Vision",
  crossref =     "CHI2010",
  pages = 	 "1535--1544",
}




















@InProceedings{JohnsonSMHB2013,
  author = 	 "Johnson, Brittany and Song, Yoonki and Murphy-Hill, Emerson and Bowdidge, Robert",
  title = 	 "Why don't software developers use static analysis tools to find bugs?",
  crossref =     "ICSE2013",
  pages = 	 "672--681",
  abstract =
   "Using static analysis tools for automating code inspections can be
    beneficial for software engineers. Such tools can make finding bugs, or
    software defects, faster and cheaper than manual inspections. Despite the
    benefits of using static analysis tools to find bugs, research suggests
    that these tools are underused. In this paper, we investigate why
    developers are not widely using static analysis tools and how current tools
    could potentially be improved. We conducted interviews with 20 developers
    and found that although all of our participants felt that use is
    beneficial, false positives and the way in which the warnings are
    presented, among other things, are barriers to use. We discuss several
    implications of these results, such as the need for an interactive
    mechanism to help developers fix defects.",
}








@inproceedings{Khomh:2012:FRI:2664446.2664475,
 author = {Khomh, Foutse and Dhaliwal, Tejinder and Zou, Ying and Adams, Bram},
 title = {Do Faster Releases Improve Software Quality?: An Empirical Case Study of Mozilla Firefox},
 booktitle = {Proceedings of the 9th IEEE Working Conference on Mining Software Repositories},
 series = {MSR '12},
 year = {2012},
 isbn = {978-1-4673-1761-0},
 address  = {Zurich, Switzerland},
 pages = {179--188},
 numpages = {10},
 url = {http://dl.acm.org/citation.cfm?id=2664446.2664475},
 acmid = {2664475},
 keywords = {bugs, release cycle, software quality, software release, testing},
}



















@InProceedings{MusluBM2015,
  author = 	 "K{\i}van\c{c} Mu{\c{s}}lu and Yuriy Brun and Alexandra Meliou",
  authorASCII =	 "Kivanc Muslu and Yuriy Brun and Alexandra Meliou",
  title = 	 "Preventing data errors with continuous testing",
  crossref =     "ISSTA2015",
  pages = 	 "373--384",
}

@InProceedings{MusluBM2013,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu and Yuriy Brun and Alexandra Meliou",
  authorASCII =	 "Kivanc Muslu and Yuriy Brun and Alexandra Meliou",
  title = 	 "Data debugging with continuous testing",
  crossref =     "FSE2013",
  pages = 	 "631--634",
  supersededby = "MusluBM2015",
}



@InProceedings{Muslu2013,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu",
  authorASCII =  "Kivanc Muslu",
  title = 	 "Integrating systematic exploration, analysis, and maintenance in software development",
  crossref =     "ICSE2013",
  pages = 	 "1389--1392",
}




@InProceedings{LoNZ2015,
  author = 	 "David Lo and Nachiappan Nagappan and Thomas Zimmermann",
  title = 	 "How practitioners perceive the relevance of software engineering research",
  crossref =     "FSE2015",
  pages = 	 "415-425",
}


@Article{Hoare1981,
  author = 	 "Charles Antony Richard Hoare",
  title = 	 "The emperor's old clothes",
  journal = 	 CACM,
  year = 	 1981,
  volume = 	 24,
  number = 	 2,
  pages = 	 "75--83",
  month = 	 feb,
}


@InProceedings{CaliskanIslamHLNVYG2015,
  author = 	 "Aylin Caliskan-Islam and Richard Harang and Andrew Liu and Arvind Narayanan and Clare Voss and Fabian Yamaguchi and Rachel Greenstadt",
  title = 	 "De-anonymizing programmers via code stylometry",
  crossref =     "USENIXSec2015",
  pages = 	 "255--270",
  abstract =
   "Source code authorship attribution is a significant privacy threat to
    anonymous code contributors. However, it may also enable attribution of
    successful attacks from code left behind on an infected system, or aid in
    resolving copyright, copyleft, and plagiarism issues in the programming
    fields. In this work, we investigate machine learning methods to
    de-anonymize source code authors of C/C++ using coding style. Our Code
    Stylometry Feature Set is a novel representation of coding style found in
    source code that reflects coding style from properties derived from
    abstract syntax trees.
    \par
    Our random forest and abstract syntax tree-based approach attributes more
    authors (1,600 and 250) with significantly higher accuracy (94\% and 98\%) on
    a larger data set (Google Code Jam) than has been previously
    achieved. Furthermore, these novel features are robust, difficult to
    obfuscate, and can be used in other programming languages, such as
    Python. We also find that (i) the code resulting from difficult programming
    tasks is easier to attribute than easier tasks and (ii) skilled programmers
    (who can complete the more difficult tasks) are easier to attribute than
    less skilled programmers.",
}












@InProceedings{MurphyHillZN2014,
  author = 	 "Emerson Murphy-Hill and Thomas Zimmermann and Nachiappan Nagappan",
  title = 	 "Cowboys, ankle sprains, and keepers of quality: How is video game development different from software development?",
  crossref =     "ICSE2014",
  pages = 	 "1--11",
}





@InProceedings{SeoSEAB2014,
  author =       "Hyunmin Seo and Caitlin Sadowski and Sebastian Elbaum and Edward Aftandilian and Robert Bowdidge",
  title =        "Programmers' build errors: A case study (at {Google})",
  crossref =     "ICSE2014",
  pages =     "724--734",
  abstract =
   "Building is an integral part of the software development
    process. However, little is known about the errors occurring in this
    process. In this paper, we present an empirical study of 26.6 million
    builds produced during a period of nine months by thousands of
    developers. We describe the workflow through which those builds are
    generated, and we analyze failure frequency, error types, and resolution
    efforts to fix those errors. The results provide insights on how a large
    organization build process works, and pinpoints errors for which further
    developer support would be most effective.",
}


@InProceedings{NarayananR2015,
  author =       "Krishna Narasimhan and Christoph Reichenbach",
  title =        "Copy and paste redeemed",
  crossref =     "ASE2015",
  pages =     "630-640",
}



@InProceedings{ChristakisMW2016,
  author =       "Maria Christakis and Peter M{\"u}ller and Valentin W{\"u}stholz",
  authorASCII =  "Maria Christakis and Peter Muller and Valentin Wustholz",
  authorASCII =  "Maria Christakis and Peter Mueller and Valentin Wuestholz",
  title =        "Guiding dynamic symbolic execution toward unverified program executions",
  crossref =     "ICSE2016",
  NEEDpages =     "*",
}


@InProceedings{MatichukMAJKS2015,
  author =       "Daniel Matichuk and Toby Murray and June Andronick and Ross Jeffery and Gerwin Klein and Mark Staples",
  title =        "Empirical study towards a leading indicator for cost of formal software verification",
  crossref =     "ICSE2015",
  NEEDpages =     "*",
}


@inproceedings{Pham14,
 author = {Pham, Raphael and Kiesling, Stephan and Liskin, Olga and Singer, Leif and Schneider, Kurt},
 title = {Enablers, Inhibitors, and Perceptions of Testing in Novice Software Teams},
 booktitle = {ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE)},
 year = {2014},
 isbn = {978-1-4503-3056-5},
 address = {Hong Kong, China},
 pages = {30--40},
 doi = {10.1145/2635868.2635925},
}


@inproceedings{Kery:2016:EPP:2901739.2903497,
 author = {Kery, Mary Beth and Le Goues, Claire and Myers, Brad A.},
 title = {Examining Programmer Practices for Locally Handling Exceptions},
 booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories},
 series = {MSR '16},
 year = {2016},
 isbn = {978-1-4503-4186-8},
 address  = {Austin, Texas},
 pages = {484--487},
 numpages = {4},
 url = {https://doi.acm.org/10.1145/2901739.2903497},
 doi = {10.1145/2901739.2903497},
 acmid = {2903497},
 keywords = {Boa, GitHub, Java exceptions, error handlers},
}

@inproceedings{Nakshatri:2016:AEH:2901739.2903499,
 author = {Nakshatri, Suman and Hegde, Maithri and Thandra, Sahithi},
 title = {Analysis of Exception Handling Patterns in Java Projects: An Empirical Study},
 booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories},
 series = {MSR '16},
 year = {2016},
 isbn = {978-1-4503-4186-8},
 address  = {Austin, Texas},
 pages = {500--503},
 numpages = {4},
 url = {https://doi.acm.org/10.1145/2901739.2903499},
 doi = {10.1145/2901739.2903499},
 acmid = {2903499},
 keywords = {Boa, GitHub, Java exception handling, best practices},
}



@InProceedings{GousiosSB2016,
  author =       "Gousios, Georgios and Storey, Margaret-Anne and Bacchelli, Alberto",
  title =        "Work practices and challenges in pull-based development:  the contributor's perspective",
  crossref =     "ICSE2016",
  pages =     "285--296",
}









@InProceedings{DeweyNH2015,
  author =       "Dewey, Kyle and Nichols, Lawton and Hardekopf, Ben",
  title =        "Automated data structure generation: Refuting common wisdom",
  crossref =     "ICSE2015",
  pages =     "32--43",
}


@InProceedings{YangXLCML2014,
  author =       "Yang, Wenhua and Xu, Chang and Liu, Yepang and Cao, Chun and Ma, Xiaoxing and Lu, Jian",
  title =        "Verifying Self-adaptive Applications Suffering Uncertainty",
  crossref =     "ASE2014",
  pages =     "199--210",
}


@InProceedings{MadsenTASM2016,
  author =       "Madsen, Magnus and Tip, Frank and Andreasen, Esben and Sen, Koushik and M{\o}ller, Anders",
  authorASCII =       "Madsen, Magnus and Tip, Frank and Andreasen, Esben and Sen, Koushik and Moller, Anders",
  title =        "Feedback-directed instrumentation for deployed {JavaScript} applications",
  crossref =     "ICSE2016",
  pages =     "899--910",
}


@article{Apel:2013:FDB:2508267.2508296,
 author = {Apel, Sven and Von Rhein, Alexander and Th\"{u}m, Thomas and K\"{a}stner, Christian},
 authorASCII = {Apel, Sven and Von Rhein, Alexander and Thum, Thomas and Kastner, Christian},
 title = {Feature-interaction detection based on feature-based specifications},
 journal = {Comput. Netw.},
 issue_date = {August, 2013},
 volume = {57},
 number = {12},
 month = aug,
 year = {2013},
 issn = {1389-1286},
 pages = {2399--2409},
 numpages = {11},
 url = {http://dx.doi.org/10.1016/j.comnet.2013.02.025},
 doi = {10.1016/j.comnet.2013.02.025},
 acmid = {2508296},
 publisher = {Elsevier North-Holland, Inc.},
 address = {New York, NY, USA},
 keywords = {Feature interaction, Feature orientation, Feature-based specification, Modularity, Software product lines},
}


@inproceedings{Johnson:2016:CCS:2950290.2950304,
 author = {Johnson, Brittany and Pandita, Rahul and Smith, Justin and Ford, Denae and Elder, Sarah and Murphy-Hill, Emerson and Heckman, Sarah and Sadowski, Caitlin},
 title = {A Cross-tool Communication Study on Program Analysis Tool Notifications},
 booktitle = {Proceedings of the 2016 24th ACM SIGSOFT International Symposium on Foundations of Software Engineering},
 series = {FSE 2016},
 year = {2016},
 isbn = {978-1-4503-4218-6},
 address  = {Seattle, WA, USA},
 pages = {73--84},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/2950290.2950304},
 doi = {10.1145/2950290.2950304},
 acmid = {2950304},
 keywords = {communication, human factors, program analysis tools},
}


@inproceedings{Siegmund:2014:UUS:2568225.2568252,
 author = {Siegmund, Janet and K\"{a}stner, Christian and Apel, Sven and Parnin, Chris and Bethmann, Anja and Leich, Thomas and Saake, Gunter and Brechmann, Andr{\'e}},
 title = {Understanding Understanding Source Code with Functional Magnetic Resonance Imaging},
 booktitle = {Proceedings of the 36th International Conference on Software Engineering},
 series = {ICSE 2014},
 year = {2014},
 isbn = {978-1-4503-2756-5},
 address  = {Hyderabad, India},
 pages = {378--389},
 numpages = {12},
 url = {https://doi.acm.org/10.1145/2568225.2568252},
 doi = {10.1145/2568225.2568252},
 acmid = {2568252},
 keywords = {Functional magnetic resonance imaging, program comprehension},
}



@InProceedings{BarrettKMHTP2004,
  author =       "Barrett, Rob and Kandogan, Eser and Maglio, Paul P. and Haber, Eben M. and Takayama, Leila A. and Prabaker, Madhu",
  title =        "Field studies of computer system administrators: Analysis of system management tools and practices",
  crossref =     "CSCW2004",
  pages =     "388--395",
}

@InProceedings{XiongHSC2012,
  author =       "Xiong, Yingfei and Hubaux, Arnaud and She, Steven and Czarnecki, Krzysztof",
  title =        "Generating range fixes for software configuration",
  crossref =     "ICSE2012",
  pages =     "58--68",
}

@InProceedings{WhitakerCG2004,
  author =       "Whitaker, Andrew and Cox, Richard S. and Gribble, Steven D.",
  title =        "Configuration debugging as search: finding the needle in the haystack",
  crossref =     "OSDI2004",
  pages =     "77-90",
}


@InProceedings{WangPCZW2004,
  author =       "Wang, Helen J. and Platt, John C. and Chen, Yu and Zhang, Ruyun and Wang, Yi-Min",
  title =        "Automatic misconfiguration troubleshooting with {PeerPressure}",
  crossref =     "OSDI2004",
  pages =     "245-257",
}


@InProceedings{RabkinK2011:ICSE,
  author =       "Rabkin, Ariel and Katz, Randy",
  title =        "Static extraction of program configuration options",
  crossref =     "ICSE2011",
  pages =     "131--140",
}


@InProceedings{RabkinK2011:ASE,
  author =       "Rabkin, Ariel and Katz, Randy",
  title =        "Precomputing possible configuration error diagnoses",
  crossref =     "ASE2011",
  pages =     "193--202",
}


@InProceedings{KellerUC2008,
  author =       "Keller, Lorenzo and Upadhyaya, Prasang and Candea, George",
  title =        "{ConfErr}: A tool for assessing resilience to human configuration errors",
  crossref =     "DSN2008",
  pages =     "157--166",
}


@Article{XiongZHSWC2014,
  author =       "Yingfei Xiong and Hansheng Zhang and Arnaud Hubaux and Steven She and Jie Wang and Krzysztof Czarnecki",
  title =        "Range fixes: Interactive error resolution for software configuration",
  journal =      TSE,
  year =         2014,
  volume =    41,
  number =    6,
  pages =     "603-619",
  month =     jun,
}

@InProceedings{HubauxXC2012,
  author =       "Hubaux, Arnaud and Xiong, Yingfei and Czarnecki, Krzysztof",
  title =        "A user survey of configuration challenges in {Linux} and {eCos}",
  crossref =     "VaMoS2012",
  pages =     "149--155",
}


@InProceedings{HentschelHB2016,
  author = 	 "Hentschel, Martin and H{\"a}hnle, Reiner and Bubel, Richard",
  authorASCII =  "Hentschel, Martin and Hahnle, Reiner and Bubel, Richard",
  title = 	 "An empirical evaluation of two user interfaces of an interactive program verifier",
  crossref =  "ASE2016",
  pages = 	 "403--413",
}


@InProceedings{BuseW2008,
  author = 	 "Buse, Raymond P.L. and Weimer, Westley R.",
  title = 	 "A metric for software readability",
  crossref =  "ISSTA2008",
  pages = 	 "121--130",
}

@Article{BuseW2010,
  author = 	 "Buse, Raymond P. L. and Weimer, Westley R.",
  title = 	 "Learning a Metric for Code Readability",
  journal = 	 TSE,
  year = 	 2010,
  volume = 	 36,
  number = 	 4,
  pages = 	 "546--558",
  month = 	 jul,
  abstract =
   "In this paper, we explore the concept of code readability and investigate
    its relation to software quality. With data collected from 120 human
    annotators, we derive associations between a simple set of local code
    features and human notions of readability. Using those features, we
    construct an automated readability measure and show that it can be 80
    percent effective and better than a human, on average, at predicting
    readability judgments. Furthermore, we show that this metric correlates
    strongly with three measures of software quality: code changes, automated
    defect reports, and defect log messages. We measure these correlations on
    over 2.2 million lines of code, as well as longitudinally, over many
    releases of selected projects. Finally, we discuss the implications of this
    study on programming language design and engineering practice. For example,
    our data suggest that comments, in and of themselves, are less important
    than simple blank lines to local judgments of readability.",
}






@InProceedings{GoffiGMPT2014,
  author = 	 "Goffi, Alberto and Gorla, Alessandra and Mattavelli, Andrea and Pezz{\`e}, Mauro and Tonella, Paolo",
  title = 	 "Search-based synthesis of equivalent method sequences",
  crossref =  "FSE2014",
  pages = 	 "366--376",
}


@inproceedings{Gopstein:2017:UMS:3106237.3106264,
 author = {Gopstein, Dan and Iannacone, Jake and Yan, Yu and DeLong, Lois and Zhuang, Yanyan and Yeh, Martin K.-C. and Cappos, Justin},
 title = {Understanding Misunderstandings in Source Code},
 booktitle = {Proceedings of the 2017 11th Joint Meeting on Foundations of Software Engineering},
 series = {ESEC/FSE 2017},
 year = {2017},
 isbn = {978-1-4503-5105-8},
 location = {Paderborn, Germany},
 pages = {129--139},
 numpages = {11},
 url = {https://doi.acm.org/10.1145/3106237.3106264},
 doi = {10.1145/3106237.3106264},
 acmid = {3106264},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Program Understanding, Programming Languages},
}


@InProceedings{DiFranceGRG2017,
  author = 	 "Di Franco, Anthony and Guo, Hui and Rubio-Gonz\'{a}lez, Cindy",
  authorASCII = 	 "Di Franco, Anthony and Guo, Hui and Rubio-Gonzalez, Cindy",
  title = 	 "A comprehensive study of real-world numerical bug characteristics",
  crossref =  "ASE2017",
  pages = 	 "509-519",
}






@InProceedings{ArcuriB2011,
  author = 	 "Arcuri, Andrea and Briand, Lionel",
  title = 	 "A practical guide for using statistical tests to assess randomized algorithms in software engineering",
  crossref =  "ICSE2011",
  pages = 	 "1--10",
}


@InProceedings{ReyesDFJ2018,
  author = 	 "Reyes, Rolando P. and Dieste, Oscar and Fonseca, Efra\'{\i}n R. and Juristo, Natalia",
  title = 	 "Statistical errors in software engineering experiments: A preliminary literature review",
  crossref =  "ICSE2018",
  pages = 	 "1195--1206",
}









@InProceedings{GilR2019,
  author = 	 "Yossi Gil and Ori Roth",
  title = 	 "Fling --- A fluent {API} generator",
  crossref =  "ECOOP2019",
  pages = 	 "13:1--13:25",
}


@Book{McConnell:1993:CCP,
  author =       "Steve McConnell",
  title =        "Code complete:  A practical handbook of software
                 construction",
  publisher =    "Microsoft Press",
  address =      "Redmond, WA, USA",
  year =         1993,
  ISBN =         "1-55615-484-4",
  LCCN =         "QA76.76.D47 M39 1993",
  bibdate =      "Sat Aug 31 09:15:22 MDT 1996",
  price =        "US\$35.00, CDN\$47.95",
  keywords =     "computer software -- development -- handbooks,
                 manuals, etc",
}

@Book{McConnell2004,
  author =       "Steve McConnell",
  title =        "Code complete:  A practical handbook of software
                 construction",
  publisher =    "Microsoft Press",
  address =      "Redmond, WA, USA",
  year =         2004,
  ISBN =         "0-7356-1967-0",
  edition = 	 "2nd",
}


@Article{Iverson1980,
  author = 	 "Iverson, Kenneth E.",
  title = 	 "Notation as a tool of thought",
  journal = 	 CACM,
  year = 	 1930,
  volume = 	 23,
  number = 	 8,
  pages = 	 "444-465",
  month = 	 aug,
}




@Article{SadowskiAEMCJ2018,
  author = 	 "Sadowski, Caitlin and Aftandilian, Edward and Eagle, Alex and Miller-Cushon, Liam and Jaspan, Ciera",
  title = 	 "Lessons from building static analysis tools at {Google}",
  journal = 	 CACM,
  year = 	 2018,
  volume = 	 61,
  number = 	 4,
  pages = 	 "58-66",
  month = 	 mar,
}


@inproceedings{10.1109/ICSE.2019.00067,
author = {Ghorbani, Negar and Garcia, Joshua and Malek, Sam},
title = {Detection and Repair of Architectural Inconsistencies in Java},
year = {2019},
publisher = {IEEE Press},
url = {https://doi.org/10.1109/ICSE.2019.00067},
doi = {10.1109/ICSE.2019.00067},
booktitle = {Proceedings of the 41st International Conference on Software Engineering},
pages = {560-571},
numpages = {12},
location = {Montreal, Quebec, Canada},
series = {ICSE ’19}
}




@InProceedings{QiuNBSV2019,
  author = 	 "Qiu, Huilian Sophie and Nolte, Alexander and Brown, Anita and Serebrenik, Alexander and Vasilescu, Bogdan",
  title = 	 "Going farther together: The impact of social capital on sustained participation in open source",
  crossref =  "ICSE2019",
  pages = 	 "688-699",
}







@Book{Booch1991,
  author = 	 "Booch, Grady",
  title = 	 "Object Oriented Design with Applications",
  publisher = 	 "Benjamin/Cummings",
  year = 	 "1991",
}


























@InProceedings{LoreyRF2022,
  author = 	 "Lorey, Tobias and Ralph, Paul and Felderer, Michael",
  title = 	 "Social science theories in software engineering research",
  crossref =  "ICSE2022",
  pages = 	 "1994–2005",
}




@InProceedings{SrinivasanR2014,
  author = 	 "Srinivasan, Venkatesh and Reps, Thomas",
  title = 	 "Recovery of class hierarchies and composition relationships from machine code",
  crossref =  "CC2014",
  pages = 	 "61--84",
  abstract =
   "We present a reverse-engineering tool, called Lego, which
    recovers class hierarchies and composition relationships from
    stripped binaries. Lego takes a stripped binary as input, and uses
    information obtained from dynamic analysis to (i) group the
    functions in the binary into classes, and (ii) identify
    inheritance and composition relationships between the inferred
    classes. The software artifacts recovered by Lego can be
    subsequently used to understand the object-oriented design of
    software systems that lack documentation and source code, e.g., to
    enable interoperability. Our experiments show that the class
    hierarchies recovered by Lego have a high degree of
    agreement---measured in terms of precision and recall---with the
    hierarchy defined in the source code.",
}











@InProceedings{Weimer2006,
  author = 	 "Weimer, Westley",
  title = 	 "Patches as Better Bug Reports",
  crossref =  "GPCE2006",
  pages = 	 "181-190",
}




@Misc{ErrorProneTool,
  author = 	 "Google",
  title = 	 "Error Prone",
  howpublished = "\url{https://errorprone.info/}",
  month = 	 jan,
  year = 	 2018,
}






@InProceedings{ZhangXZLXZ2024,
  author = 	 "Zejun Zhang and Zhenchang Xing and Dehai Zhao and Qinghua Lu and Xiwei Xu and Liming Zhu",
  title = 	 "Hard to Read and Understand {Pythonic} Idioms? {DeIdiom} and Explain Them in Non-Idiomatic Equivalent Code",
  crossref =  "ICSE2024",
  pages = 	 "1011-1011",
  abstract =
   "The Python community strives to design pythonic idioms so that Python users
    can achieve their intent in a more concise and efficient way. According to
    our analysis of 154 questions about challenges of understanding pythonic
    idioms on Stack Overflow, we find that Python users face various challenges
    in comprehending pythonic idioms. And the usage of pythonic idioms in 7,577
    GitHub projects reveals the prevalence of pythonic idioms. By using a
    statistical sampling method, we find pythonic idioms result in not only
    lexical conciseness but also the creation of variables and functions, which
    indicates it is not straightforward to map back to non-idiomatic code. And
    usage of pythonic idioms may even cause potential negative effects such as
    code redundancy, bugs and performance degradation. To alleviate such
    readability issues and negative effects, we develop a transforming tool,
    DeIdiom, to automatically transform idiomatic code into equivalent
    non-idiomatic code. We test and review over 7,572 idiomatic code instances
    of nine pythonic idioms (list/set/dict-comprehension, chain-comparison,
    truth-value-test, loop-else, assign-multi-targets, for-multi-targets, star),
    the result shows the high accuracy of DeIdiom. Our user study with 20
    participants demonstrates that explanatory non-idiomatic code generated by
    DeIdiom is useful for Python users to understand pythonic idioms correctly
    and efficiently, and leads to a more positive appreciation of pythonic
    idioms.",
}


@InProceedings{AsthanaSVAH2023,
  author = 	 "Asthana, Sumit and Sajnani, Hitesh and Voyloshnikova, Elena and Acharya, Birendra and Herzig, Kim",
  title = 	 "A case study of developer bots: motivations, perceptions, and challenges",
  crossref =  "FSE2023",
  pages = 	 "1268-1280",
}



@InProceedings{PertsevaCZC2024,
  author = 	 "Pertseva, Elizaveta and Chang, Melinda and Zaman, Ulia and Coblenz, Michael",
  title = 	 "A theory of scientific programming efficacy",
  crossref =  "ICSE2024",
  NEEDpages = 	 "*",
}


@INPROCEEDINGS{1046334,
  author={Blackwell, A.F.},
  booktitle={Proceedings IEEE 2002 Symposia on Human Centric Computing Languages and Environments},
  title={First steps in programming: a rationale for attention investment models},
  year={2002},
  volume={},
  number={},
  pages={2-10},
  keywords={Investments;Programming profession;Mathematical programming;Psychology;Books;Humans;Laboratories;Microcomputers;Microprocessors;Electronic switching systems},
  doi={10.1109/HCC.2002.1046334}}
  I disagree with the paper's claim that "most [computer] programming deals with
problems that we would not now consider to be mathematical.", because there is
always a mathematical model that the program deals with.  The paper gives no
examples.
  The paper asks 3 questions.  I think the questions are in the wrong answer,
and thus lead to definitions that are not very useful.
 1. Who is a programmer?  "all computer users ought to be regarded as potential
programmers, whose tools differ only in their usability for that purpose".
 2. What is a programming language?  "almost all major software
applications could now be recognized as including programming languages".
 3. What is a programming activity? The paper answers that it's anything anyone
uses the term "programming" for, including programming a VCR, programming a
microwave, programming a car radio, or writing HTML.  This ignores the obvious
fact that "programming" is a homonym in English.
  That bit of wordplay about "programming" renders the paper useless for
thinking about computer programming in specific.  However, the paper is still
useful insofar as it applies to many or all intellectual tasks that humans
perform.  The paper could have given a useful definition such as "a program is
something that runs multiple times on different inputs", and then an editor
macro and a spreadsheet would count but HTML and the buttons pressed on a
microwave would not.
  The key idea of the paper is in paragraph 6:  "This paper asks instead what is
distinctive about the cognitive tasks involved in programming," The paper states
that the cognitive features of "programming" (i.e., any intellectual activity)
are "(a) loss of the benefits of direct manipulation and (b) introduction of
notational elements to represent abstraction", and (c) abstraction, or factoring
out repeated parts of a complex activity.  Even gestures, button presses, and
"linguistic and representational strategies" count as "notational elements".
  "The Attention Investment model is a decision-theoretic account of programming
behavior. It offers a cost/benefit analysis of abstraction use that allows us to
predict the circumstances in which users will choose to engage in programming
activities, as well as helping tool designers to facilitate users’ investment
decisions and reduce the risks associated with those decisions. As with any
decision theoretic account, this depends on the availability of some currency -
a measure according to which cost, risk, pay-off etc can be calculated and
compared."  The paper cites "earlier papers on attention investment", but I
guess those are not (capitalized) Attention Investment.  This model seems
high-level and glaringly obvious:  people do a risk-benefit analysis before
choosing their course of action, such as which financial instruments to invest
in, or whether to go to the hardware store to purchase a new tool or make do
with the tools in their toolbox.  Was this novel at the time?  Or novel as
applied to programming?
  They built a "model" of many agents doing a spell-correction task, with each
agent working at a different location.  (Two different actions are to do a
single edit, or to pop up a search-and-replace box to correct all instances of
the misspelling.)  I don't see what information this model conveys, except that
they achieved, via a multi-agent process, a result that they say reflects
unconscious decisions that human would take.  I don't see that the model enables
prediction or yields insight.
  The paper is twice as long as it needs to be, due to waffling generalities.

@article{doi:10.1080/13639080020028747,
author = {Yrjö Engeström},
title = {Expansive Learning at Work: Toward an activity theoretical reconceptualization},
journal = {Journal of Education and Work},
volume = {14},
number = {1},
pages = {133--156},
year = {2001},
publisher = {Routledge},
doi = {10.1080/13639080020028747},
URL = {https://www.tandfonline.com/doi/abs/10.1080/13639080020028747},
eprint = {https://www.tandfonline.com/doi/pdf/10.1080/13639080020028747}
}






@Article{Perlow1999,
  author =       {Leslie A. Perlow},
  title =        {The Time Famine: Toward a Sociology of Work Time},
  journal =      {Administrative Science Quarterly},
  year =         1999,
  volume =    44,
  number =    1,
  pages =     {57-81},
  abstract =
  {This paper describes a qualitative study of how people use their time at
    work, why they use it this way, and whether their way of using time is
    optimal for them or their work groups. Results of a nine-month field study
    of the work practices of a software engineering team revealed that the
    group's collective use of time perpetuated its members' ``time famine,'' a
    feeling of having too much to do and not enough time to do it. Engineers had
    difficulty getting their individual work done because they were constantly
    interrupted by others. A crisis mentality and a reward system based on
    individual heroics perpetuated this disruptive way of interacting. Altering
    the way software engineers used their time at work, however, enhanced their
    collective productivity. This research points toward a “sociology of work
    time,” a framework integrating individuals' interdependent work patterns and
    the larger social and temporal contexts. The theoretical and practical
    implications of a sociology of work time are explored.},
}


@article{10.1145/3720421,
author = {Cohen, Sam and Chugh, Ravi},
title = {Code Style Sheets: CSS for Code},
year = {2025},
issue_date = {April 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3720421},
doi = {10.1145/3720421},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {87},
numpages = {29},
keywords = {CSS, Code Style Sheets, Haskell, Structure Editors, Text Layout}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% LocalWords Dictionary
%%%

% LocalWords: GhezziJM Ghezzi Mehdi Jazayeri Mandrioli NJ ISBN Belady BasitRJ Xu
% LocalWords: Sommerville Wokingham InProceedings VandevoordeG Guttag Hamid STL
% LocalWords: Vandevoorde booktitle dec StreckenbachS Mirko Gregor al Basit XVCL
% LocalWords: Streckenbach Snelting KABA addr Kataoka ICSM KataokaEGN Damith TSE
% LocalWords: Kataoka's Kremenek Ashcraft Junfeng Engler FSE KremenekAYE ErnstBN
% LocalWords: Rajapakse Jarzabek NEEDpages CCFinder HenkelD Henkel Bod Balzer
% LocalWords: Amer Diwan CatchUp BCELMethod MandelinXBK Mandelin Bodik Cheatham
% LocalWords: Rastislav Kimmelman authorSEARCHABLE Jungloid jungloid SW Boehm
% LocalWords: jungloids composable int TRW's jul BalzerCG nov sep Walkthroughs
% LocalWords: TechReport UWCSE OPTkey UWCSEaddr aug Opdyke CC MensT XP BasitJ
% LocalWords: Tourw feb Tourwe Misc Borland howpublished JavaOne jun Robillard
% LocalWords: ChowN Kingsum ObjectWindows widenings datapoints RutarAF Livshits
% LocalWords: Rutar Almazan JLint PMD KimSNM Miryung dnsjava higo ist LivshitsZ
% LocalWords: Vibha Sazawal osaka ac jp ISSRE Bandera ESC overclaim co DynaMine
% LocalWords: asitJ Itemset FIM IDs MayrandLM tokenization java Zimmermann baz
% LocalWords: OpenMBeanAttributeInfoSpport ObjectFactory jEdit checkins itemset
% LocalWords: OpenMBeanParameterInfoSpport Apriori checkin SullivanGSCSTR Cai
% LocalWords: Yuanyuan Yuanfang Macneil Shonle Nishit Tewari Hridesh LiZ Zhou
% LocalWords: Rajan un AspectJ Zhenmin PR PostgreSQL HTTP Engler's FireWire rba
% LocalWords: FindBugs Braude Budgen CoplienS Coplien FelleisenFFK Orla IEEE UI
% LocalWords: Felleisen Findler CohoonD Cohoon KuhnGG Greevy PCODA LSI Urbana
% LocalWords: Taghi Khoshgoftaar Ruqun Shan Faundez Sekirkin Boland MMR Mens QA
% LocalWords: EisenbarthKS Eisenbarth Koschke GreevyD phane Ducasse oct APIs Ko
% LocalWords: CMSR GreevyDG WongGH Gokhale Horgan ZaidmanCDP Zaidman Champaign
% LocalWords: Toon Calders Demeyer Paredaens Webmining webmining JMeter Parnin
% LocalWords: Kleinberg's HaRDRCRW Jungwoo Rossbach Indrajit Hany Inlining DOI
% LocalWords: Witchel Borland's authorASCII MurphyHillPB toolsmiths downcasting
% LocalWords:  refactorable Englewood McGraw subsequences getters checkable Yan
% LocalWords:  Winograd ApiwattanapongOH Taweesup Apiwattanapong supersededby
% LocalWords:  ASEjournal JDiff usesDaikonAsTestSubject JABA XuRTQ Guoqing Feng
% LocalWords:  Atanas Rountev Qin checkpointed DwyerKE Dwyer Kinneer Elbaum KoM
% LocalWords:  optimizine FSAs Emre AjaxScope Kiciman SOSP redeployabiliy Manos
% LocalWords:  Whyline timeline JFrame prefast JonesH totalpassed totalfailed
% LocalWords:  RenierisR Renieris Reiss iComment Gopal Radatz issn doi ADT isbn
% LocalWords:  JeongKZ Jeong Gaeul Sunghun WalradS Walrad Strom SCM BallKPS Siy
% LocalWords:  NagappanBZ Nagappan Nachiappan Rochkind IEEETSE SCCS BaconCPR LD
% LocalWords:  Yiling Parkes Rao Malvika Sakthivel CACM apr FritzM subtable csv
% LocalWords:  DSketch Cossette ApelLBLK2011 Apel Jorg Liebig Brandl Lengauer
% LocalWords:  Putnam78 BalzerCG83 Kastner Semistructured FSE2011 FSE2011addr
% LocalWords:  FSE2011date semistructured FSTGENERATOR FSTMERGE Boehm87 Su NPEs
% LocalWords:  top10 Griswold91 Opdyke92 Fowler2000 Parr94 CC94 CC94addr ICSM96
% LocalWords:  CC94date MensT2004 StreckenbachS2004 OOPSLA2004 OOPSLA2004addr
% LocalWords:  OOPSLA2004date KataokaEGN01 HenkelD2005 ICSE2005 ICSE2005addr ek
% LocalWords:  ICSE2005date Perkins2005 MurphyHillPB2009 ICSE2009 ICSE2009addr
% LocalWords:  ICSE2009date researchers' Borland2004 ChowN96 ICSM96addr FSE2005
% LocalWords:  ICSM96date MandelinXBK2005 PLDI2005 PLDI2005addr PLDI2005date AO
% LocalWords:  RutarAF2004 ISSRE2004 ISSRE2004addr ISSRE2004date tradeoffs NPE
% LocalWords:  KimSNM2005 FSE2005addr FSE2005date GhezziJM91 Lamb88 Erlikh SNK
% LocalWords:  Pressman92 VandevoordeG94 runtime KremenekAYE2004 FSE2004 Przyby
% LocalWords:  FSE2004addr FSE2004date BasitRJ2005 parameterization ErnstBN2002
% LocalWords:  BasitJ2005 Baker95 MayrandLM96 dependences LivshitsZ2005 AOP OOP
% LocalWords:  SullivanGSCSTR2005 Przybylek2011 Przybylek FASE2011 FASE2011addr
% LocalWords:  FASE2011date modularizing modularizable modularized refactored
% LocalWords:  LOC LCOM OO LiZ2005 Simon96 Braude2003 Budgen2003 KuhnGG2005 SRC
% LocalWords:  Winograd1996 CoplienS1995 FelleisenFFK2001 CohoonD2005 PCODA2005
% LocalWords:  PCODA2005addr PCODA2005date dimensionality ISSRE'00 GreevyD2005
% LocalWords:  EisenbarthKS2003 CMSR2005 CMSR2005addr CMSR2005date GreevyDG2005
% LocalWords:  ICSM2005 ICSM2005addr ICSM2005date WongGH2000 ZaidmanCDP2005 ASE
% LocalWords:  HaRDRCRW2007 PLDI2007 PLDI2007addr PLDI2007date backtrace Orso
% LocalWords:  unscalable LaTeX's ApiwattanapongOH2004 Alessandro Harrold Kamei
% LocalWords:  differencing ASE2004 ASE2004addr ASE2004date XuRTQ2007 FSE2007
% LocalWords:  ApiwattanapongOH2007 checkpointing FSE2007addr FSE2007date Ko Ko
% LocalWords:  DwyerKE2007 ICSE2007 ICSE2007addr ICSE2007date KoM2008 ICSE2008
% LocalWords:  ICSE2008addr ICSE2008date Weise's JonesH2005 ASE2005 ASE2005addr
% LocalWords:  ASE2005date RenierisR2003 unexamined NLP OOPSLA2009 Ko Ko Yutaro
% LocalWords:  OOPSLA2009companion OOPSLA2009date Downcasts equational AWT INIT
% LocalWords:  downcasts Cook2009 OOPSLA2009addr Brooks1975 JeongKZ2009 FSE2009
% LocalWords:  FSE2009addr FSE2009date WalradS2002 BallKPS97 ICSE97addr Zeller
% LocalWords:  ICSE97date NagappanBZ2006 Andreas ICSE2006 ICSE2006addr ICSE2010
% LocalWords:  ICSE2006date Rochkind75 BaconCPR2009 Sakthivel2007 FritzM2010 Ko
% LocalWords:  ICSE2010addr ICSE2010date panopticon Norman90 PTRSLB Khaled El
% LocalWords:  Emam Saida Benlarbi Nishith Goel Shesh Rai rg stner ost Bj orn
% LocalWords:  Regnell Claes Wohlin Runeson PSP Pankratius Scala Goues Vogt Yeh
% LocalWords:  LeGouesDVFW2012 Weimer Westley ICSE2012 ICSE2012addr Tsung Roehm
% LocalWords:  ICSE2012date Hsiang Sikuli filenames Tobias Tiarks Rainer Walid
% LocalWords:  Maalej I2 Erlikh2000 Eastwood1993 Moad1990 Moad AFIPS Abreu ś18
% LocalWords:  LientzS1981 Lientz Bennet ZelkowitzSG1979 Zelkowitz COCOMO Cok
% LocalWords:  Seacord Plakosh McConnell2006 Jones2011 Su2006 ParninO2011 RAC
% LocalWords:  ISSTA2011 ISSTA2011date ISSTA2011addr Tetris NanoXML Rui Kazuki
% LocalWords:  ASE2003 ASE2003date ASE2003addr SteimannFA2013 Steimann T1 Kang
% LocalWords:  Frenkel locators ISSTA2013 ISSTA2013date ISSTA2013addr Yoo Choi
% LocalWords:  ZhangZK2013 Lingming Khurshid Sarfraz OOPSLA2013 Stasko P' BAPP
% LocalWords:  OOPSLA2013date OOPSLA2013addr JonesHS2002 ICSE2002 DBLP T2 kPAR
% LocalWords:  ICSE2002date ICSE2002addr YooNH2011 optimisation Dstar n11 TBar
% LocalWords:  n10 n01 DiGiuseppeJ2015 DiGiuseppe JEmpiricalSE Foo Omesh Aleti
% LocalWords:  SanthiarPK2014 Santhiar Anirudh Pandita Kanade Aditya tmp Karri
% LocalWords:  normf DoubleMatrix norm2 inv SimpleMatrix T3 mult Ghafari Dolan
% LocalWords:  GhafariGMT2014 Mocci Tamburrelli ICPC2014 ICPC2014date Pmd Luan
% LocalWords:  ICPC2014addr Rahman Khatri Devanbu Jlint foo Przybyłek Vo SeAPR
% LocalWords:  Jlint TanYKZ2007 SOSP2007 SOSP2007date SOSP2007addr JB10 Matias
% LocalWords:  Garretón GenProg Schulte DiLorenzo ASPLOS'13 ClearView Vu Kells
% LocalWords:  segfault underperforms ChangYM2010 CHI2010 CHI2010date Jne conf
% LocalWords:  CHI2010addr inproceedings Jalbert Proc Zhendong POPL'13 QP UIST
% LocalWords:  bessel asympx GSL Arjun Guha ReitBlatt OpenFlow NetCore lu json
% LocalWords:  ICSE'05 LaToza learnability JohnsonSMHB2013 Yoonki PREfix Rafal
% LocalWords:  Bowdidge ICSE2013 ICSE2013date ICSE2013addr BushPS2000 Zou Eval
% LocalWords:  Gorla Corapi Magee Katsumi Inoue NoMPRoL D'Ippolito Khomh Vesna
% LocalWords:  Braberman Foutse Dhaliwal Tejinder Ying numpages url acmid Theo
% LocalWords:  Piscataway Mika antyl Emelie Engstr RRs TRs Jiaping GMA de Ko Ko
% LocalWords:  Mcilroy dex2jar ASM regexes recharg batt ery RQ1 radaee af Ko
% LocalWords:  pdf Sonal Mahajan ICST PID mockups Fogarty's Huyen OLED rn Lorge
% LocalWords:  Smartphones smartphones Nyx Julien IoT cloudlets cloudlet Bowes
% LocalWords:  PDS multihop metadata Nirmalya Archan Misra Sajal Das Jit Fixie
% LocalWords:  Biswas PerCom QoINF QoINFs MusluBM2015 Meliou ISSTA2015 Ay Madey
% LocalWords:  ISSTA2015date ISSTA2015addr MusluBM2013 FSE2013 Nachi Liu Saini
% LocalWords:  FSE2013date FSE2013addr MusluBNC2014 Jacek Czerwonka Hoare
% LocalWords:  ICSE2014 ICSE2014date ICSE2014addr Muslu2013 LoNZ2015 Voss
% LocalWords:  FSE2015 FSE2015date FSE2015addr Hoare1981 Aylin Caliskan Pearce
% LocalWords:  CaliskanIslamHLNVYG2015 Harang Narayanan Yamaguchi Palyart
% LocalWords:  Greenstadt anonymizing stylometry USENIXSec2015 copyleft Ramesh
% LocalWords:  USENIXSec2015date USENIXSec2015addr anonymize NIER UMass Gavitt
% LocalWords:  anonymization Einar Høst Bjarte Østvold containsField Jin Baldi
% LocalWords:  findField getField Tianyin Xuepeng Shankar Pasupathy Rukma
% LocalWords:  Talwadker FlexJava Jongse Hadi Esmaeilzadeh Xin Mayur Naik
% LocalWords:  EnerJ Bornholt Stolee MurphyHillZN2014 Bixie Philipp ummer
% LocalWords:  Schaf Ruemmer Schaef Joa Shuvendu Lahiri ClusterChanges Qi
% LocalWords:  Estler Nordio Furia Wenhua Yepang Chun Cao Xioxing Jian AE
% LocalWords:  LDA ESEM HostRW2000 Runeson2003 Keele SalmanTMJ2015 Iflaah
% LocalWords:  Salman Tosun Misirli Juristo Ayse ICSE2015 ICSE2015date E1
% LocalWords:  ICSE2015addr TLD TDD1 TDD2 Kitchenham Brereton judgement Kirbas
% LocalWords:  Spearman Linkman EBSE ICSE04 RQ2 RQ3 RQ4 Magne Jørgensen Serkan
% LocalWords:  Pretorius Rialette Niazi Softw Technol Butterworth Prem E2
% LocalWords:  Heinemann Zheng Rahmanet RenieresR2003 Tien Duy Grunske S1
% LocalWords:  SBFL Ochiai BrunE2004 jan Nath Domingos AAAI TFLMs Zichao NIfTI
% LocalWords:  QiLAR2015 Achour RSRepair SPR Hwei Hiroaki Yoshida Mukul Pagano
% LocalWords:  Prasad Abhik Roychoudhury CoREBench Ferdian Thung Chu libm
% LocalWords:  overfit TrpAutoRepair IntroClass overfits Jlint Daming Seo
% LocalWords:  Xinrui Yingfei Xiong glibc predictiveness SeoSEAB2014 Pex Latoza
% LocalWords:  Hyunmin NarayananR2015 Narasimhan Reichenbach ASE2015 DSE Parnas
% LocalWords:  ASE2015date ASE2015addr forego Clousot DSE's Christakis js
% LocalWords:  ChristakisMW2016 ller stholz undertested Jlint Wustholz ie
% LocalWords:  Wuestholz ICSE2016 ICSE2016date ICSE2016addr Matichuk Pham
% LocalWords:  MatichukMAJKS2015 Andronick Gerwin Pham14 Kiesling Liskin Perlow
% LocalWords:  Kery Nakshatri Suman Hegde Maithri Thandra Sahithi JDK's Nowack
% LocalWords:  InterruptedException GousiosSB2016 Gousios Georgios Storey
% LocalWords:  Bacchelli PRs Magnus Esben Andreasen Koushik Møller Ciera
% LocalWords:  Tricorder Jaspan Söderberg Xie SFL Kuo SBSE SSBSE Taehoon
% LocalWords:  Byeongcheol Kwak Yiru Jeon Bongsuk Yunho Moonzoo Hardekopf
% LocalWords:  DeweyNH2015 CLP rotateLeft AElem CElem Korat UDITA ASE2014
% LocalWords:  YangXLCML2014 Xiaoxing ASE2014date ASE2014addr Moller P5 blue''
% LocalWords:  MadsenTASM2016 CROWDIE Rosso untracking Gitless async von
% LocalWords:  Gitless's Rhein astner Aniruddh Lawrance behaviour favour
% LocalWords:  idealised localisation webserver Thum Comput Netw Elsevier
% LocalWords:  Rahul Denae Heckman EclEmma Bethmann Anja Leich Saake Andr
% LocalWords:  Brechmann Brodmann MIS LientzS ZelkowitzSG Gannon Yourdon
% LocalWords:  Papaccio crossref Productivities HostRW Bjorn SalmanTMJ RQ
% LocalWords:  Siegmund Tarvo Mockus Amritanshu Agrawal datapoint ParninO
% LocalWords:  hyperparameters SMOTUNED RenieresR SteimannFA Friedrich TF
% LocalWords:  ZhangZK JonesHS YooNH Nilsson Harman DiGiuseppeJ BrunE Xia
% LocalWords:  KochharXLL Kochhar Pavneet Shanping LongR Ren Jiang Xuan Hadeel
% LocalWords:  diffoscope wrt IDF RepLoc Guix LeGouesDVFW ASPLOS QiLAR JB
% LocalWords:  Overfitting overfitting TianR Tian Yuchi Baishakhi ErrDoc
% LocalWords:  ErroDoc Motwani Manish Sankaranarayanan Nopol SanthiarPK SimFix
% LocalWords:  GhafariGMT Giordano ICPC FASE OOPSLACompanion PMESSE CBCD
% LocalWords:  ApelLBLK ChangYM JohnsonSMHB BushPS Domenico Alessandra Yu
% LocalWords:  Uchitel Bram Kai Gui Mei Halfond dex wifi Payton Proximal
% LocalWords:  middleware datums MusluBM MusluBNC LoNZ USENIXSec Blanc Yi
% LocalWords:  CaliskanIslamHLNVYG Sadowski Likert MurphyHillZN SeoSEAB Farima
% LocalWords:  changesets Aftandilian NarayananR Christoph Kellogg's Hong
% LocalWords:  ChristakisMW MatichukMAJKS IOException SQLException Madsen
% LocalWords:  GousiosSB Anders Gogh Springer DeweyNH Lawton dequeue Shimizu
% LocalWords:  YangXLCML MadsenTASM Gunter BarrettKMHTP IEEESoftware Yasutaka
% LocalWords:  Kandogan Eser Maglio Takayama Prabaker Madhu CSCW XiongHSC
% LocalWords:  Hubaux Arnaud Czarnecki Krzysztof WhitakerCG OSDI WangPCZW
% LocalWords:  Platt Ruyun misconfiguration PeerPressure RabkinK Rabkin Yadong
% LocalWords:  Katz KellerUC Upadhyaya Prasang Candea ConfErr DSN Jie KeY
% LocalWords:  XiongZHSWC Hansheng HubauxXC eCos VaMoS HentschelHB hnle Hitesh
% LocalWords:  Hentschel Reiner Bubel Hahnle SED BuseW Buse Sainyam enums
% LocalWords:  Galhotra Themis GoffiGMPT Goffi Mattavelli Pezz Tonella Naoyasu
% LocalWords:  Paolo Gopstein Iannacone DeLong Zhuang Yanyan Cappos qwert
% LocalWords:  Paderborn Weimer's linter formatter DiFranceGRG Guo Rubio
% LocalWords:  Gonz lez Fiorella Zampetti Gabriele Bavota Massimiliano MyBatis
% LocalWords:  Penta Lanza Oliveto CoreNLP dev nd KochharXLL2016 sw Ubayashi
% LocalWords:  ISSTA2016 LongR2016 unreproducible TianR2017 FSE2017 ICSME2021
% LocalWords:  Motwani2017 Sandhya CodeCarbonCopy Stelios Sidiroglou linenumber
% LocalWords:  Douskos Lahtinen typeclass boolean PFInfo Property1 Kashiwa
% LocalWords:  Property2 SCST jfreechart jOcular Smalltalk evidence'' Aldeida
% LocalWords:  Tonder Rijnard FootPatch Infer's FootPatch's Amanj Hua analyse
% LocalWords:  Sherwany Nosheen Zaza Nystrom WongWQZ2008 Tingting Xue Durieux
% LocalWords:  Zhao crosstab ICST2008 Gothenburg FootPrint VFix Yulei Fernanda
% LocalWords:  Xuezheng LoreyRF2022 Lorey Felderer ICSE2022 Dwivedi AletiM2021
% LocalWords:  P16 P20 P17 P18 P19 KashiwaSLBLKU2021 Rachatasumrit predominator
% LocalWords:  RefactoringMiner visualises Madeiral tan2015relifix relifix
% LocalWords:  Baleegh Alamitos Amirfarhad Nilizadeh Sungmin Wonkeun unexecuted
% LocalWords:  KirbasWMKPSVWCBHHW2021 Windels Etienne McBello Olayori Szalanski
% LocalWords:  Counsell Haraldsson Saemundur Divide'' EldawyLGB2023 Eladawy
% LocalWords:  ICSE2024 Recoder SainiFLYMSBL2019 Vaibhav Farmahinifarahani
% LocalWords:  Sajnani ICSE2019 InspectorClone SimCad Alaboudi Abdulaziz Latoza
% LocalWords:  Hypothesizer articleno Latoza Hypothesizer's hypothesizer Latoza
% LocalWords:  onClick setState HelpMeOut LeeDM2006 Dourish CSCM2006 Berman2001
% LocalWords:  sensical Neuroimaging Noguera Kellens Deridder D'Hondt Flor
% LocalWords:  OOPSLACompanion2009 automation'' implementors verbalizations
% LocalWords:  GenProg's RibesL2010 Ribes Sociotechnical JCSCW Tolsum STS Ko
% LocalWords:  emph Ko Ko faturization PARNAS199541 NguyenHoanFS2010 Perlow1999
% LocalWords:  PEARL's
