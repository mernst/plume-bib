% Software engineering bibliography


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Maintenance
%%%



@Article{Putnam78,
  author = 	 "Lawrence H. Putnam",
  title = 	 "A general empirical solution to the macro software sizing
                  and estimating problem",
  journal = 	 TSE,
  year = 	 1978,
  volume =	 4,
  number =	 4,
  pages =	 "345--361",
  month =	 jul
}

@Article{BalzerCG83,
  author = 	 "R. Balzer and T. E. Cheatham, Jr. and C. Green",
  title = 	 "Software technology in the 1990's: Using a new paradigm",
  journal = 	 "Computer",
  year = 	 1983,
  volume =	 16,
  number =	 11,
  pages =	 "39--45",
  month =	 nov
}

@Article{Boehm87:top10,
  author = 	 "Barry W. Boehm",
  title = 	 "Industrial software metrics top 10 list",
  journal = 	 "IEEE Software",
  year = 	 1987,
  volume =	 4,
  number =	 5,
  pages =	 "84--85",
  month =	 sep
}





@Article{Erlikh2000,
  author = 	 "Erlikh, Len",
  title = 	 "Leveraging legacy system dollars for e-business",
  journal = 	 "IT Professional",
  year = 	 2000,
  volume = 	 2,
  number = 	 3,
  pages = 	 "17--23",
  month = 	 may,
}



@Article{Eastwood1993,
  author = 	 "A. Eastwood",
  title = 	 "Firm fires shots at legacy systems",
  journal = 	 "Computing Canada",
  year = 	 1993,
  volume = 	 19,
  number = 	 2,
  pages = 	 17,
}


@Article{Moad1990,
  author = 	 "J. Moad",
  title = 	 "Maintaining the competitive edge",
  journal = 	 "DATAMATION",
  year = 	 1990,
  pages = 	 "61--66",
  month = 	 feb,
}






@Article{LientzS1981,
  author = 	 "Lientz, Bennet P. and Swanson, E. Burton",
  title = 	 "Problems in application software maintenance",
  journal = 	 CACM,
  year = 	 1981,
  volume = 	 24,
  number = 	 11,
  pages = 	 "763--769",
  month = 	 nov,
}


@Book{ZelkowitzSG1979,
  author = 	 "Zelkowitz, Marvin V. and Shaw, Alan C. and Gannon, John D.",
  title = 	 "Principles of Software Engineering and Design",
  publisher = 	 "Prentice Hall Professional Technical Reference",
  year = 	 1979,
}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Refactoring
%%%

@TechReport{Griswold91,
  author = 	 "William G. Griswold",
  title = 	 "Program Restructuring To Aid Software Maintenance",
  institution =  UWCSE,
  year = 	 1991,
  number =	 "91-08-04",
  address =	 UWCSEaddr,
  month =	 aug,
  note =	 "PhD dissertation"
}

@TechReport{Opdyke92,
  author = 	 "W. F. Opdyke",
  title = 	 "Refactoring: A Program Restructuring Aid in Designing
                  Object-Oriented Applications Frameworks",
  institution =  "University of Illinois at Urbana-Champaign, Dept. of Computer Science",
  year = 	 1992,
  number =	 1759,
  note =	 "PhD dissertation"
}



@book{Fowler2000,
 title = {Refactoring: Improving the Design of Existing Code},
 author = {Martin Fowler},
 publisher = {Addison-Wesley},
 year = {2000}
}



@InProceedings{Parr94,
  author = 	 "Terence J. Parr",
  title = 	 "An overview of {SORCERER}: A simple tree-parser generator",
  booktitle =	 CC94,
  NEEDpages = 	 "",
  year =	 1994,
  address =	 CC94addr,
  month = 	 CC94date
}


@Article{MensT2004,
  author = 	 "Tom Mens and Tom Tourw{\'e}",
  authorASCII =  "Tom Mens and Tom Tourwe",
  title = 	 "A survey of software refactoring",
  journal = 	 TSE,
  year = 	 2004,
  volume =	 30,
  number =	 2,
  pages =	 "126--139",
  month =	 feb
}



@InProceedings{StreckenbachS2004,
  author = 	 "Mirko Streckenbach and Gregor Snelting",
  title = 	 "Refactoring class hierarchies with {KABA}",
  booktitle =	 OOPSLA2004,
  pages = 	 "315--330",
  year =	 2004,
  address =	 OOPSLA2004addr,
  month =	 OOPSLA2004date
}


@InProceedings{HenkelD2005,
  author = 	 "Johannes Henkel and Amer Diwan",
  title = 	 "CatchUp!  Capturing and replaying refactorings to support
                  {API} evolution",
  booktitle =	 ICSE2005,
  pages = 	 "274--283",
  year =	 2005,
  address =	 ICSE2005addr,
  month =	 ICSE2005date,
  abstract =
   "Library developers who have to evolve a library to accommodate changing
    requirements often face a dilemma: Either they implement a clean, efficient
    solution but risk breaking client code, or they maintain compatibility with
    client code, but pay with increased design complexity and thus higher
    maintenance costs over time.
    \par
    We address this dilemma by presenting a lightweight approach for evolving
    application programming interfaces (APIs), which does not depend on version
    control or configuration management systems. Instead, we capture API
    actions as a developer evolves an API. Users of the API can then replay the
    refactorings to bring their client software components up to date.
    \par
    We present CatchUp!, an implementation of our approach that captures and
    replays refactoring actions within an integrated development environment
    semi-automatically. Our experiments suggest that our approach could be
    valuable in practice.",
}



@InProceedings{MurphyHillPB2009,
  author = 	 "Murphy-Hill, Emerson and Parnin, Chris and Black, Andrew P.",
  title = 	 "How we refactor, and how we know it",
  booktitle = ICSE2009,
  pages = 	 "287--297",
  year = 	 2009,
  address = 	 ICSE2009addr,
  month = 	 ICSE2009date,
  abstract =
   "Much of what we know about how programmers refactor in the wild is
    based on studies that examine just a few software projects. Researchers
    have rarely taken the time to replicate these studies in other contexts
    or to examine the assumptions on which they are based. To help put
    refactoring research on a sound scientific basis, we draw conclusions
    using four data sets spanning more than 13 000 developers, 240 000
    tool-assisted refactorings, 2500 developer hours, and 3400 version
    control commits. Using these data, we cast doubt on several previously
    stated assumptions about how programmers refactor, while validating
    others. For example, we find that programmers frequently do not indicate
    refactoring activity in commit logs, which contradicts assumptions made
    by several previous researchers. In contrast, we were able to confirm
    the assumption that programmers do frequently intersperse refactoring
    with other program changes. By confirming assumptions and replicating
    studies made by other researchers, we can have greater confidence that
    those researchers' conclusions are generalizable.",
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Programmer productivity: lines of code per day
%%%





@Book{McConnell2006,
  author = 	 "Steve McConnell",
  title = 	 "Software Estimation: Demystifying the Black Art",
  publisher = 	 "Microsoft Press",
  year = 	 2006,
}


@Book{Jones2011,
  author = 	 "Capers Jones",
  title = 	 "The Economics of Software Quality",
  publisher = 	 "Addison-Wesley",
  year = 	 2011,
}



@Misc{Su2006,
  author = 	 "Philip Su",
  title = 	 "Broken {Windows} Theory",
  howpublished = "\url{http://blogs.msdn.com/b/philipsu/archive/2006/06/14/631438.aspx}",
  month = 	 jun,
  year = 	 2006,
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Fault localization
%%%

@InProceedings{JonesH2005,
  author = 	 "James A. Jones and Mary Jean Harrold",
  title = 	 "Empirical evaluation of the {Tarantula} automatic fault-localization technique",
  booktitle = ASE2005,
  pages = 	 "273--282",
  year = 	 2005,
  address = 	 ASE2005addr,
  month = 	 ASE2005date,
}



@InProceedings{ParninO2011,
  author = 	 "Parnin, Chris and Orso, Alessandro",
  title = 	 "Are automated debugging techniques actually helping programmers?",
  booktitle = ISSTA2011,
  year = 	 2011,
  pages = 	 "199--209",
  month = 	 ISSTA2011date,
  address = 	 ISSTA2011addr,
}


@InProceedings{RenierisR2003,
  author = 	 "Manos Renieris and Steven P. Reiss",
  title = 	 "Fault localization with nearest neighbor queries",
  booktitle = ASE2003,
  year = 	 2003,
  pages = 	 "30--39",
  month = 	 ASE2003date,
  address = 	 ASE2003addr,
}


@InProceedings{SteimannFA2013,
  author = 	 "Steimann, Friedrich and Frenkel, Marcus and Abreu, Rui",
  title = 	 "Threats to the validity and value of empirical assessments of the accuracy of coverage-based fault locators",
  booktitle = ISSTA2013,
  year = 	 2013,
  pages = 	 "314--324",
  month = 	 ISSTA2013date,
  address = 	 ISSTA2013addr,
}

@InProceedings{ZhangZK2013,
  author = 	 "Zhang, Lingming and Zhang, Lu and Khurshid, Sarfraz",
  title = 	 "Injecting Mechanical Faults to Localize Developer Faults for Evolving Software",
  booktitle = OOPSLA2013,
  year = 	 2013,
  pages = 	 "765--784",
  month = 	 OOPSLA2013date,
  address = 	 OOPSLA2013addr,
}

@InProceedings{JonesHS2002,
  author = 	 "Jones, James A. and Harrold, Mary Jean and Stasko, John",
  title = 	 "Visualization of test information to assist fault localization",
  booktitle = ICSE2002,
  year = 	 2002,
  pages = 	 "467--477",
  month = 	 ICSE2002date,
  address = 	 ICSE2002addr,
}

@Unpublished{YooNH2011,
  author = 	 "Yoo, Shin and Nilsson, Robert and Harman, Mark",
  title = 	 "Faster fault finding at {Google} using multi objective regression test optimisation",
  note = 	 "Unpublished paper accompanying industrial track talk at ESEC/FSE 2011",
  month = 	 FSE2011date,
  year = 	 2011,
}





@Article{DiGiuseppeJ2015,
  author = 	 "DiGiuseppe, Nicholas and Jones, James A.",
  title = 	 "Fault Density, Fault Types, and Spectra-based Fault Localization",
  journal = 	 JEmpiricalSE,
  year = 	 2015,
  volume = 	 20,
  number = 	 4,
  pages = 	 "928--967",
  month = 	 aug,
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Miscellaneous
%%%


@Misc{Borland2004,
  author =	 "Borland",
  title =	 "Making Development A Team Sport",
  howpublished = "demo at JavaOne",
  month =	 jun # "~29,",
  year =	 2004
}



@InProceedings{ChowN96,
  author = 	 "Kingsum Chow and David Notkin",
  title = 	 "Semi-automatic update of applications in response to
                  library changes",
  booktitle =	 ICSM96,
  pages =	 "259--368",
  year =	 1996,
  address =	 ICSM96addr,
  month =	 ICSM96date
}



@InProceedings{MandelinXBK2005,
  author = 	 "David Mandelin and Lin Xu and Rastislav Bod{\'\i}k and
                  Doug Kimmelman",
  authorSEARCHABLE = "Rastislav Bodik",
  title = 	 "Jungloid mining: Helping to navigate the {API} jungle",
  booktitle =	 PLDI2005,
  pages = 	 "48--61",
  year =	 2005,
  address =	 PLDI2005addr,
  month =	 PLDI2005date,
  abstract =
   "Reuse of existing code from class libraries and frameworks is often
    difficult because APIs are complex and the client code required to use the
    APIs can be hard to write. We observed that a common scenario is that the
    programmer knows what type of object he needs, but does not know how to
    write the code to get the object.
    \par
    In order to help programmers write API client code more easily, we
    developed techniques for synthesizing jungloid code fragments automatically
    given a simple query that describes that desired code in terms of input and
    output types. A jungloid is simply a unary expression; jungloids are
    simple, enabling synthesis, but are also versatile, covering many coding
    problems, and composable, combining to form more complex code fragments. We
    synthesize jungloids using both API method signatures and jungloids mined
    from a corpus of sample client programs.
    \par
    We implemented a tool, Prospector, based on these techniques. Prospector is
    integrated with the Eclipse IDE code assistance feature, and it infers
    queries from context so there is no need for the programmer to write
    queries. We tested Prospector on a set of real programming problems
    involving APIs; Prospector found the desired solution for 18 of 20
    problems.We also evaluated Prospector in a user study, finding that
    programmers solved programming problems more quickly and with more reuse
    when using Prospector than without Prospector."
}



@Article{SanthiarPK2014,
  author = 	 "Santhiar, Anirudh and Pandita, Omesh and Kanade, Aditya",
  title = 	 "Mining Unit Tests for Discovery and Migration of Math {APIs}",
  journal = 	 TOSEM,
  year = 	 2014,
  volume = 	 24,
  number = 	 1,
  pages = 	 "4:1--4:33",
  month = 	 oct,
}



@InProceedings{GhafariGMT2014,
  author = 	 "Mohammad Ghafari and Carlo Ghezzi and Andrea Mocci and Giordano Tamburrelli",
  title = 	 "Mining unit tests for code recommendation",
  booktitle = ICPC2014,
  year = 	 2014,
  pages = 	 "142--145",
  month = 	 ICPC2014date,
  address = 	 ICPC2014addr,
}



@InProceedings{RutarAF2004,
  author = 	 "Nick Rutar and Christian B. Almazan and Jeffrey S. Foster",
  title = 	 "A comparison of bug finding tools for {Java}",
  booktitle =	 ISSRE2004,
  pages =	 "245--256",
  year =	 2004,
  address =	 ISSRE2004addr,
  month =	 ISSRE2004date,
  abstract =
   "Bugs in software are costly and difficult to find and fix. In recent years,
    many tools and techniques have been developed for automatically finding
    bugs by analyzing source code or intermediate code statically (at compile
    time). Different tools and techniques have different tradeoffs, but the
    practical impact of these tradeoffs is not well understood. In this paper,
    we apply five bug finding tools, specifically Bandera, ESC/Java 2,
    FindBugs, JLint, and PMD, to a variety of Java programs. By using a variety
    of tools, we are able to cross-check their bug reports and warnings. Our
    experimental results show that none of the tools strictly subsumes another,
    and indeed the tools often find non-overlapping bugs. We discuss the
    techniques each of the tools is based on, and we suggest how particular
    techniques affect the output of the tools. Finally, we propose a meta-tool
    that combines the output of the tools together, looking for particular
    lines of code, methods, and classes that many tools warn about.",
}





@InProceedings{KimSNM2005,
  author = 	 "Miryung Kim and Vibha Sazawal and David Notkin
                  and Gail C. Murphy",
  title = 	 "An empirical study of code clone genealogies",
  booktitle =	 FSE2005,
  pages =	 "187--196",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "It has been broadly assumed that code clones are inherently bad and that
    eliminating clones by refactoring would solve the problems of code
    clones. To investigate the validity of this assumption, we developed a
    formal definition of clone evolution and built a clone genealogy tool that
    automatically extracts the history of code clones from a source code
    repository. Using our tool we extracted clone genealogy information for two
    Java open source projects and analyzed their evolution.
    \par
    Our study contradicts some conventional wisdom about clones. In particular,
    refactoring may not always improve software with respect to clones for two
    reasons. First, many code clones exist in the system for only a short time;
    extensive refactoring of such short-lived clones may not be worthwhile if
    they are likely diverge from one another very soon. Second, many clones,
    especially long-lived clones that have changed consistently with other
    elements in the same group, are not easily refactorable due to programming
    language limitations. These insights show that refactoring will not help in
    dealing with some types of clones and open up opportunities for
    complementary clone maintenance tools that target these other classes of
    clones.",
}


@Book{GhezziJM91,
  author =       "Carlo Ghezzi and Mehdi Jazayeri and Dino Mandrioli",
  title =        "Fundamentals of Software Engineering",
  edition =      "1",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year =         "1991",
  ISBN =         "0-13-818204-3",
}


@Book{Lamb88,
  author =	 "David Alex Lamb",
  title = 	 "Software Engineering:  Planning for Change",
  publisher =    "Prentice Hall",
  address =      "Englewood Cliffs, NJ",
  year = 	 1988
}

@Book{Sommerville:1996a,
  author =       "Ian Sommerville",
  title =        "Software Engineering",
  publisher =    "Addison-Wesley",
  year =         "1996",
  address =      "Wokingham, England",
  edition =      "Fifth",
}

@Book{Pressman92,
  author =	 "Roger S. Pressman",
  title = 	 "Software Engineering:  A Practitioner's Approach",
  publisher = 	 "McGraw-Hill",
  year = 	 1992,
  address =	 "New York",
  edition =	 "Third"
}




@InProceedings{VandevoordeG94,
  author =       "Mark T. Vandevoorde and John V. Guttag",
  title =        "Using specialized procedures and specification-based analysis
                  to reduce the runtime costs of modularity",
  booktitle =    "Symposium on the Foundations of Software Engineering",
  year =         1994,
  month =        dec
}

@InProceedings{KremenekAYE2004,
  author = 	 "Ted Kremenek and Ken Ashcraft and Junfeng Yang and Dawson Engler",
  title = 	 "Correlation exploitation in error ranking",
  booktitle =    FSE2004,
  pages = 	 "83--93",
  year =	 2004,
  address =	 FSE2004addr,
  month =	 FSE2004date
}



@InProceedings{BasitRJ2005,
  author = 	 "Hamid Abdul Basit and Damith C. Rajapakse and Stan Jarzabek",
  title = 	 "Beyond templates: A study of clones in the {STL} and some
                  general implications",
  booktitle =	 ICSE2005,
  pages = 	 "451--459",
  year =	 2005,
  address =	 ICSE2005addr,
  month =	 ICSE2005date,
  abstract =
   "Templates (or generics) help us write compact, generic code, which aids
    both reuse and maintenance. The STL is a powerful example of how templates
    help achieve these goals. Still, our study of the STL revealed substantial,
    and in our opinion, counter-productive repetitions (so-called clones)
    across groups of similar class or function templates. Clones occurred, as
    variations across these similar program structures were irregular and could
    not be unified by suitable template parameters in a natural way. We
    encountered similar problems in other class libraries as well as in
    application programs, written in a range of programming languages. In the
    paper, we present quantitative and qualitative results from our study. We
    argue that the difficulties we encountered affect programs in general. We
    present a solution that can treat such template-unfriendly cases of
    redundancies at the meta-level, complementing and extending the power of
    language features, such as templates, in areas of generic programming.",
}



@InProceedings{BasitJ2005,
  author = 	 "Hamid Abdul Basit and Stan Jarzabek",
  title = 	 "Detecting higher-level similarity patterns in programs",
  booktitle =	 FSE2005,
  pages =	 "156--165",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "Cloning in software systems is known to create problems during software
    maintenance. Several techniques have been proposed to detect the same or
    similar code fragments in software, so-called simple clones. While the
    knowledge of simple clones is useful, detecting design-level similarities
    in software could ease maintenance even further, and also help us identify
    reuse opportunities. We observed that recurring patterns of simple clones -
    so-called structural clones - often indicate the presence of interesting
    design-level similarities. An example would be patterns of collaborating
    classes or components. Finding structural clones that signify potentially
    useful design information requires efficient techniques to analyze the bulk
    of simple clone data and making non-trivial inferences based on the
    abstracted information. In this paper, we describe a practical solution to
    the problem of detecting some basic, but useful, types of design-level
    similarities such as groups of highly similar classes or files. First, we
    detect simple clones by applying conventional token-based techniques. Then
    we find the patterns of co-occurring clones in different files using the
    Frequent Itemset Mining (FIM) technique. Finally, we perform file
    clustering to detect those clusters of highly similar files that are likely
    to contribute to a design-level similarity pattern. The novelty of our
    approach is application of data mining techniques to detect design level
    similarities. Experiments confirmed that our method finds many useful
    structural clones and scales up to big programs. The paper describes our
    method for structural clone detection, a prototype tool called Clone Miner
    that implements the method and experimental results."
}






@InProceedings{LivshitsZ2005,
  author = 	 "Benjamin Livshits and Thomas Zimmermann",
  title = 	 "{DynaMine}: Finding common error patterns by mining
                  software revision histories",
  booktitle =	 FSE2005,
  pages =	 "296--305",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "A great deal of attention has lately been given to addressing software
    bugs such as errors in operating system drivers or security bugs. However,
    there are many other lesser known errors specific to individual
    applications or APIs and these violations of application-specific coding
    rules are responsible for a multitude of errors. In this paper we propose
    DynaMine, a tool that analyzes source code check-ins to find highly
    correlated method calls as well as common bug fixes in order to
    automatically discover application-specific coding patterns. Potential
    patterns discovered through mining are passed to a dynamic analysis tool
    for validation; finally, the results of dynamic analysis are presented to
    the user.
    \par
    The combination of revision history mining and dynamic analysis techniques
    leveraged in DynaMine proves effective for both discovering new
    application-specific patterns and for finding errors when applied to very
    large applications with many man-years of development and debugging effort
    behind them. We have analyzed Eclipse and jEdit, two widely-used, mature,
    highly extensible applications consisting of more than 3,600,000 lines of
    code combined. By mining revision histories, we have discovered 56
    previously unknown, highly application-specific patterns. Out of these, 21
    were dynamically confirmed as very likely valid patterns and a total of 263
    pattern violations were found.",
}



@InProceedings{SullivanGSCSTR2005,
  author = 	 "Kevin Sullivan and William G. Griswold and Yuanyuan Song
                  and Yuanfang Cai and Macneil Shonle and Nishit Tewari and
                  Hridesh Rajan",
  title = 	 "Information hiding interfaces for aspect-oriented design",
  booktitle =	 FSE2005,
  pages =	 "166--175",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date
}




@InProceedings{Przybylek2011,
  author = 	 "Adam Przyby{\l}ek",
  authorASCII =  "Adam Przyby≈Çek, Adam Przybylek",
  title = 	 "Where the truth lies: {AOP} and its impact on software modularity",
  booktitle = FASE2011,
  NEEDpages = 	 "*",
  year = 	 2011,
  address = 	 FASE2011addr,
  month = 	 FASE2011date,
  abstract =
   "Modularity is the single attribute of software that allows a program to be
    intellectually manageable [29]. The recipe for modularizing is to define a
    narrow interface, hide an implementation detail, keep low coupling and high
    cohesion. Over a decade ago, aspect-oriented programming (AOP) was proposed
    in the literature to ``modularize the un-modularizable'' [24]. Since then,
    aspect-oriented languages have been providing new abstraction and
    composition mechanisms to deal with concerns that could not be modularized
    because of the limited abstractions of the underlying programming
    language. This paper is a continuation of our earlier work [32] and further
    investigates AO software with regard to coupling and cohesion. We compare
    two versions (Java and AspectJ) of ten applications to review AOP within
    the context of software modularity. It turns out that the claim that ``the
    software built in AOP is more modular than the software built in OOP'' is a
    myth.",
}







@InProceedings{LiZ2005,
  author = 	 "Zhenmin Li and Yuanyuan Zhou",
  title = 	 "PR-Miner: automatically extracting implicit programming
                  rules and detecting violations in large software code",
  booktitle =	 FSE2005,
  pages =	 "306--315",
  year =	 2005,
  address =	 FSE2005addr,
  month =	 FSE2005date,
  abstract =
   "Programs usually follow many \emph{implicit} programming rules, most of
    which are too tedious to be documented by programmers. When these rules are
    violated by programmers who are unaware of or forget about them, defects
    can be easily introduced. Therefore, it is highly desirable to have tools
    to automatically extract such rules and also to automatically detect
    violations. Previous work in this direction focuses on simple function-pair
    based programming rules and additionally requires programmers to provide
    rule templates.
    \par
    This paper proposes a \emph{general} method called PR-Miner that uses a
    data mining technique called frequent itemset mining to efficiently extract
    implicit programming rules from large software code written in an
    industrial programming language such as C, \emph{requiring little effort
    from programmers and no prior knowledge of the software}. Benefiting from
    frequent itemset mining, PR-Miner can extract programming rules in general
    forms (without being constrained by any fixed rule templates) that can
    contain multiple program elements of various types such as functions,
    variables and data types. In addition, we also propose an efficient
    algorithm to automatically detect violations to the extracted programming
    rules, which are strong indications of bugs.
    \par
    Our evaluation with large software code, including Linux, PostgreSQL Server
    and the Apache HTTP Server, with 84K--3M lines of code each, shows that
    PR-Miner can efficiently extract thousands of general programming rules and
    detect violations within 2 minutes. Moreover, PR-Miner has detected many
    violations to the extracted rules. Among the top 60 violations reported by
    PR-Miner, 16 have been confirmed as bugs in the \emph{latest version} of
    Linux, 6 in PostgreSQL and 1 in Apache. Most of them violate complex
    programming rules that contain more than 2 elements and are thereby
    difficult for previous tools to detect. We reported these bugs and they are
    currently being fixed by developers.",
}



@Book{Simon96,
  author = 	 "Herbert A. Simon",
  title = 	 "The Sciences of the Artificial",
  publisher = 	 "MIT Press",
  year = 	 1996,
  edition = 	 "Third",
}

@Book{Braude2003,
  author = 	 "Eric J. Braude",
  title = 	 "Software Design: From Programming to Architecture",
  publisher = 	 "Wiley",
  year = 	 2003,
}


@Book{Budgen2003,
  author = 	 "Software Design",
  title = 	 "David Budgen",
  publisher = 	 "Addison-Wesley",
  year = 	 2003,
}

@Book{Winograd1996,
  author = 	 "Terry Winograd",
  title = 	 "Bringing Design to Software",
  publisher = 	 "Addison-Wesley",
  year = 	 1996
}

@Book{CoplienS1995,
  author = 	 "James O. Coplien and Douglas C. Schmidt",
  title = 	 "Pattern Languages of Program Design",
  publisher = 	 "Addison-Wesley",
  year = 	 1995,
}

@Book{FelleisenFFK2001,
  author = 	 "Matthias Felleisen and Robert Bruce Findler and Matthew
                  Flatt and Shriram Krishnamurthi",
  title = 	 "How to Design Programs: An Introduction to Programming and Computing",
  publisher = 	 "MIT Press",
  year = 	 2001
}

@Book{CohoonD2005,
  author = 	 "James P. Cohoon and Jack W. Davidson ",
  title = 	 "Java 5.0 Program Design",
  publisher = 	 "McGraw-Hill",
  year = 	 2005,
}



@InProceedings{KuhnGG2005,
  author = 	 "Adrian Kuhn and Orla Greevy and Tudor G{\^\i}rba",
  title = 	 "Applying semantic analysis to feature execution traces",
  booktitle =    PCODA2005,
  pages = 	 "48--53",
  year = 	 2005,
  address = 	 PCODA2005addr,
  month = 	 PCODA2005date,
  abstract =
   "Recently there has been a revival of interest in feature
    analysis of software systems. Approaches to feature location
    have used a wide range of techniques such as dynamic
    analysis, static analysis, information retrieval and formal
    concept analysis. In this paper we introduce a novel approach
    to analyze the execution traces of features using Latent
    Semantic Indexing (LSI). Our goal is twofold. On the
    one hand we detect similarities between features based on
    the content of their traces, and on the other hand we categorize
    classes based on the frequency of the outgoing invocations
    involved in the traces. We apply our approach on
    two case studies and we discuss its benefits and drawbacks.",
}



@Article{EisenbarthKS2003,
  author = 	 "T. Eisenbarth and R. Koschke and D. Simon",
  title = 	 "Locating Features in Source Code",
  journal = 	 computer,
  year = 	 2003,
  volume = 	 29,
  number = 	 3,
  pages = 	 "210--224",
  month = 	 mar,
}


@InProceedings{GreevyD2005,
  author = 	 "O. Greevy and St{\'e}phane Ducasse",
  title = 	 "Correlating features and code using a compact two-sided
                  trace analysis approach",
  booktitle = CMSR2005,
  pages = 	 "314--323",
  year = 	 2005,
  address = 	 CMSR2005addr,
  month = 	 CMSR2005date,
}


@InProceedings{GreevyDG2005,
  author = 	 "Orla Greevy and St{\'e}phane Ducasse and Tudor G{\^\i}rba",
  title = 	 "Analyzing feature traces to incorporate the semantics of
		  change in software evolution analysis",
  booktitle = ICSM2005,
  pages = 	 "347--356",
  year = 	 2005,
  address = 	 ICSM2005addr,
  month = 	 ICSM2005date,
}


@Article{WongGH2000,
  author = 	 "W. E. Wong and S. S. Gokhale and J. R. Horgan",
  title = 	 "Quantifying the closeness between program components and features",
  journal = 	 j-systems-and-software,
  year = 	 2000,
  volume = 	 54,
  number = 	 2,
  pages = 	 "87--98",
  month = 	 oct,
}


@InProceedings{ZaidmanCDP2005,
  author = 	 "Andy Zaidman and Toon Calders and Serge Demeyer and Jan Paredaens",
  title = 	 "Applying Webmining Techniques to Execution Traces to
                  Support the Program Comprehension Process",
  booktitle =    CMSR2005,
  pages = 	 "134--142",
  year = 	 2005,
  address = 	 CMSR2005addr,
  month = 	 CMSR2005date,
  abstract =
   "Well-designed object-oriented programs typically consist
    of a few key classes that work tightly together to provide
    the bulk of the functionality. As such, these key classes are
    excellent starting points for the program comprehension
    process. We propose a technique that uses webmining
    principles on execution traces to discover these important
    and tightly interacting classes. Based on two medium-scale
    case studies --- Apache Ant and Jakarta JMeter --- and
    detailed architectural information from its developers, we
    show that our heuristic does in fact find a sizable number
    of the classes deemed important by the developers.",
}


@InProceedings{HaRDRCRW2007,
  author = 	 "Jungwoo Ha and Christopher J. Rossbach and Jason V. Davis and Indrajit Roy and David L. Chen and Hany E. Ramadan and Emmett Witchel",
  title = 	 "Improved error reporting for software that uses black-box components",
  booktitle = PLDI2007,
  pages = 	 "101--111",
  year = 	 2007,
  address = 	 PLDI2007addr,
  month = 	 PLDI2007date,
}



@InProceedings{ApiwattanapongOH2004,
  author = 	 "Taweesup Apiwattanapong and Alessandro Orso and Mary Jean Harrold",
  title = 	 "A differencing algorithm for object-oriented programs",
  booktitle = ASE2004,
  pages = 	 "2--13",
  year = 	 2004,
  address = 	 ASE2004addr,
  month = 	 ASE2004date,
  abstract =
   "During software evolution, information about changes between different
    versions of a program is useful for a number of software engineering
    tasks. For many of these tasks, a purely syntactic differencing may not
    provide enough information for the task to be performed effectively. This
    problem is especially relevant in the case of object-oriented software, for
    which a syntactic change can have subtle and unforeseen effects. In this
    paper, we present a technique for comparing object-oriented programs that
    identifies both differences and correspondences between two versions of a
    program. The technique is based on a representation that handles
    object-oriented features and, thus, can capture the behavior of
    object-oriented programs. We also present JDIFF, a tool that implements the
    technique for Java programs, and empirical results that show the efficiency
    and effectiveness of the technique on a real program.",
  supersededby = "ApiwattanapongOH2007",
}


@Article{ApiwattanapongOH2007,
  author = 	 "Taweesup Apiwattanapong and Alessandro Orso and Mary Jean Harrold",
  title = 	 "{JD}iff: A differencing technique and tool for object-oriented programs",
  journal = 	 ASEjournal,
  year = 	 2007,
  volume = 	 14,
  month =        mar,
  pages = 	 "3--36",
  abstract =
   "During software evolution, information about changes between different
    versions of a program is useful for a number of software engineering
    tasks. For example, configuration-management systems can use change
    information to assess possible conflicts among updates from different
    users. For another example, in regression testing, knowledge about which
    parts of a program are unchanged can help in identifying test cases that
    need not be rerun. For many of these tasks, a purely syntactic differencing
    may not provide enough information for the task to be performed
    effectively.  This problem is especially relevant in the case of
    object-oriented software, for which a syntactic change can have subtle and
    unforeseen effects. In this paper, we present a technique for comparing
    object-oriented programs that identifies both differences and
    correspondences between two versions of a program. The technique is based
    on a representation that handles object-oriented features and, thus, can
    capture the behavior of object-oriented programs.We also present JDiff, a
    tool that implements the technique for Java programs. Finally, we present
    the results of four empirical studies, performed on many versions of two
    medium-sized subjects, that show the efficiency and effectiveness of the
    technique when used on real programs.",
  usesDaikonAsTestSubject = 1,
  downloads = "http://dx.doi.org/10.1007/s10515-006-0002-0 DOI",
}


@InProceedings{XuRTQ2007,
  author = 	 "Guoqing Xu and Atanas Rountev and Yan Tang and Feng Qin",
  title = 	 "Efficient checkpointing of {Java} software using context-sensitive capture and replay",
  booktitle = FSE2007,
  pages = 	 "85--94",
  year = 	 2007,
  address = 	 FSE2007addr,
  month = 	 FSE2007date,
}



@InProceedings{DwyerKE2007,
  author = 	 "Matthew B. Dwyer and Alex Kinneer and Sebastian Elbaum",
  title = 	 "Adaptive Online Program Analysis",
  booktitle = ICSE2007,
  pages = 	 "220--229",
  year = 	 2007,
  address = 	 ICSE2007addr,
  month = 	 ICSE2007date,
}







@InProceedings{KoM2008,
  author = 	 "Andrew J. Ko and Brad A. Myers",
  title = 	 "Debugging reinvented: Asking and answering why and why not questions about program behavior",
  booktitle = ICSE2008,
  pages = 	 "301--310",
  year = 	 2008,
  address = 	 ICSE2008addr,
  month = 	 ICSE2008date,
}







@Book{IEEE-610.12-1990,
  editor = 	 "Jane Radatz",
  title = 	 "IEEE Std 610.12-1990 IEEE Standard Glossary of Software Engineering Terminology",
  publisher = 	 "IEEE Computer Society",
  year = 	 1990,
  month = 	 sep # "~28,",
  abstract =
   "Describes the IEEE Std 610.12-1990, IEEE standard glossary of software
   engineering terminology, which identifies terms currently in use in the
   field of software engineering. Standard definitions for those terms are
   established.",
}


@InProceedings{Cook2009,
  author = 	 "Cook, William R.",
  title = 	 "On understanding data abstraction, revisited",
  booktitle = OOPSLA2009companion,
  pages = 	 "557--572",
  year = 	 2009,
  address = 	 OOPSLA2009addr,
  month = 	 OOPSLA2009date,
}



@Book{Brooks1975,
  author = 	 "Brooks, Jr., Frederick P.",
  title = 	 "The Mythical Man-Month: Essays on Software Engineering",
  publisher = 	 "Addison-Wesley",
  year = 	 1975,
  address = {Boston, MA, USA},
  isbn = {0201006502},
}



@InProceedings{JeongKZ2009,
  author = 	 "Jeong, Gaeul and Kim, Sunghun and Zimmermann, Thomas",
  title = 	 "Improving bug triage with bug tossing graphs",
  booktitle = FSE2009,
  pages = 	 "111--120",
  year = 	 2009,
  address = 	 FSE2009addr,
  month = 	 FSE2009date,
}


@Article{WalradS2002,
  author = 	 "Walrad, Chuck and Strom, Darrel",
  title = 	 "The Importance of Branching Models in {SCM}",
  journal = 	 "Computer",
  year = 	 2002,
  volume = 	 35,
  number = 	 9,
  pages = 	 "31--38",
  month = 	 sep,
}

@InProceedings{BallKPS97,
  author = 	 "Thomas Ball and Jung-Min Kim and Adam A. Porter and Harvey P. Siy",
  title = 	 "If Your Version Control System Could Talk \ldots",
  booktitle = "ICSE '97 Workshop on Process Modelling and Empirical Studies of Software Engineering",
  NEEDpages = 	 "*",
  year = 	 1997,
  address = 	 ICSE97addr,
  month = 	 ICSE97date,
}


@InProceedings{NagappanBZ2006,
  author = 	 "Nagappan, Nachiappan and Ball, Thomas and Zeller, Andreas",
  title = 	 "Mining metrics to predict component failures",
  booktitle = ICSE2006,
  pages = 	 "452--461",
  year = 	 2006,
  address = 	 ICSE2006addr,
  month = 	 ICSE2006date,
}




@Article{Rochkind75,
  author = 	 "Marc J. Rochkind",
  title = 	 "The Source Code Control System",
  journal = 	 IEEETSE,
  year = 	 1975,
  volume = 	 1,
  number = 	 4,
  pages = 	 "364--370",
  month = 	 dec,
}



@InProceedings{BaconCPR2009,
  author = 	 "Bacon, David F. and Chen, Yiling and Parkes, David and Rao, Malvika",
  title = 	 "A market-based approach to software evolution",
  booktitle = OOPSLA2009companion,
  pages = 	 "973--980",
  year = 	 2009,
  address = 	 OOPSLA2009addr,
  month = 	 OOPSLA2009date,
  doi = {http://doi.acm.org/10.1145/1639950.1640066},
}


@Article{Sakthivel2007,
  author = 	 "Sakthivel, S.",
  title = 	 "Managing risk in offshore systems development",
  journal = 	 CACM,
  year = 	 2007,
  volume = 	 50,
  number = 	 4,
  pages = 	 "69--75",
  month = 	 apr,
  doi = {http://doi.acm.org/10.1145/1232743.1232750},
}


@InProceedings{FritzM2010,
  author = 	 "Fritz, Thomas and Murphy, Gail C.",
  title = 	 "Using information fragments to answer the questions developers ask",
  booktitle = ICSE2010,
  pages = 	 "175--184",
  year = 	 2010,
  address = 	 ICSE2010addr,
  month = 	 ICSE2010date,
}






@Article{Norman90,
  author = 	 "Donald A. Norman",
  title = 	 "The ``Problem'' with automation: Inappropriate feedback and interaction, not ``over-automation''",
  journal = 	 PTRSLB,
  year = 	 1990,
  volume = 	 327,
  number = 	 1241,
  pages = 	 "585--593",
}




@InProceedings{ApelLBLK2011,
  author = 	 "Sven Apel and J{\"o}rg Liebig and Benjamin Brandl and Christian Lengauer and Christian K{\"a}stner",
  authorASCII = 	 "Sven Apel and Jorg Liebig and Benjamin Brandl and Christian Lengauer and Christian Kastner",
  title = 	 "Semistructured Merge: Rethinking Merge in Revision Control Systems",
  booktitle = FSE2011,
  pages = 	 "190--200",
  year = 	 2011,
  address = 	 FSE2011addr,
  month = 	 FSE2011date,
}






@InProceedings{LeGouesDVFW2012,
  author = 	 "Le Goues, Claire and Dewey-Vogt, Michael and Forrest, Stephanie and Weimer, Westley",
  title = 	 "A systematic study of automated program repair: fixing 55 out of 105 bugs for \$8 each",
  booktitle = ICSE2012,
  pages = 	 "3--13",
  year = 	 2012,
  address = 	 ICSE2012addr,
  month = 	 ICSE2012date,
  abstract =
   "There are more bugs in real-world programs than human programmers can
    realistically address. This paper evaluates two research questions: ``What
    fraction of bugs can be repaired automatically?'' and ``How much does it
    cost to repair a bug automatically?'' In previous work, we presented
    GenProg, which uses genetic programming to repair defects in off-the-shelf
    C programs. To answer these questions, we: (1) propose novel algorithmic
    improvements to GenProg that allow it to scale to large programs and find
    repairs 68\% more often, (2) exploit GenProg's inherent parallelism using
    cloud computing resources to provide grounded, human-competitive cost
    measurements, and (3) generate a large, indicative benchmark set to use for
    systematic evaluations. We evaluate GenProg on 105 defects from 8
    open-source programs totaling 5.1 million lines of code and involving
    10,193 test cases. GenProg automatically repairs 55 of those 105
    defects. To our knowledge, this evaluation is the largest available of its
    kind, and is often two orders of magnitude larger than previous work in
    terms of code or test suite size or defect count. Public cloud computing
    prices allow our 105 runs to be reproduced for \$403; a successful repair
    completes in 96 minutes and costs \$7.32, on average.",
}







@InProceedings{ChangYM2010,
  author = 	 "Chang, Tsung-Hsiang and Yeh, Tom and Miller, Robert C.",
  title = 	 "{GUI} Testing Using Computer Vision",
  booktitle = CHI2010,
  year = 	 2010,
  pages = 	 "1535--1544",
  month = 	 CHI2010date,
  address = 	 CHI2010addr,
}




@inproceedings{JB10,
  Author = {Kevin Jalbert and Jeremy S. Bradbury},
  Title = {Using Clone Detection to Identify Bugs in Concurrent Software},
  Booktitle = {Proc. of 26th IEEE International Conference on Software Maintenance (ICSM 2010)},
  Month = {Sept.},
  Year = {2010}
}

















@InProceedings{JohnsonSMHB2013,
  author = 	 "Johnson, Brittany and Song, Yoonki and Murphy-Hill, Emerson and Bowdidge, Robert",
  title = 	 "Why don't software developers use static analysis tools to find bugs?",
  booktitle = ICSE2013,
  year = 	 2013,
  pages = 	 "672--681",
  month = 	 ICSE2013date,
  address = 	 ICSE2013addr,
  abstract =
   "Using static analysis tools for automating code inspections can be
    beneficial for software engineers. Such tools can make finding bugs, or
    software defects, faster and cheaper than manual inspections. Despite the
    benefits of using static analysis tools to find bugs, research suggests
    that these tools are underused. In this paper, we investigate why
    developers are not widely using static analysis tools and how current tools
    could potentially be improved. We conducted interviews with 20 developers
    and found that although all of our participants felt that use is
    beneficial, false positives and the way in which the warnings are
    presented, among other things, are barriers to use. We discuss several
    implications of these results, such as the need for an interactive
    mechanism to help developers fix defects.",
}








@inproceedings{Khomh:2012:FRI:2664446.2664475,
 author = {Khomh, Foutse and Dhaliwal, Tejinder and Zou, Ying and Adams, Bram},
 title = {Do Faster Releases Improve Software Quality?: An Empirical Case Study of Mozilla Firefox},
 booktitle = {Proceedings of the 9th IEEE Working Conference on Mining Software Repositories},
 series = {MSR '12},
 year = {2012},
 isbn = {978-1-4673-1761-0},
 location = {Zurich, Switzerland},
 pages = {179--188},
 numpages = {10},
 url = {http://dl.acm.org/citation.cfm?id=2664446.2664475},
 acmid = {2664475},
 publisher = {IEEE Press},
 address = {Piscataway, NJ, USA},
 keywords = {bugs, release cycle, software quality, software release, testing},
}



















@InProceedings{MusluBM2015,
  author = 	 "K{\i}van\c{c} Mu{\c{s}}lu and Yuriy Brun and Alexandra Meliou",
  authorASCII =	 "Kivanc Muslu and Yuriy Brun and Alexandra Meliou",
  title = 	 "Preventing data errors with continuous testing",
  booktitle = ISSTA2015,
  year = 	 2015,
  pages = 	 "373--384",
  month = 	 ISSTA2015date,
  address = 	 ISSTA2015addr,
}

@InProceedings{MusluBM2013,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu and Yuriy Brun and Alexandra Meliou",
  authorASCII =	 "Kivanc Muslu and Yuriy Brun and Alexandra Meliou",
  title = 	 "Data debugging with continuous testing",
  booktitle = FSE2013,
  year = 	 2013,
  pages = 	 "631--634",
  month = 	 FSE2013date,
  address = 	 FSE2013addr,
  supersededby = "MusluBM2015",
}

@InProceedings{MusluBNC2014,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu and Christian Bird and Nachi Nagappan and Jacek Czerwonka",
  authorASCII = 	 "Kivanc Muslu and Christian Bird and Nachi Nagappan and Jacek Czerwonka",
  title = 	 "Transition from centralized to distributed version control systems: A case study on reasons, barriers, and outcomes",
  booktitle = ICSE2014,
  year = 	 2014,
  pages = 	 "334--344",
  month = 	 ICSE2014date,
  address = 	 ICSE2014addr,
}



@InProceedings{Muslu2013,
  author = 	 "K{\i}van{\c{c}} Mu{\c{s}}lu",
  authorASCII =  "Kivanc Muslu",
  title = 	 "Integrating systematic exploration, analysis, and maintenance in software development",
  booktitle = ICSE2013,
  year = 	 2013,
  pages = 	 "1389--1392",
  month = 	 ICSE2013date,
  address = 	 ICSE2013addr,
}




@InProceedings{LoNZ2015,
  author = 	 "David Lo and Nachiappan Nagappan and Thomas Zimmermann",
  title = 	 "How practitioners perceive the relevance of software engineering research",
  booktitle = FSE2015,
  year = 	 2015,
  NEEDpages = 	 "*",
  month = 	 FSE2015date,
  address = 	 FSE2015addr,
}


@Article{Hoare1981,
  author = 	 "Charles Antony Richard Hoare",
  title = 	 "The emperor's old clothes",
  journal = 	 CACM,
  year = 	 1981,
  volume = 	 24,
  number = 	 2,
  pages = 	 "75--83",
  month = 	 feb,
}


@InProceedings{CaliskanIslamHLNVYG2015,
  author = 	 "Aylin Caliskan-Islam and Richard Harang and Andrew Liu and Arvind Narayanan and Clare Voss and Fabian Yamaguchi and Rachel Greenstadt",
  title = 	 "De-anonymizing programmers via code stylometry",
  booktitle = USENIXSec2015,
  year = 	 2015,
  pages = 	 "255--270",
  month = 	 USENIXSec2015date,
  address = 	 USENIXSec2015addr,
  abstract =
   "Source code authorship attribution is a significant privacy threat to
    anonymous code contributors. However, it may also enable attribution of
    successful attacks from code left behind on an infected system, or aid in
    resolving copyright, copyleft, and plagiarism issues in the programming
    fields. In this work, we investigate machine learning methods to
    de-anonymize source code authors of C/C++ using coding style. Our Code
    Stylometry Feature Set is a novel representation of coding style found in
    source code that reflects coding style from properties derived from
    abstract syntax trees.
    \par
    Our random forest and abstract syntax tree-based approach attributes more
    authors (1,600 and 250) with significantly higher accuracy (94% and 98%) on
    a larger data set (Google Code Jam) than has been previously
    achieved. Furthermore, these novel features are robust, difficult to
    obfuscate, and can be used in other programming languages, such as
    Python. We also find that (i) the code resulting from difficult programming
    tasks is easier to attribute than easier tasks and (ii) skilled programmers
    (who can complete the more difficult tasks) are easier to attribute than
    less skilled programmers.",
}












@InProceedings{MurphyHillZN2014,
  author = 	 "Emerson Murphy-Hill and Thomas Zimmermann and Nachiappan Nagappan",
  title = 	 "Cowboys, ankle sprains, and keepers of quality: How is video game development different from software development?",
  booktitle = ICSE2014,
  year = 	 2014,
  pages = 	 "1--11",
  month = 	 ICSE2014date,
  address = 	 ICSE2014addr,
}







@InProceedings{SeoSEAB2014,
  author =       "Hyunmin Seo and Caitlin Sadowski and Sebastian Elbaum and Edward Aftandilian and Robert Bowdidge",
  title =        "Programmers' build errors: A case study (at {Google})",
  booktitle = ICSE2014,
  year =      2014,
  pages =     "724--734",
  month =     ICSE2014date,
  address =   ICSE2014addr,
  abstract =
   "Building is an integral part of the software development
    process. However, little is known about the errors occurring in this
    process. In this paper, we present an empirical study of 26.6 million
    builds produced during a period of nine months by thousands of
    developers. We describe the workflow through which those builds are
    generated, and we analyze failure frequency, error types, and resolution
    efforts to fix those errors. The results provide insights on how a large
    organization build process works, and pinpoints errors for which further
    developer support would be most effective.",
}

@InProceedings{NarayananR2015,
  author =       "Krishna Narasimhan and Christoph Reichenbach",
  title =        "Copy and paste redeemed",
  booktitle = ASE2015,
  year =      2015,
  pages =     "630-640",
  month =     ASE2015date,
  address =   ASE2015addr,
}



@InProceedings{ChristakisMW2016,
  author =       "Maria Christakis and Peter M{\"u}ller and Valentin W{\"u}stholz",
  title =        "Guiding dynamic symbolic execution toward unverified program executions",
  booktitle = ICSE2016,
  year =      2016,
  NEEDpages =     "*",
  month =     ICSE2016date,
  address =   ICSE2016addr,
}


@InProceedings{MatichukMAJKS2015,
  author =       "Daniel Matichuk and Toby Murray and June Andronick and Ross Jeffery and Gerwin Klein and Mark Staples",
  title =        "Empirical study towards a leading indicator for cost of formal software verification",
  booktitle = ICSE2015,
  year =      2015,
  NEEDpages =     "*",
  month =     ICSE2015date,
  address =   ICSE2015addr,
}


@InProceedings{SalmanTMJ2015,
  author =    "Iflaah Salman and Ay{\c{s}}e {Tosun Misirli} and Natalia Juristo",
  title =     "Are Students Representatives of Professionals in Software Engineering Experiments?",
  booktitle = ICSE2015,
  year =      2015,
  pages =     "666-676",
  month =     ICSE2015date,
  address =   ICSE2015addr,
}

@inproceedings{Pham14,
 author = {Pham, Raphael and Kiesling, Stephan and Liskin, Olga and Singer, Leif and Schneider, Kurt},
 title = {Enablers, Inhibitors, and Perceptions of Testing in Novice Software Teams},
 booktitle = {ACM SIGSOFT International Symposium on Foundations of Software Engineering (FSE)},
 year = {2014},
 isbn = {978-1-4503-3056-5},
 address = {Hong Kong, China},
 pages = {30--40},
 doi = {10.1145/2635868.2635925},
}


@inproceedings{Kery:2016:EPP:2901739.2903497,
 author = {Kery, Mary Beth and Le Goues, Claire and Myers, Brad A.},
 title = {Examining Programmer Practices for Locally Handling Exceptions},
 booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories},
 series = {MSR '16},
 year = {2016},
 isbn = {978-1-4503-4186-8},
 location = {Austin, Texas},
 pages = {484--487},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/2901739.2903497},
 doi = {10.1145/2901739.2903497},
 acmid = {2903497},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Boa, GitHub, Java exceptions, error handlers},
}

@inproceedings{Nakshatri:2016:AEH:2901739.2903499,
 author = {Nakshatri, Suman and Hegde, Maithri and Thandra, Sahithi},
 title = {Analysis of Exception Handling Patterns in Java Projects: An Empirical Study},
 booktitle = {Proceedings of the 13th International Conference on Mining Software Repositories},
 series = {MSR '16},
 year = {2016},
 isbn = {978-1-4503-4186-8},
 location = {Austin, Texas},
 pages = {500--503},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/2901739.2903499},
 doi = {10.1145/2901739.2903499},
 acmid = {2903499},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Boa, Github, Java exception handling, best practices},
}



@InProceedings{GousiosSB2016,
  author =       "Gousios, Georgios and Storey, Margaret-Anne and Bacchelli, Alberto",
  title =        "Work practices and challenges in pull-based development:  the contributor's perspective",
  booktitle = ICSE2016,
  year =      2016,
  pages =     "285--296",
  month =     ICSE2016date,
  address =   ICSE2016addr,
}




@InProceedings{QiLAR2015,
  author =       "Qi, Zichao and Long, Fan and Achour, Sara and Rinard, Martin",
  title =        "An analysis of patch plausibility and correctness for generate-and-validate patch generation systems",
  booktitle = ISSTA2015,
  year =      2015,
  pages =     "24--36",
  month =     ISSTA2015date,
  address =   ISSTA2015addr,
}


@InProceedings{DeweyNH2015,
  author =       "Dewey, Kyle and Nichols, Lawton and Hardekopf, Ben",
  title =        "Automated data structure generation: Refuting common wisdom",
  booktitle = ICSE2015,
  year =      2015,
  pages =     "32--43",
  month =     ICSE2015date,
  address =   ICSE2015addr,
}


@InProceedings{YangXLCML2014,
  author =       "Yang, Wenhua and Xu, Chang and Liu, Yepang and Cao, Chun and Ma, Xiaoxing and Lu, Jian",
  title =        "Verifying Self-adaptive Applications Suffering Uncertainty",
  booktitle = ASE2014,
  year =      2014,
  pages =     "199--210",
  month =     ASE2014date,
  address =   ASE2014addr,
}


@InProceedings{MadsenTASM2016,
  author =       "Madsen, Magnus and Tip, Frank and Andreasen, Esben and Sen, Koushik and M{\o}ller, Anders",
  authorASCII =       "Madsen, Magnus and Tip, Frank and Andreasen, Esben and Sen, Koushik and Moller, Anders",
  title =        "Feedback-directed instrumentation for deployed {JavaScript} applications",
  booktitle = ICSE2016,
  year =      2016,
  pages =     "899--910",
  month =     ICSE2016date,
  address =   ICSE2016addr,
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% LocalWords: GhezziJM Ghezzi Mehdi Jazayeri Mandrioli NJ ISBN Belady BasitRJ Xu
% LocalWords: Sommerville Wokingham InProceedings VandevoordeG Guttag Hamid STL
% LocalWords: Vandevoorde booktitle dec StreckenbachS Mirko Gregor al Basit XVCL
% LocalWords: Streckenbach Snelting KABA addr Kataoka ICSM KataokaEGN Damith TSE
% LocalWords: Kataoka's Kremenek Ashcraft Junfeng Engler FSE KremenekAYE ErnstBN
% LocalWords: Rajapakse Jarzabek NEEDpages CCFinder HenkelD Henkel Bod Balzer
% LocalWords: Amer Diwan CatchUp BCELMethod MandelinXBK Mandelin Bodik Cheatham
% LocalWords: Rastislav Kimmelman authorSEARCHABLE Jungloid jungloid SW Boehm
% LocalWords: jungloids composable int TRW's jul BalzerCG nov sep Walkthroughs
% LocalWords: TechReport UWCSE OPTkey UWCSEaddr aug Opdyke CC MensT XP BasitJ
% LocalWords: Tourw feb Tourwe Misc Borland howpublished JavaOne jun Robillard
% LocalWords: ChowN Kingsum ObjectWindows widenings datapoints RutarAF Livshits
% LocalWords: Rutar Almazan JLint PMD KimSNM Miryung dnsjava higo ist LivshitsZ
% LocalWords: Vibha Sazawal osaka ac jp ISSRE Bandera ESC overclaim co DynaMine
% LocalWords: asitJ Itemset FIM IDs MayrandLM tokenization java Zimmermann baz
% LocalWords: OpenMBeanAttributeInfoSpport ObjectFactory jEdit checkins itemset
% LocalWords: OpenMBeanParameterInfoSpport Apriori checkin SullivanGSCSTR Cai
% LocalWords: Yuanyuan Yuanfang Macneil Shonle Nishit Tewari Hridesh LiZ Zhou
% LocalWords: Rajan un AspectJ Zhenmin PR PostgreSQL HTTP Engler's FireWire rba
% LocalWords: FindBugs Braude Budgen CoplienS Coplien FelleisenFFK Orla IEEE UI
% LocalWords: Felleisen Findler CohoonD Cohoon KuhnGG Greevy PCODA LSI Urbana
% LocalWords: Taghi Khoshgoftaar Ruqun Shan Faundez Sekirkin Boland MMR Mens QA
% LocalWords: EisenbarthKS Eisenbarth Koschke GreevyD phane Ducasse oct APIs Ko
% LocalWords: CMSR GreevyDG WongGH Gokhale Horgan ZaidmanCDP Zaidman Champaign
% LocalWords: Toon Calders Demeyer Paredaens Webmining webmining JMeter Parnin
% LocalWords: Kleinberg's HaRDRCRW Jungwoo Rossbach Indrajit Hany Inlining DOI
% LocalWords: Witchel Borland's authorASCII MurphyHillPB toolsmiths downcasting
% LocalWords:  refactorable Englewood McGraw subsequences getters checkable Yan
% LocalWords:  Winograd ApiwattanapongOH Taweesup Apiwattanapong supersededby
% LocalWords:  ASEjournal JDiff usesDaikonAsTestSubject JABA XuRTQ Guoqing Feng
% LocalWords:  Atanas Rountev Qin checkpointed DwyerKE Dwyer Kinneer Elbaum KoM
% LocalWords:  optimizine FSAs Emre AjaxScope Kiciman SOSP redeployabiliy Manos
% LocalWords:  Whyline timeline JFrame prefast JonesH totalpassed totalfailed
% LocalWords:  RenierisR Renieris Reiss iComment Gopal Radatz issn doi ADT isbn
% LocalWords:  JeongKZ Jeong Gaeul Sunghun WalradS Walrad Strom SCM BallKPS Siy
% LocalWords:  NagappanBZ Nagappan Nachiappan Rochkind IEEETSE SCCS BaconCPR
% LocalWords:  Yiling Parkes Rao Malvika Sakthivel CACM apr FritzM subtable
% LocalWords:  DSketch Cossette ApelLBLK2011 Apel Jorg Liebig Brandl Lengauer
% LocalWords:  Putnam78 BalzerCG83 Kastner Semistructured FSE2011 FSE2011addr
% LocalWords:  FSE2011date semistructured FSTGENERATOR FSTMERGE Boehm87 Su
% LocalWords:  top10 Griswold91 Opdyke92 Fowler2000 Parr94 CC94 CC94addr ICSM96
% LocalWords:  CC94date MensT2004 StreckenbachS2004 OOPSLA2004 OOPSLA2004addr
% LocalWords:  OOPSLA2004date KataokaEGN01 HenkelD2005 ICSE2005 ICSE2005addr ek
% LocalWords:  ICSE2005date Perkins2005 MurphyHillPB2009 ICSE2009 ICSE2009addr
% LocalWords:  ICSE2009date researchers' Borland2004 ChowN96 ICSM96addr FSE2005
% LocalWords:  ICSM96date MandelinXBK2005 PLDI2005 PLDI2005addr PLDI2005date AO
% LocalWords:  RutarAF2004 ISSRE2004 ISSRE2004addr ISSRE2004date tradeoffs
% LocalWords:  KimSNM2005 FSE2005addr FSE2005date GhezziJM91 Lamb88 Erlikh
% LocalWords:  Pressman92 VandevoordeG94 runtime KremenekAYE2004 FSE2004 Przyby
% LocalWords:  FSE2004addr FSE2004date BasitRJ2005 parameterization ErnstBN2002
% LocalWords:  BasitJ2005 Baker95 MayrandLM96 dependences LivshitsZ2005 AOP OOP
% LocalWords:  SullivanGSCSTR2005 Przybylek2011 Przybylek FASE2011 FASE2011addr
% LocalWords:  FASE2011date modularizing modularizable modularized refactored
% LocalWords:  LOC LCOM OO LiZ2005 Simon96 Braude2003 Budgen2003 KuhnGG2005
% LocalWords:  Winograd1996 CoplienS1995 FelleisenFFK2001 CohoonD2005 PCODA2005
% LocalWords:  PCODA2005addr PCODA2005date dimensionality ISSRE'00 GreevyD2005
% LocalWords:  EisenbarthKS2003 CMSR2005 CMSR2005addr CMSR2005date GreevyDG2005
% LocalWords:  ICSM2005 ICSM2005addr ICSM2005date WongGH2000 ZaidmanCDP2005 ASE
% LocalWords:  HaRDRCRW2007 PLDI2007 PLDI2007addr PLDI2007date backtrace Orso
% LocalWords:  unscalable LaTeX's ApiwattanapongOH2004 Alessandro Harrold
% LocalWords:  differencing ASE2004 ASE2004addr ASE2004date XuRTQ2007 FSE2007
% LocalWords:  ApiwattanapongOH2007 checkpointing FSE2007addr FSE2007date Ko
% LocalWords:  DwyerKE2007 ICSE2007 ICSE2007addr ICSE2007date KoM2008 ICSE2008
% LocalWords:  ICSE2008addr ICSE2008date Weise's JonesH2005 ASE2005 ASE2005addr
% LocalWords:  ASE2005date RenierisR2003 unexamined NLP OOPSLA2009 Ko Ko
% LocalWords:  OOPSLA2009companion OOPSLA2009date Downcasts equational AWT
% LocalWords:  downcasts Cook2009 OOPSLA2009addr Brooks1975 JeongKZ2009 FSE2009
% LocalWords:  FSE2009addr FSE2009date WalradS2002 BallKPS97 ICSE97addr Zeller
% LocalWords:  ICSE97date NagappanBZ2006 Andreas ICSE2006 ICSE2006addr ICSE2010
% LocalWords:  ICSE2006date Rochkind75 BaconCPR2009 Sakthivel2007 FritzM2010 Ko
% LocalWords:  ICSE2010addr ICSE2010date panopticon Norman90 PTRSLB Khaled El
% LocalWords:  Emam Saida Benlarbi Nishith Goel Shesh Rai rg stner ost Bj orn
% LocalWords:  Regnell Claes Wohlin Runeson PSP Pankratius Scala Goues Vogt Yeh
% LocalWords:  LeGouesDVFW2012 Weimer Westley ICSE2012 ICSE2012addr Tsung Roehm
% LocalWords:  ICSE2012date Hsiang Sikuli filenames Tobias Tiarks Rainer Walid
% LocalWords:  Maalej I2 Erlikh2000 Eastwood1993 Moad1990 Moad AFIPS Abreu
%  LocalWords:  LientzS1981 Lientz Bennet ZelkowitzSG1979 Zelkowitz COCOMO
%  LocalWords:  Seacord Plakosh McConnell2006 Jones2011 Su2006 ParninO2011
%  LocalWords:  ISSTA2011 ISSTA2011date ISSTA2011addr Tetris NanoXML Rui
%  LocalWords:  ASE2003 ASE2003date ASE2003addr SteimannFA2013 Steimann T1
%  LocalWords:  Frenkel locators ISSTA2013 ISSTA2013date ISSTA2013addr Yoo
%  LocalWords:  ZhangZK2013 Lingming Khurshid Sarfraz OOPSLA2013 Stasko P'
%  LocalWords:  OOPSLA2013date OOPSLA2013addr JonesHS2002 ICSE2002 DBLP T2
%  LocalWords:  ICSE2002date ICSE2002addr YooNH2011 optimisation Dstar n11
%  LocalWords:  n10 n01 DiGiuseppeJ2015 DiGiuseppe JEmpiricalSE Foo Omesh
%  LocalWords:  SanthiarPK2014 Santhiar Anirudh Pandita Kanade Aditya tmp
%  LocalWords:  normf DoubleMatrix norm2 inv SimpleMatrix T3 mult Ghafari
%  LocalWords:  GhafariGMT2014 Mocci Tamburrelli ICPC2014 ICPC2014date Pmd
%  LocalWords:  ICPC2014addr Rahman Khatri Devanbu Jlint foo Przyby≈Çek Vo
%  LocalWords:  Jlint TanYKZ2007 SOSP2007 SOSP2007date SOSP2007addr JB10
%  LocalWords:  Garret√≥n GenProg Schulte DiLorenzo ASPLOS'13 ClearView Vu
%  LocalWords:  segfault underperforms ChangYM2010 CHI2010 CHI2010date Jne
%  LocalWords:  CHI2010addr inproceedings Jalbert Proc Zhendong POPL'13 QP
%  LocalWords:  bessel asympx GSL Arjun Guha ReitBlatt OpenFlow NetCore lu
%  LocalWords:  ICSE'05 LaToza learnability JohnsonSMHB2013 Yoonki PREfix
%  LocalWords:  Bowdidge ICSE2013 ICSE2013date ICSE2013addr BushPS2000 Zou
%  LocalWords:  Gorla Corapi Magee Katsumi Inoue NoMPRoL D'Ippolito Khomh
%  LocalWords:  Braberman Foutse Dhaliwal Tejinder Ying numpages url acmid
%  LocalWords:  Piscataway Mika antyl Emelie Engstr RRs TRs Jiaping GMA de
%  LocalWords:  Mcilroy dex2jar ASM regexes recharg batt ery RQ1 radaee af
%  LocalWords:  pdf Sonal Mahajan ICST PID mockups Fogarty's Huyen OLED
%  LocalWords:  Smartphones smartphones Nyx Julien IoT cloudlets cloudlet
%  LocalWords:  PDS multihop metadata Nirmalya Archan Misra Sajal Das Jit
%  LocalWords:  Biswas PerCom QoINF QoINFs MusluBM2015 Meliou ISSTA2015
%  LocalWords:  ISSTA2015date ISSTA2015addr MusluBM2013 FSE2013 Nachi Liu
%  LocalWords:  FSE2013date FSE2013addr MusluBNC2014 Jacek Czerwonka Hoare
%  LocalWords:  ICSE2014 ICSE2014date ICSE2014addr Muslu2013 LoNZ2015 Voss
%  LocalWords:  FSE2015 FSE2015date FSE2015addr Hoare1981 Aylin Caliskan
%  LocalWords:  CaliskanIslamHLNVYG2015 Harang Narayanan Yamaguchi Palyart
%  LocalWords:  Greenstadt anonymizing stylometry USENIXSec2015 copyleft
%  LocalWords:  USENIXSec2015date USENIXSec2015addr anonymize NIER UMass
%  LocalWords:  anonymization Einar H√∏st Bjarte √òstvold containsField Jin
%  LocalWords:  findField getField Tianyin Xuepeng Shankar Pasupathy Rukma
%  LocalWords:  Talwadker FlexJava Jongse Hadi Esmaeilzadeh Xin Mayur Naik
%  LocalWords:  EnerJ Bornholt Stolee MurphyHillZN2014 Bixie Philipp ummer
%  LocalWords:  Schaf Ruemmer Schaef Joa Shuvendu Lahiri ClusterChanges
%  LocalWords:  Estler Nordio Furia Wenhua Yepang Chun Cao Xioxing Jian
